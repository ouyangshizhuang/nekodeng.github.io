<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于给hexo博客增加音乐页面（使用Aplayer和MetingJS插件）</title>
      <link href="/posts/hexo-music-aplayer.html"/>
      <url>/posts/hexo-music-aplayer.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">前言: 作为一个音乐发烧友，一直想在博客网站里弄一个音乐播放歌单页面，现在它来了。本文基于matery主题，利用hexo-tag-aplayer插件和MetingJS实现。</div><h3 id="新建音乐页面"><a href="#新建音乐页面" class="headerlink" title="新建音乐页面"></a>新建音乐页面</h3><ol><li>在source文件下新建一个<code>musics</code>文件</li><li>在该文件里新建一个<code>index.md</code>文件，其中文件内容为：</li></ol><pre><code>---title: musicstype: &quot;musics&quot;layout: &quot;musics&quot;---</code></pre><ol><li>在主题配置文件<code>_config.yml</code>下，增加音乐页面链接和标题</li></ol><pre><code>musics:  url: /musics</code></pre><h3 id="新建musics-ejs文件"><a href="#新建musics-ejs文件" class="headerlink" title="新建musics.ejs文件"></a>新建musics.ejs文件</h3><p>在主题<code>layout</code>文件下新建<code>musics.ejs</code>文件，<br>这里在<code>musics.ejs</code>文件直接贴代码即可，根据自定义可修改歌单id等信息。源代码如下：</p><pre><code>&lt;!-- 添加网易云我喜欢的歌曲模块 --&gt;&lt;p&gt;网易云2019年度歌单top10&lt;/p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayedist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayemin.js&quot;&gt;&lt;/script&gt;&lt;!-- require MetingJS --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2/dist/Metinmin.js&quot;&gt;&lt;/script&gt;  &lt;meting-js style=&quot;margin-top: 1.5rem;width: auto;height: auto&quot;  server=&quot;netease&quot;  type=&quot;playlist&quot;  id=&quot;3155294100&quot;  order= &quot;random&quot;  theme=&quot;#ad7a86&quot;  loop=&quot;all&quot;  autoplay=&quot;false&quot;  storageName=&quot;aplayer-setting&quot;  hideLrc= &quot;false&quot;  &gt;  &lt;/meting-js&gt;  &lt;style&gt;      .aplayer&#123;          margin: 1.5rem 0;      &#125;                &lt;/style&gt;</code></pre><p>效果展示：<br><a href="https://nekodeng.gitee.io/musics/" class="LinkCard" target="_blank">itsNekoDeng 音乐台</a></p><div class="note info">总结：若想要在博客文章md文件中引入也是可以的，直接粘贴上述ejs文件代码即可。</div>]]></content>
      
      
      <categories>
          
          <category> 关于hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客增加音乐页面 </tag>
            
            <tag> Aplayer和MetingJS插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome小恐龙跑酷</title>
      <link href="/posts/chrome-dragon-game.html"/>
      <url>/posts/chrome-dragon-game.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">前言: 偶然间在一个大佬博客里发现的，挺有趣的，就是离线状态下chrome浏览器会出现的那个小游戏。</div><div class="note info">操作介绍：先点击小恐龙<br>开始游戏：再按 “空格键” 或者 “点击屏幕” <br>跳跃：“空格键”  <br>爬行： ↓ <br>如果右上角时间数值未变或者较慢，请多点击空格或刷新网站加载速度略慢请等待。</div><iframe align="center" width="100%" height="200px" src="https://cdn.xsiy.ltd/site/typecho/game/index.html" frameborder="no" border="0" scrolling="no" marginwidth="0" marginheight="0"></iframe><p>转载自：<br><a href="https://www.xsy.fun/archives/170/" class="LinkCard" target="_blank">将Chrome离线小恐龙嵌入博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 有趣小物件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome小恐龙跑酷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于给hexo博客增加随笔页面（并对页面仿信纸作业纸样式修饰）</title>
      <link href="/posts/imitation-paper-essay.html"/>
      <url>/posts/imitation-paper-essay.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">前言: 本文是给hexo博客增加随笔页面，并对页面仿信纸作业纸样式修饰，基于matery主题，其他主题亦可参考。</div><p>至于为什么要写本文，是因为有一天，突然有了一个想法，想把以前初高中写的那些作文，整理一下，上传到博客网站，无论是对于风花雪月，对于以前的一些独特的世界观，那个时期独特的idea，想要通通记录下来。于是就酝酿出来本文了。</p><h3 id="实现效果展示"><a href="#实现效果展示" class="headerlink" title="实现效果展示"></a>实现效果展示</h3><p>首先，直接展示效果图：<br><img src="https://i.loli.net/2020/10/08/es39lOYI25LCVa8.png" alt="仿书信效果图"><br><img src="https://i.loli.net/2020/10/08/edNcnRirmhXFKxt.png" alt><br>效果链接：<a href="https://nekodeng.gitee.io/posts/essay-demo.html" class="LinkCard" target="_blank">啊啊啊这是随笔文章模板</a></p><h3 id="增加essay随笔页面"><a href="#增加essay随笔页面" class="headerlink" title="增加essay随笔页面"></a>增加essay随笔页面</h3><ol><li>在<code>source</code>文件夹下新建一个<code>essay</code>文件，并且在essay文件下新建一个<code>index.md</code>文件，并设置内容为：</li></ol><pre><code>---    title: 🐈随 笔    date: 2020-10-07 15:23:38    type: &quot;essay&quot;    layout: &quot;essay&quot;---</code></pre><ol><li>接着在主题_config文件里加入essay页面导航按钮，这里不赘述了，很简单。<pre><code>essay url: /essay</code></pre></li></ol><h3 id="新建essay-ejs文件"><a href="#新建essay-ejs文件" class="headerlink" title="新建essay.ejs文件"></a>新建essay.ejs文件</h3><p>在<code>layout</code>文件夹下新建一个<code>essay.ejs</code>文件，文件内容，这里我直接贴源码：</p><pre><code>&lt;%- partial(&#39;_partial/bg-cover&#39;) %&gt;&lt;main class=&quot;content&quot;&gt;    &lt;%- partial(&#39;_widget/essay-cloud&#39;) %&gt;&lt;/main&gt;</code></pre><h3 id="对页面进行仿信纸样式修饰"><a href="#对页面进行仿信纸样式修饰" class="headerlink" title="对页面进行仿信纸样式修饰"></a>对页面进行仿信纸样式修饰</h3><p>此部分均为css代码，直接贴在<code>post-detail.ejs</code>文件里即可。</p><pre><code>&lt;style&gt;    .ititle &#123;        margin: 15px 0;        text-align:center;        font-family: &#39;Architects Daughter&#39;, cursive;    &#125;    .ipage &#123;        line-height: 30px;        margin: 0 auto;        padding: 15px 32px 29px;        background-color: #f9f9f9;        box-shadow: 0px 2px 5px 0px rgba(0, 0, 0, 0.26);        -moz-border-radius-bottomleft: 20px 500px;        -moz-border-radius-bottomright: 500px 30px;        -moz-border-radius-topright: 5px 100px;            -webkit-border-bottom-left-radius: 20px 500px;        -webkit-border-bottom-right-radius: 64px 10px;        -webkit-border-top-right-radius: 5px 100px;            border-bottom-left-radius: 20px 500px;        border-bottom-right-radius: 64px 10px;        border-top-right-radius: 5px 100px;                   -webkit-background-size: 100% 30px;        -moz-box-shadow: 0 2px 10px 1px rgba(0, 0, 0, 0.2);        -webkit-box-shadow: 0 2px 10px 1px rgba(0, 0, 0, 0.2);        text-shadow: 0 1px 0 #F6EF97;        position: relative;    &#125;.izhengwen &#123;    position: relative;    top: 0;    left: 0;    z-index: 2;    height: auto;    background: repeating-linear-gradient(to bottom, #f9f9f9, #f9f9f9 31px, #6BA2D8 1px, #f9f9f9);    background-size: 100% 32px;&#125;#articleContent p &#123;    margin: 0&#125;.ititle &#123;    font-family: &#39;Architects Daughter&#39;, cursive;    font-size: 1.45rem!important;    padding: 10px auto;&#125;.izhengwen p &#123;    position: relative;    line-height: 2.2rem!important;    text-indent: 2em;    font-family: &#39;Architects Daughter&#39;, cursive!important;    font-size: 1.45rem!important;&#125;.ipage::before &#123;    content: &quot; &quot;;    display: inline-block;    position: absolute;    top: 0px;    bottom: 0;    right: 52px;    z-index: 4;    width: 4px;    height: 100%;    border-left: 1px solid #fca1a1;&#125;.izhengwen p:nth-child(odd):before &#123;    content: &quot; &quot;;    display: inline-block;    position: absolute;    top: 0;    left: -16px;    z-index: 3;    width: 24px;    height: 24px;    background-color: #fff;    -webkit-border-radius: 50%;    -moz-border-radius: 50%;    border-radius: 50%;    box-shadow: inset 0px 2px 5px 0px rgba(0, 0, 0, 0.26);&#125;.ipage:after &#123;    content: &quot; &quot;;    display: inline-block;    position: absolute;    top: 0;    bottom: 0;    left: 52px;    z-index: 3;    width: 4px;    height: 100%;    border-left: 4px double #fca1a1;&#125;.ipage p &#123;    padding: 0 2em;    color: #333!important;&#125;body.dark .ipage &#123;    opacity: 0.85;&#125;/*小屏幕下(手机类)的样式*/@media only screen and (max-width: 600px) &#123;    .ipage &#123;        padding: 15px 23px 29px;    &#125;    .ipage:after &#123;        left: 36px;    &#125;    .ipage::before &#123;        right: 36px;        &#125;    .ipage p &#123;        padding: 0 0.9em;    &#125;&#125;&lt;/style&gt;</code></pre><h3 id="新建一个md文件作为随笔文章页"><a href="#新建一个md文件作为随笔文章页" class="headerlink" title="新建一个md文件作为随笔文章页"></a>新建一个md文件作为随笔文章页</h3><p>这里我直接给出一个模板随笔文章页，可直接粘贴，其中以下div格式是固定的，不可修改，但可以随意自定义内容文字。</p><pre><code>&lt;div class=&quot;ipage&quot;&gt;  &lt;div class=&quot;ititle&quot;&gt;标题&lt;/div&gt;  &lt;div class=&quot;izhengwen&quot;&gt;    &lt;p&gt;正文&lt;/p&gt;    &lt;p&gt;正文&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>以下是我自拟的一个随笔模板页md文件源码，你可以直接粘贴做修改</li></ul><pre><code>---title: 啊啊啊这是随笔文章模板abbrlink: &#39;essay-demo&#39;tags:  - 随笔categories: 随笔mathjax: true---### 这是博主的随笔板块，后续会更新文章，目前弄好了模板格式~&lt;div class=&quot;ipage&quot;&gt;    &lt;div class=&quot;ititle&quot;&gt;节选自《你若安好便是晴天》- 前言&lt;/div&gt;  &lt;div class=&quot;izhengwen&quot;&gt;    &lt;p&gt;几场梅雨，几卷荷风，江南已是烟水迷离。小院里湿润的青苔在雨中纯净生长。    &lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><p>最后，运行<code>hexo s</code>查看效果，进行调试。</p>]]></content>
      
      
      <categories>
          
          <category> 关于hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客增加随笔页面 </tag>
            
            <tag> 仿信纸作业纸样式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啊啊啊这是随笔文章模板</title>
      <link href="/posts/essay-demo.html"/>
      <url>/posts/essay-demo.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">tips~：桌面端点击右侧竖排 “ 从上至下 ” “ 第三个按钮 ”，展开阅读效果更佳哦~</div><h4 id="这是博主的随笔板块，后续会更新文章，目前弄好了模板格式"><a href="#这是博主的随笔板块，后续会更新文章，目前弄好了模板格式" class="headerlink" title="这是博主的随笔板块，后续会更新文章，目前弄好了模板格式~"></a>这是博主的随笔板块，后续会更新文章，目前弄好了模板格式~</h4><div class="ipage">    <div class="ititle">节选自《你若安好便是晴天》- 前言</div>  <div class="izhengwen">  <p>几场梅雨，几卷荷风，江南已是烟水迷离。小院里湿润的青苔在雨中纯净生长。这个季节，许多人都在打听关于莲荷的消息，以及茉莉在黄昏浮动的神秘幽香。不知多少人会记得有个女子，曾经走过人间四月天，又与莲开的夏季有过相濡以沫的约定。</p>  <p>一个人，一本书，一杯茶，一帘梦。有时候，寂寞是这样叫人心动，也只有此刻，世事才会如此波澜不惊。凉风吹起书页，这烟雨让尘封在书卷里的词章和故事弥漫着潮湿的气息。独倚幽窗，看转角处的青石小巷，一柄久违的油纸伞，遮住了低过屋檐的光阴。</p>  <p>时光微凉，那一场远去的往事被春水浸泡，秋风吹拂，早已洗去铅华，清绝明净。以为历经人生匆匆聚散，尝过尘世种种烟火，应该承担岁月带给我们的沧桑。可流年分明安然无恙，而山石草木是这样毫发无伤。只是曾经许过地老天荒的城，在细雨中越发地清瘦单薄。</p>  <p>青梅煎好的茶水，还是当年的味道；而我们等候的人，不会再来。后来才知道，那一袭素色白衣的女子已化身为燕，去寻觅水乡旧巢。她走过的地方，有一树一树的花开，她呢喃的梁间，还留着余温犹存的梦。有人说，她是个冰洁的女子，所以无论人世如何变迁，她都有着美丽的容颜。有人说，她是个理智的女子，不管面临怎样的诱惑，最后都可以全身而退。</p>  <p>她叫林徽因，出生于杭州，是许多人梦中期待的白莲。她在雨雾之都伦敦，发生过一场空前绝后的康桥之恋。她爱过三个男子，爱得清醒，也爱得平静。徐志摩为她徜徉在康桥，深情地等待一场旧梦可以归来。梁思成与她携手走过千山万水，为完成使命而相约白头。金岳霖为她终身不娶，痴心不改地守候一世。可她懂得人生飘忽不定，要学会随遇而安。</p>  </div></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于给hexo博客增加相册页面（实现瀑布流相册，实现加密相册）</title>
      <link href="/posts/waterfall-flow-photo-album.html"/>
      <url>/posts/waterfall-flow-photo-album.html</url>
      
        <content type="html"><![CDATA[<div class="note info">前言: 本文是关于给自己的博客网站添加一个相册页面，并且实现瀑布流相册效果，基于matery主题，其他主题亦可参考。</div><ul><li>首先，直接上效果图，详细浏览地址：<br><a href="https://nekodeng.gitee.io/gallery/" class="LinkCard" target="_blank">关于给hexo博客增加相册页面（实现瀑布流相册）</a></li></ul><p><img src="https://i.loli.net/2020/10/05/9XhxmzlRn3iM7fI.png" alt="相册页面"><br><img src="https://i.loli.net/2020/10/05/wqgKjcEi58APJ3o.png" alt="相册图片展示页面"></p><h3 id="新建相册页面"><a href="#新建相册页面" class="headerlink" title="新建相册页面"></a>新建相册页面</h3><ol><li>在站点的<code>source</code>文件夹下面新建一个<code>gallery</code>相册页面。<pre><code>hexo new page gallery</code></pre></li><li>打开新建的gallery文件夹，里面会有一个index.md文件，设置<code>index.md</code>文件内容。</li></ol><pre><code>---title: gallerydate: 2020-10-05 12:00:00type: &quot;gallery&quot;layout: &quot;gallery&quot;---</code></pre><h3 id="新建相册图片展示页面"><a href="#新建相册图片展示页面" class="headerlink" title="新建相册图片展示页面"></a>新建相册图片展示页面</h3><ol><li><p>在gallery文件夹（也就是刚才创建的那个文件），可以在里面新建一些文件夹，也就是相册文件夹。例如：<br><img src="https://i.loli.net/2020/10/05/AvmYWoa7flPeOtZ.png" alt></p></li><li><p>然后在新建的相册文件夹里，分别在每个文件夹里新建文件<code>index.md</code>，例如：<br><img src="https://i.loli.net/2020/10/05/yDGv1lYQH4NbfS5.png" alt><br>并分别设置每个<code>index.md</code>文件内容：</p></li></ol><pre><code>---title: 峨眉山之行date: 2020-10-02 23:00:17type: &quot;galleries&quot;layout: &quot;galleries&quot;password: ---</code></pre><h4 id="实现加密相册"><a href="#实现加密相册" class="headerlink" title="实现加密相册"></a>实现加密相册</h4><div class="note info">注意：此处的galleries代表接下里要新增的galleries.ejs文件，而password是给相册设置访问密码。</div><p>在上面<code>index.md</code>文件中，可以实现加密功能，加密使用<code>SHA256</code>加密，所以在加密前需要先将你的密码转换成<code>SHA256格式</code>然后输入到最上面的创建相片页面的index.md的<code>password</code>里面。至于SHA256加密，请自行网上搜索在线生成，例如: <a href="http://www.ttmd5.com/hash.php?type=9">http://www.ttmd5.com/hash.php?type=9</a></p><h3 id="编辑主题导航栏加入相册按钮"><a href="#编辑主题导航栏加入相册按钮" class="headerlink" title="编辑主题导航栏加入相册按钮"></a>编辑主题导航栏加入相册按钮</h3><p>在站点主题<code>_config.yml</code>文件下<code>menu</code>菜单下新增gallery页面。<br>这应是第一步做的事，新建页面后应该立即添加，因为很容易忘却。</p><pre><code># 配置菜单导航的名称、路径和图标icon.menu:  gallery    url: /gallery</code></pre><h3 id="新建相册的json文件"><a href="#新建相册的json文件" class="headerlink" title="新建相册的json文件"></a>新建相册的json文件</h3><ol><li><p>同样在站点的<code>source</code>文件夹下面新建一个<code>gallery.json</code>文件。<br>设置文件内容：（以我的为例，使用时修改成自己的）<br>这里图片是放在图床上的，可自定义修改图片链接。</p><pre><code> [   &#123;   &quot;name&quot;: &quot;峨眉山之行&quot;,   &quot;cover&quot;: &quot;https://i.loli.net/2020/10/05/kBcvAf7INgMLaem.jpg&quot;,   &quot;date&quot;: &quot;2017-10&quot;,   &quot;description&quot;: &quot;峨眉山之行&quot;,   &quot;url_name&quot;: &quot;峨眉山之行&quot;,   &quot;album&quot;: [       &#123;           &quot;img_url&quot;: &quot;https://i.loli.net/2020/10/05/qtOevHpw5XImS1J.jpg&quot;,           &quot;title&quot;: &quot;峨眉山之行&quot;,           &quot;describe&quot;: &quot;峨眉山之行&quot;       &#125;,       &#123;           &quot;img_url&quot;: &quot;https://i.loli.net/2020/10/05/4acvniMKTx8euqp.jpg&quot;,           &quot;title&quot;: &quot;峨眉山之行&quot;,           &quot;describe&quot;: &quot;峨眉山之行&quot;       &#125;,       &#123;           &quot;img_url&quot;: &quot;https://i.loli.net/2020/10/05/4acvniMKTx8euqp.jpg&quot;,           &quot;title&quot;: &quot;峨眉山之行&quot;,           &quot;describe&quot;: &quot;峨眉山之行&quot;       &#125;     ]   &#125; ]</code></pre></li></ol><div class="note info">注意：设置该json文件里的url_name属性值时，url_name属性值必须和对应相册文件里的index.md文件的title属性值一样。<br>所以建议，除了describe值自定义，其他属性值一律采用和title值一样的。</div><h3 id="编辑相册及图片展示页面"><a href="#编辑相册及图片展示页面" class="headerlink" title="编辑相册及图片展示页面"></a>编辑相册及图片展示页面</h3><p>在站点主题文件夹下layout文件夹下新建文件 <code>gallery.ejs</code> 和 <code>galleries.ejs</code><br><img src="https://i.loli.net/2020/10/05/DOVRkM3NyHpexn5.png" alt></p><ul><li>gallery.ejs： 相册页面</li><li>galleries.ejs：相册图片展示页面</li></ul><h4 id="编辑相册页面gallery-ejs"><a href="#编辑相册页面gallery-ejs" class="headerlink" title="编辑相册页面gallery.ejs"></a>编辑相册页面gallery.ejs</h4><p>编辑<code>gallery.ejs</code>内容：<br>以下是我的源代码，若同样主题，即可直接复制，其他主题可做参考，根据需要修改即可使用。</p><pre><code>&lt;%- partial(&#39;_partial/bg-cover&#39;) %&gt;&lt;!-- 增加相册显示的特效样式 --&gt;&lt;style&gt;    .photo &#123;        padding: 0 40px!important;        display: inline-block;        position: relative;        transition: all .6s;    &#125;    .biaotiss &#123;        padding: 8px 10px;        color: #4c4c4e;        text-align: center;        font-weight: 400;        font-size: 18px;    &#125;    .img-item &#123;        padding: .2rem;        background-color: #fff;        border-radius: 10px;        box-shadow: 1px 2px 2px 0 #aaa;        transition: all .4s cubic-bezier(.63,.15,.03,1.12);        margin-bottom: 20px;    &#125;    .photo:nth-child(odd) &#123;        transform: rotateZ(-5deg);    &#125;        .photo:nth-child(even) &#123;        transform: rotateZ(5deg);    &#125;    .text_des&#123;        position: absolute;        width: 92%;        height: 100%;        top: 0;        color: #000;        overflow: hidden;    &#125;    .text_des h3&#123;        margin: 5px 0 8px 0px;        right: 40px;        font-size: 1.5rem;        font-weight: bold;        line-height: 1.7rem;        position: absolute;        top: 10%;        font-style: italic;        text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);        /*transform: translateX(200px);  */    &#125;    .text_des p&#123;        left: 15px;        position: absolute;        top: 50%;    /*    transform: translateX(-200px);         transition-delay: 0.2s;    */    &#125;    .my-gallery .photo img &#123;        border-radius: 10px;        height: 240px;    &#125;    .card .card-content &#123;        padding: 24px 24px 24px 24px;    &#125;    .miaoshus &#123;        padding: 20px;        border: 1px dashed #e6e6e6;        color: #969696;        position: relative;        display: inline-block;        width: 95%;        background: #fbfbfb50;        border-radius: 10px;        font-size: 16px;        margin: 12px auto;    &#125;    body.dark .miaoshus &#123;        background: 0 0;        border: 1px dashed #888;    &#125;    .img-item &#123;            transition: all 0.4s ease-out;        &#125;        .img-item a img&#123;            opacity: 1;            transition: all 0.4s ease-out;        &#125;        .img-item a:hover img&#123;            opacity: 0.8;        &#125;           .biaotiss &#123;            font-family: MV Boli;        &#125;           .miaoshus .title &#123;        font-family: MV Boli;    &#125;     /*大屏幕下(桌面类)的样式*/    @media only screen and (min-width: 993px) &#123;        .text_des h3&#123;            transform: translateX(200px);        &#125;        .text_des p&#123;            transform: translateX(-200px);             transition-delay: 0.2s;        &#125;        .animate-text &#123;            opacity: 0;            transition: all 0.6s ease-in-out;         &#125;    &#125;    /*小屏幕下(桌面类)的样式*/    @media only screen and (max-width: 500px) &#123;        .my-gallery .photo img &#123;            height: 186px;        &#125;    &#125;&lt;/style&gt;&lt;main class=&quot;content&quot;&gt;    &lt;div class=&quot;container chip-container&quot;&gt;        &lt;div class=&quot;card&quot;&gt;            &lt;div class=&quot;card-content&quot;&gt;                &lt;div class=&quot;tag-title center-align&quot;&gt;                    &lt;div class=&quot;miaoshus&quot;&gt;                        &lt;div class=&quot;title center-align&quot;&gt;“ &lt;%- theme.gallery.title %&gt; ”&lt;/div&gt;                        “ 这里有光影流年，还有两朵穿衣裳的云，相拥在明天的河岸。”                                          &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;my-gallery&quot;&gt;                    &lt;div class=&quot;row&quot;&gt;                    &lt;% if (site.data &amp;&amp; site.data.gallery) &#123; %&gt;                        &lt;% var gallery = site.data.gallery; %&gt;                        &lt;% for (var i = 0, len = gallery.length; i &lt; len; i++) &#123; %&gt;                            &lt;% var photo = gallery[i]; %&gt;                            &lt;% if (photo.cover)&#123; %&gt;                            &lt;div class=&quot;photo col s12 m6 l4&quot;&gt;                                &lt;div class=&quot;img-item&quot;&gt;                                    &lt;a href=&quot;./&lt;%- photo.url_name %&gt;&quot;&gt;                                        &lt;img src=&quot;/medias/loading.svg&quot; data-src=&quot;&lt;%- photo.cover %&gt;&quot; class=&quot;responsive-img&quot; alt=&quot;img&quot;+&lt;%- i %&gt; /&gt;                                        &lt;div class=&quot;biaotiss&quot;&gt;“ &lt;%- photo.name %&gt; ”&lt;br&gt;“ &lt;%- photo.date %&gt; ”&lt;/div&gt;                                    &lt;/a&gt;                                &lt;/div&gt;                                                          &lt;/div&gt;                            &lt;% &#125; %&gt;                        &lt;% &#125; %&gt;                    &lt;% &#125; %&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        start()            $(window).on(&#39;scroll&#39;, function()&#123;            start();        &#125;)        function start()&#123;              //.not(&#39;[data-isLoaded]&#39;)选中已加载的图片不需要重新加载            $(&#39;.container img&#39;).not(&#39;[data-isLoaded]&#39;).each(function()&#123;                var $node = $(this)                if( isShow($node) )&#123;                    loadImg($node);                &#125;            &#125;);        &#125;        //判断一个元素是不是出现在窗口(视野)        function isShow($node)&#123;            return $node.offset().top &lt;= $(window).height() + $(window).scrollTop();        &#125;        //加载图片        function loadImg($img)&#123;        //.attr(值)        //.attr(属性名称,值)            $img.attr(&#39;src&#39;, $img.attr(&#39;data-src&#39;)); //把data-src的值 赋值给src            $img.attr(&#39;data-isLoaded&#39;, 1);//已加载的图片做标记        &#125;    &lt;/script&gt;&lt;/main&gt;</code></pre><h4 id="编辑相册图片展示页面galleries-ejs"><a href="#编辑相册图片展示页面galleries-ejs" class="headerlink" title="编辑相册图片展示页面galleries.ejs"></a>编辑相册图片展示页面galleries.ejs</h4><p>编辑<code>galleries.ejs</code>内容：<br>以下是我的源代码，若同样主题，即可直接复制，其他主题可做参考，根据需要修改即可使用。</p><pre><code>&lt;!-- 加密功能 --&gt;&lt;% if (theme.PhotoVerifyPassword.enable) &#123; %&gt;    &lt;script src=&quot;&lt;%- theme.libs.js.crypto %&gt;&quot;&gt;&lt;/script&gt;    &lt;script&gt;        (function() &#123;            let pwd = &#39;&lt;%- page.password %&gt;&#39;;            if (pwd &amp;&amp; pwd.length &gt; 0) &#123;                if (pwd !== CryptoJS.SHA256(prompt(&#39;&lt;%- theme.PhotoVerifyPassword.promptMessage %&gt;&#39;)).toString(CryptoJS.enc.Hex)) &#123;                    alert(&#39;&lt;%- theme.PhotoVerifyPassword.errorMessage %&gt;&#39;);                    location.href = &#39;&lt;%- url_for(&quot;/&quot;)  %&gt;&#39;;                &#125;            &#125;        &#125;)();    &lt;/script&gt;&lt;% &#125; %&gt;&lt;!-- &lt;%- partial(&#39;_partial/bg-cover&#39;) %&gt; --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- theme.libs.css.baguetteBoxCss %&gt;&quot;&gt;&lt;!-- 该主题自带的lightGallery.js在图片多的时候会很卡，所以弃用，使用了一个我在网上找的baguetteBox，很轻量级，就是功能少了点 --&gt;&lt;script src=&quot;&lt;%- theme.libs.js.baguetteBoxJs %&gt;&quot;&gt;&lt;/script&gt; &lt;style&gt;        .my-gallery .photo img &#123;        transition: all 0.6s ease-in-out;     &#125;         .my-gallery .photo:hover img &#123;        opacity: 0.6;        transform: scale(1.05);    &#125;          .my-gallery &#123;        margin: 20px auto;    &#125;       .miaoshus .title &#123;        font-family: MV Boli;    &#125;    .miaoshus &#123;        padding: 20px;        border: 1px dashed #e6e6e6;        color: #969696;        position: relative;        display: inline-block;        width: 75%;        background: #fbfbfb50;        border-radius: 10px;        font-size: 16px;        margin: 24px auto 12px;    &#125;    body.dark .miaoshus &#123;        background: 0 0;        border: 1px dashed #888;    &#125;    body &#123;        overflow: visible!important;    &#125;    .box &#123;            position: relative;        &#125;    .box img &#123;        width: 350px;        vertical-align: top;        padding: 8px;        border-radius: 10px;        transition: all 0.5s;    &#125;    .box img:hover &#123;        transform: scale(1.05);    &#125;    .page-footer &#123;        display: none    &#125;    body &#123;        overflow-y: visible!important;    &#125;    header &#123;        background-color: #000;    &#125;    .biaotiss &#123;            font-family: MV Boli;        &#125;       @media only screen and (max-width: 1058px) &#123;        .box &#123;            margin-left: 145px;        &#125;    &#125;    @media only screen and (max-width: 770px) &#123;        .box &#123;            margin-left: 15px;        &#125;    &#125;    @media only screen and (max-width: 500px) &#123;        #previous-button, #next-button &#123;            display: none;        &#125;    &#125;    @media only screen and (max-width: 380px) &#123;        .box &#123;            margin-left: -5px;        &#125;    &#125;    @media only screen and (max-width: 323px) &#123;        .box img &#123;            width: 296px;            left: 0;        &#125;    &#125;&lt;/style&gt;&lt;div class=&quot;tag-title center-align&quot;&gt;    &lt;div class=&quot;miaoshus&quot;&gt;        &lt;div class=&quot;title center-align&quot;&gt;            “ &lt;% if (is_home() &amp;&amp; config.subtitle &amp;&amp; config.subtitle.length &gt; 0) &#123; %&gt;                &lt;%= config.subtitle %&gt;            &lt;% &#125; else &#123; %&gt;                &lt;%= page.title %&gt;            &lt;% &#125; %&gt; ”        &lt;/div&gt;        “ &lt;%- theme.gallery.title %&gt; ”        “ 这里有光影流年，还有两朵穿衣裳的云，相拥在明天的河岸。”    &lt;/div&gt;&lt;/div&gt;&lt;!-- 相册 --&gt;&lt;section class=&quot;gallery&quot;&gt;    &lt;div id=&quot;myGallery&quot; class=&quot;my-gallery&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;box&quot;&gt;            &lt;% if (site.data &amp;&amp; site.data.gallery) &#123; %&gt;                &lt;% var galleries = site.data.gallery;                     var pageTitle = page.title;                    function getCurrentGallery(galleries, pageTitle) &#123;                        for (let i = 0; i &lt; galleries.length; i++) &#123;                            if (galleries[i][&#39;name&#39;] == pageTitle) &#123;                                return galleries[i];                            &#125;                        &#125;                    &#125;                    var currentGallery = getCurrentGallery(galleries, pageTitle);                    var photos = currentGallery.album;                %&gt;                &lt;% for (var i = 0, len = photos.length; i &lt; len; i++) &#123; %&gt;                    &lt;% var my_album = photos[i]; %&gt;                                           &lt;a href=&quot;&lt;%- my_album.img_url %&gt;&quot; data-caption=&quot;&lt;%- my_album.title %&gt;&quot;&gt;                            &lt;img class=&quot;mat&quot; src=&quot;/medias/loading.svg&quot; data-src=&quot;&lt;%- my_album.img_url %&gt;&quot; alt=&quot;img&quot;+&lt;%- i %&gt; &gt;                        &lt;/a&gt;                                   &lt;% &#125; %&gt;            &lt;% &#125; %&gt;        &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/section&gt;&lt;script&gt;    $(function () &#123;        // 获取图片的宽度(200px)        let imgWidth = $(&#39;.mat&#39;).outerWidth(); // 200        waterfallHandler();        // 瀑布流处理        function waterfallHandler() &#123;            // 获取图片的列数            let column = parseInt($(window).width() / imgWidth);            // 高度数组            let heightArr = [];            for(let i=0; i&lt;column; i++) &#123;                heightArr[i] = 0;            &#125;            // 遍历所有图片进行定位处理            $.each($(&#39;.mat&#39;), function (index, item) &#123;                // 当前元素的高度                let itemHeight = $(item).outerHeight();                // 高度数组最小的高度                let minHeight = Math.min(...heightArr);                // 高度数组最小的高度的索引                let minIndex = heightArr.indexOf(minHeight);                $(item).css(&#123;                    position: &#39;absolute&#39;,                    top: minHeight + &#39;px&#39;,                    left: minIndex * imgWidth + &#39;px&#39;                &#125;);                heightArr[minIndex] += itemHeight;            &#125;);        &#125;        // 窗口大小改变        $(window).resize(function () &#123;            waterfallHandler();        &#125;);    &#125;);&lt;/script&gt;&lt;script&gt;    baguetteBox.run(&#39;.gallery&#39;, &#123;        // 配置参数        buttons:Boolean,//是否显示导航按钮。        noScrollbars:true,//是否在显示时隐藏滚动条。        titleTag:true,//是否使用图片上的title属性作为图片标题        async:false,//是否异步加载文件。    &#125;);    start()        $(window).on(&#39;scroll&#39;, function()&#123;        start();    &#125;)    function start()&#123;          //.not(&#39;[data-isLoaded]&#39;)选中已加载的图片不需要重新加载        $(&#39;.gallery img&#39;).not(&#39;[data-isLoaded]&#39;).each(function()&#123;            var $node = $(this)            if( isShow($node) )&#123;                loadImg($node);            &#125;        &#125;);    &#125;    //判断一个元素是不是出现在窗口(视野)    function isShow($node)&#123;        return $node.offset().top &lt;= $(window).height() + $(window).scrollTop();    &#125;    //加载图片    function loadImg($img)&#123;    //.attr(值)    //.attr(属性名称,值)        $img.attr(&#39;src&#39;, $img.attr(&#39;data-src&#39;)); //把data-src的值 赋值给src        $img.attr(&#39;data-isLoaded&#39;, 1);//已加载的图片做标记    &#125;&lt;/script&gt;</code></pre><ul><li>为了实现懒加载，在这里需要在站点主题文件夹下的<code>medias</code>文件夹下面放入一个用于懒加载的图片<code>loading.svg</code> ，这里你可以直接使用我的加载svg，地址<a href="https://nekodeng.gitee.io/medias/loading.svg">https://nekodeng.gitee.io/medias/loading.svg</a></li></ul><h3 id="编辑主题-config-yml文件内容"><a href="#编辑主题-config-yml文件内容" class="headerlink" title="编辑主题_config.yml文件内容"></a>编辑主题_config.yml文件内容</h3><p>在站点主题_config.yml文件下新增以下内容</p><pre><code># 增加了图片页面gallery:   title: 光影流年   #标题  icon: fa         #这个显示相册页面的图标  icon2: fa        #这个显示自己的具体相册里面的相册的图标PhotoVerifyPassword:  enable: true  promptMessage: 该相册已加密，请输入密码访问  errorMessage: 密码错误，将返回主页！</code></pre><ul><li>最后，完成，引用我的相册页面dec来结束：</li><li>“ 光影流年 ”</li><li>“ 这里有光影流年，还有两朵穿衣裳的云，相拥在明天的河岸。”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 关于hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增加瀑布流相册页面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-router</title>
      <link href="/posts/vue-router.html"/>
      <url>/posts/vue-router.html</url>
      
        <content type="html"><![CDATA[<div class="note info">前言：vue-router是什么？为什么我们不像原来一样直接用 a 标签编写链接？如何使用？常见路由操作有哪些？</div><h3 id="Vue-Router是什么"><a href="#Vue-Router是什么" class="headerlink" title="Vue Router是什么"></a>Vue Router是什么</h3><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ul><div class="note info">注意：<code>route</code>指的是当前页面的所有路由信息，<code>router</code>是路由的方法。</div><h4 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h4><pre><code>&lt;router-link to=&quot;xxx&quot; tag=&quot; &quot;&gt;//  将原本用a标签跳转的功能用router-link实现//  to是指要跳转到的目录，tag是这个点击跳转标签的样式，可以是li的样式等等</code></pre><p><img src="https://i.loli.net/2020/10/03/2kswRxcOipy5HIf.png" alt></p><p><code>router-link-exact-active</code>:  路由完全匹配，当前选中<br><code>router-link-active</code>:  路由不完全匹配<br><code>to</code>:  表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。</p><pre><code>&lt;!-- 字符串 --&gt;&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=&quot;home&quot;&gt;Home&lt;/a&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to=&quot;&#39;home&#39;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to=&quot;&#39;home&#39;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 同上 --&gt;&lt;router-link :to=&quot;&#123; path: &#39;home&#39; &#125;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to=&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to=&quot;&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;&quot;&gt;Register&lt;/router-link&gt;</code></pre><h4 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h4><p>除了使用<code> router-link </code>标签创建<code> a </code>标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。<br><code>this.$router.push()</code>:括号里面参数和to的方法一致</p><p><img src="https://i.loli.net/2020/10/03/uYUB2aCA1WlQ7q5.png" alt></p><pre><code>// 字符串router.push(&#39;home&#39;)// 对象router.push(&#123; path: &#39;home&#39; &#125;)// 命名的路由router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</code></pre><ul><li>注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</li></ul><pre><code>const userId = &#39;123&#39;router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: &#39;/user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user</code></pre><h4 id="动态路由和嵌套路由"><a href="#动态路由和嵌套路由" class="headerlink" title="动态路由和嵌套路由"></a>动态路由和嵌套路由</h4><p>动态路由：一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到<code>this.$route.params</code></p><p>注意：子路由path不写斜线</p><pre><code>import Home from &#39;../views/Home&#39;import Products from &#39;../views/Products&#39;import Category from &#39;../views/Category&#39;export default [  &#123;    path: &#39;/home&#39;,    name: &#39;home&#39;,    component: Home  &#125;, &#123;    path: &#39;/Products&#39;,    name: &#39;products&#39;,    component: Products,    children: [&#123;      path: &#39;:cateName&#39;,//子路由path不写斜线      name: &#39;category&#39;,      component: Category    &#125;]  &#125;]</code></pre><h4 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h4><p>子路由(children)的<code>router-view</code>要在父组件里面去配置</p><h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有<code> sidebar </code>(侧导航) 和<code> main </code>(主内容) 两个视图。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code></p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;头部&lt;/h2&gt;    &lt;div class=&quot;main&quot;&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;  &lt;router-view name=&quot;x-footer&quot;&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;export default [  &#123;    path: &#39;/home&#39;,    name: &#39;home&#39;,    components: &#123;//这里一定要写components，default指的是没有没有命名的那个组件(在这里是app.vue)      default: Home,      &#39;x-footer&#39;: Footer    &#125;  &#125;</code></pre><h4 id="捕获所有路由或-404-Not-found-路由"><a href="#捕获所有路由或-404-Not-found-路由" class="headerlink" title="捕获所有路由或 404 Not found 路由"></a>捕获所有路由或 404 Not found 路由</h4><p>常规参数只会匹配被 / 分隔的 URL 片段中的字符。如果想匹配任意路径，我们可以使用通配符 (*)：</p><pre><code>&#123;  // 会匹配所有路径  path: &#39;*&#39;&#125;&#123;  // 会匹配以 `/user-` 开头的任意路径  path: &#39;/user-*&#39;&#125;</code></pre><h3 id="重定向-redirect和别名alias"><a href="#重定向-redirect和别名alias" class="headerlink" title="重定向 redirect和别名alias"></a>重定向 redirect和别名alias</h3><p>注意：含有通配符的路由应该放在最后</p><pre><code>export default [  &#123;//从&quot;/&quot;重定向到&quot;/home&quot;,这样根路径就变成了home    path: &#39;/&#39;,    redirect: &#39;/home&#39;  &#125;]</code></pre><h3 id="导航守卫（常用来做权限验证）"><a href="#导航守卫（常用来做权限验证）" class="headerlink" title="导航守卫（常用来做权限验证）"></a>导航守卫（常用来做权限验证）</h3><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航</p><h4 id="全局前置守卫-beforeEach"><a href="#全局前置守卫-beforeEach" class="headerlink" title="全局前置守卫-beforeEach"></a>全局前置守卫-beforeEach</h4><p>全局导航守卫可以在main.js里做，因为需要在router的实例上做,用来做全局的权限验证</p><pre><code>  const router = new VueRouter(&#123; ... &#125;)  router.beforeEach((to, from, next) =&gt; &#123;    next()  &#125;)</code></pre><p><code>to</code>:  要到哪个组件去，<br><code>from</code>:  从哪个组件来的<br><code>next</code>:  必须要调用next( )这个方法否则路由无法跳转访问</p><ul><li>在路由里除了本身参数，要加入扩展参数时使用meta</li></ul><h4 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h4><pre><code>const Foo = &#123;  template: `...`,  beforeRouteEnter (to, from, next) &#123;    // 在渲染该组件的对应路由被 confirm 前调用    // 不！能！获取组件实例 `this`    // 因为当守卫执行前，组件实例还没被创建,在created之前就会执行这个守卫  &#125;,  beforeRouteUpdate (to, from, next) &#123;    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    // 可以访问组件实例 `this`  &#125;,  beforeRouteLeave (to, from, next) &#123;    // 导航离开该组件的对应路由时调用    // 可以访问组件实例 `this`  &#125;&#125;</code></pre><p><code>beforeRouteUpdate</code>: 路由更新之前，这里可以发送ajax请求。在使用beforeRouteUpdate时一般会先使用beforeRouteEnter。<br>在<code>beforeRouteEnter</code>中不能获取this，可以在next里传一个回调函数，该回调函数的第一个形参VM就是this，且beforeRouteEnter只会在第一次进来时执行一次。</p><p><img src="https://i.loli.net/2020/10/03/AVwDxS8EMRiG6HX.png" alt></p><p>在之前没有<code>beforeRouteUpdate</code>，使用<code>watch</code>来替代 ，watch可以watch this.上的所有东西</p><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，利用import返回promise来异步加载</p><pre><code>const Foo = () =&gt; import(&#39;./Foo.vue&#39;)</code></pre><p>把组件按组分块，下面的注释意思是：将这三个组件的代码打包到一个js文件里。</p><pre><code>const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)</code></pre><p><code>native</code> 在加不上事件的时候使用，往当前组件的的根dom元素上绑定一个事件</p>]]></content>
      
      
      <categories>
          
          <category> Vue基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础</title>
      <link href="/posts/vue.html"/>
      <url>/posts/vue.html</url>
      
        <content type="html"><![CDATA[<div class="note info">前言:  Vue.js 是什么？为什么这么火？这么多人使用？优缺点有哪些？</div><h3 id="Vue-js-是什么"><a href="#Vue-js-是什么" class="headerlink" title="Vue.js 是什么"></a>Vue.js 是什么</h3><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p><ul><li>然后可以通过如下方式引入 Vue：<pre><code>&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></pre>或者：<pre><code>&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;</code></pre></li></ul><h3 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h3><h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><p>vue的指令都是v-这种格式，虽然<code>v-xxx=”xxx”</code>写的值是用””包裹，但实际上是js，因此需要在双引号里再加层引号，否则会报错。</p><p><code>v-text</code> : 用于替换插值表达式，如果有v-text，插值就不生效。</p><p><code>v-html</code>: 输出转译过的不带HTML标签的HTML语句。富文本编辑器的内容直接渲染的话是被转译过的，那么HTML标签就会被渲染到页面上</p><p><code>v-cloak</code>: 配合样式来使用，可以让样式在vue实例化之前生效</p><p><code>v-for</code>: 用于循环渲染数据。v-for=”item in list”。可以直接遍历对象、数组、数字。</p><p><code>v-if</code>: 直接是dom节点的移除和插入，来达到显示和隐藏元素的效果。通过判断true和false来实现</p><p><code>v-else</code>:必须与v-if配合使用，而v-if不需要配合v-else</p><p><code>v-show</code>: 是通过改变css样式style来显示或者隐藏元素，通过display。对于需要频繁切换显示和隐藏的节点特别实用，比如弹窗、手机注册和邮箱注册两个tab的切换。</p><p><code>v-bind</code>:属性:用于动态绑定元素的属性 ，可以简写为:属性。<br><img src="https://i.loli.net/2020/09/30/9VniwYTtfkPOXqs.png" alt="v-bind"></p><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p><code>v-on</code>:事件名: 绑定事件，可以直接操作data里的数据，v-on可以缩写为@事件名。<br>vue的事件可以加括号也可以不加，不加默认接收事件处理函数的事件对象；加了括号就可以任意传参。（可以继续在括号里通过$event获取当前事件对象）<br><img src="https://i.loli.net/2020/09/30/JP5Vzti2HA8KjhW.png" alt="v-on"></p><p><code>v-on:click</code>: 用于绑定点击事件</p><p><code>v-model</code>:自动绑定input输入内容改变事件<br><img src="https://i.loli.net/2020/09/30/7KiSLcDtRsQM2eF.png" alt="v-model"></p><p><code> @keyup.enter</code>: .enter是按键修饰符，也可以用enter的对应码13代替。可以使用组合键如<code>.ctrl.enter</code><br><img src="https://i.loli.net/2020/09/30/gj5tFKepvoORPJQ.png" alt="v-@keyup"></p><p><code>.stop</code>:事件修饰符，阻止冒泡。</p><h3 id="class绑定"><a href="#class绑定" class="headerlink" title="class绑定"></a>class绑定</h3><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><ul><li>methods和computed区别<ul><li>methods用来绑定一些方法，每次有数据更改只要在模板里使用这个方法就会执行，没有缓存。</li><li>computed是计算属性，有依赖缓存，只有它所依赖的数据发生改变才会重新计算，计算出来的值可以当成data直接使用，不需要添加括号，必须要有一个return值。计算属性是基于它们的响应式依赖进行缓存的。</li></ul></li></ul><h4 id="侦听器watch"><a href="#侦听器watch" class="headerlink" title="侦听器watch"></a>侦听器watch</h4><p>一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。</p><ul><li>computed是生成一个新的数据，watch是观测已有的数据，当被观测的数据发生改变时，自动执行后面的方法。</li></ul><h4 id="filters过滤器"><a href="#filters过滤器" class="headerlink" title="filters过滤器"></a>filters过滤器</h4><p><img src="https://i.loli.net/2020/09/30/589IqhoiZTSjnmR.png" alt="filters过滤器"></p><h4 id="ajax-fetch"><a href="#ajax-fetch" class="headerlink" title="ajax-fetch"></a>ajax-fetch</h4><p><img src="https://i.loli.net/2020/09/30/ylSGA8Mcuk4iUQn.png" alt="ajax-fetch"></p><h3 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h3><ul><li>组件是可复用的 Vue 实例(可以将组件进行任意次数的复用)，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</li></ul><p><code>Vue.compoent(“tagName”, options ):</code><br>tagName 为组件名，options 为配置选项。注册后，我们可以使用以下方式来调用组件：</p><pre><code>&lt;tagName&gt;&lt;/tagName&gt;</code></pre><ol><li>全局注册一个组件，第一个参数就是要使用的标签的名字，不论使用大驼峰或者小写字母加中线的命名方式，在使用组件的时候都要使用小写字母加中线使用。<br></li><li>第二个参数就是组件的配置项，全局注册的组件可以在任何地方使用</li></ol><p><code>components</code>:  局部注册一个组件，只有当前Vue实例中才可以使用这个组件</p><ul><li>组件的data必须是一个方法(函数)，然后要return一个对象，为了保证组件的数据是独立的而不是共享</li></ul><p><b>一个组件可以嵌套，但是一个组件的template只能有一个根元素</b></p><h4 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h4><p>Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。</p><ul><li><p>通过prop来接收调用的时候传过来的值，然后可以把prop当data使用，但是不能修改父组件传的值，这是基于单项数据流。</p></li><li><p>单项数据流<br>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p></li><li><p>props的大小写<br>HTML 的属性忽略大小写，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，驼峰命名的 prop 名需要使用短横线分隔命名</p></li></ul><p><i>传递非字符串类型的数据需要使用动态绑定</i><code>v-bind</code></p><p><i>如果要对传入的props进行类型检查，就需要使用对象的方式来写props；如果要对传入的值进行更多约束，就需要把这个值写成对象，对其设置default或者required(二选一)</i></p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p><code>ref</code>: 用来获取dom或者组件</p><pre><code>&lt;tag ref=&quot;a&quot;&gt;&lt;/tag&gt; //可以通过this.$refs.a获取到tag标签</code></pre><p><code>slot</code>:  插槽 占位组件，能够实现标签的嵌套，可以写成:</p><pre><code>&lt;slot name=&quot;xxx&quot;&gt;&lt;/slot&gt;//给slot加一个name属性，写在模板里面，在页面的显示顺序只有模板里面的顺序有关&lt;h2 slot=&quot;xxx&quot;&gt;内容&lt;/h2&gt;//通过slot属性来获取获取到slot</code></pre><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><pre><code>&lt;component is=&quot; &quot;&gt;&lt;/component&gt;//is后面写组件名，用来指定是哪一个组件</code></pre><p>还可以通过is 来解决标签嵌套不合法的情况<br><img src="https://i.loli.net/2020/09/30/U43BnbPp2zVDC8v.png" alt></p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>用transition将需要过渡的元素包起来，要为多个元素设置的话使用transition-group。<br>transition的主要作用是给它的子元素添加和移除class</p><p><code>v-enter</code>: v指元素的name属性，如xxx-enter,不设置的话默认为transition内所有的元素</p><h4 id="过渡的类型"><a href="#过渡的类型" class="headerlink" title="过渡的类型"></a>过渡的类型</h4><p><code>v-enter</code>：定义进入过渡的开始状态<br><code>v-enter-active</code>：定义进入过渡生效时的状态。<br><code>v-enter-to</code>: 定义进入过渡的结束状态。<br><code>v-leave</code>: 定义离开过渡的开始状态。<br><code>v-leave-active</code>：定义离开过渡生效时的状态。<br><code>v-leave-to</code>:  定义离开过渡的结束状态。<br><img src="https://i.loli.net/2020/09/30/xYuBcvFWr9hUw2L.png" alt></p><p><i>transition负责给它的子元素添加和移除class</i></p><h4 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h4><p><code>in-out</code>：新元素先进行过渡，完成之后当前元素过渡离开。<br><code>out-in</code>：当前元素先进行过渡，完成之后新元素过渡进入。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li>创建阶段<br>（1）beforeCreate — 没什么用，里面取不到数据<br>（2）created — 没有this.$el,也没有真实的dom，但是已经有数据，可以在这里更改数据，如果数据是同步更改就会带入下一个生命周期；如果是异步修改，当数据修改完之后就会进入更新阶段，在这里做Ajax请求比较推荐</li><li>挂载阶段<br>(1)beforeMount—这里已经能看到this.$el，但还没有进行真实的数据替换，看到的还是插值表达式，这里也不会做太多的事<br>(2)mounted—在这里this.$el是真实渲染的dom，在这里及之后才能取到真实的dom。一些第三方dom插件也会在这里来进行初始化，（仅限没有异步数据的dom，这里也可以做Ajax请求）</li><li>更新阶段<br>(1)beforeUpdate—不做太多事<br>(2)updated—可能需要在这里重新初始化第三方的dom操作插件</li><li>销毁阶段<br>(1)beforeDestroy—在这里一般会去解除一些事件的监听，或者清除一些定时器。<br>(2)destroyed</li></ol><p><img src="https://i.loli.net/2020/09/30/fciMv7P2tzHF5nD.png" alt="lifecycle"></p><p><img src="https://i.loli.net/2020/09/30/IxVEN7t9XfQpu1j.png" alt></p><ul><li><p>nextTick<br>在created里数据有异步更新时，这时dom还没有进行渲染，在这时候进行dom操作没有用，而在$nextTick的回调中去操作dom的时候，代表此时的页面已经根据最新的数据渲染完成。通过异步返回的数据去操作dom，就放在next tick里执行</p><p>  created() {</p><pre><code>// 模拟一下ajaxsetTimeout(() =&gt; &#123;  this.banners = [&#39;banner 1&#39;, &#39;banner 2&#39;, &#39;banner 3&#39;]  // 在这里的dom还是没有应用新数据的dom  // this.$nextTick(() =&gt; &#123;  //   // 在这里的dom就是已经使用了更新的数据的dom  //   this.initSwiper()  // &#125;)  this.$nextTick()    .then(() =&gt; &#123;      this.initSwiper()    &#125;)&#125;, 2000)</code></pre><p>  }</p></li></ul><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p><code>console.time() … console.timeEnd()</code>查看代码运行耗费的时间</p><h3 id="vue-ajax-axios"><a href="#vue-ajax-axios" class="headerlink" title="vue-ajax axios"></a>vue-ajax axios</h3><p>1、安装<code>axios — npm i axios -s</code><br>2、在index.js里引入<i> axios import axios from ‘axios’</i><br>3、配置<i> baseUrl const ajax = axios.create({ baseURL: ‘<a href="http://jsonplaceholder.typicode.com/">http://jsonplaceholder.typicode.com/</a>‘ })</i><br>4、在index.js里定义接口导出你要的数据，以todos为例</p><pre><code>import axios from &#39;axios&#39;const ajax  = axios.create(&#123;    baseURL: &#39;http://jsonplaceholder.typicode.com/&#39;&#125;)//取todosexport const getTodos = () =&gt; &#123;    return ajax.get(&#39;/todos&#39;)&#125;//单个todoexport const getTodoById = (id) =&gt; &#123;    return ajax.get(`/todos/$(id)`)&#125;</code></pre><p>5、在main.js里引入所有的，而不用挨个引入  <i> import * as $http from ‘./requests’ //引入所有的</i><br>6、挂载到Vue上</p><pre><code>import * as $http from &#39;./requests&#39; //引入所有的Vue.prototype.$http = $http</code></pre><p>7、在app.vue里请求数据(在created里)</p><pre><code>created () &#123;  this.$http.getTodos()  .then(resp =&gt; &#123;    if(resp.status === 200)&#123;      this.todos = resp.data    &#125;  &#125;)&#125;</code></pre><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>作用：更改请求的参数，在里面自动注入一个参数；</p><pre><code>//拦截请求//拦截器 使用一个方法去拦截Ajax的request请求,有些请求要求你必须携带token...ajax.interceptors.request.use((config) =&gt; &#123;    //第一个人用途：用于显示全局的loading状态    document.querySelector(&#39;.modal&#39;).style.display = &#39;block&#39;    //第二个用途：在请求参数里加上全局的参数，比如token，这个token在实际项目中会从本地存储中取    config.headers.token=&#39;123&#39;    //必须return config，否则请求不会执行    return config&#125;)//拦截响应ajax.interceptors.response.use(resp =&gt; &#123;    //隐藏全局loading    document.querySelector(&#39;.modal&#39;).style.display = &#39;none&#39;    //全局处理错误    if(resp === 200)&#123;        return resp.data      &#125;    //这里统一做错误处理，需要后端配合，接口的返回格式必须一致&#125;)</code></pre><p><img src="https://i.loli.net/2020/09/30/2oc5FqtBmgZD3WE.png" alt></p><p>判断isDev，判断是否处于开发模式，就使用前面的地址；上线模式就使用后面的地址</p><p><img src="https://i.loli.net/2020/09/30/P3HfEnukbXsOCZx.png" alt></p><h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h3><pre><code>&lt;style scoped&gt;</code></pre><p>scoped指定样式只在当前页面生效</p><p>代理服务器配置<br><code>devServer</code>: 如果你的前端应用和后端 API 服务器没有运行在同一个主机上，你需要在开发环境下将 API 请求代理到 API 服务器。这个问题可以通过 vue.config.js 中的 devServer.proxy 选项来配置。</p><pre><code>module.exports = &#123;  devServer: &#123;    port: 3000,    open: true,    proxy: &#123;      //所有以ajax开始的都配置到下面这个地址      &#39;/ajax&#39;: &#123;        target: &#39;http://m.maoyan.com&#39;,        changeOrigin: true      &#125;    &#125;  &#125;&#125;</code></pre><h3 id="kepp-alive"><a href="#kepp-alive" class="headerlink" title="kepp-alive"></a>kepp-alive</h3><ul><li><p>用法:</p><pre><code>&lt;keep-alive&gt;</code></pre><p>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。主要用于保留组件状态或避免重新渲染。</p></li><li><p>Propes：</p></li></ul><p><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。<br><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。<br><code>max</code> - 数字。最多可以缓存多少组件实例。<br>会新增 <code>activated</code>和<code>deactivated</code>这两个生命周期</p>]]></content>
      
      
      <categories>
          
          <category> Vue基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git踩坑-git报错bad signature和index file corrupt和error：spawn failed的处理方法</title>
      <link href="/posts/git-error-index-file-corrupt.html"/>
      <url>/posts/git-error-index-file-corrupt.html</url>
      
        <content type="html"><![CDATA[<div class="note info">前言: 今天在部署写好的博客文章时，出现了git报错bad signature和index file corrupt和error：spawn failed，网上找了一堆解决办法，都没行，最后利用了巧妙地方法解决了。</div><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>git报错bad signature和index file corrupt和error：spawn failed(如图所示)<br><img src="https://i.loli.net/2020/10/01/I2mdltAi9r63B5o.png" alt="git报错"></p><h3 id="一般解决办法"><a href="#一般解决办法" class="headerlink" title="一般解决办法"></a>一般解决办法</h3><ul><li>分析：可能是.git/index 这个文件损坏造成的。</li><li>方法：删除这个损坏的文件，重新生成一个。</li></ul><ol><li>进入到文件对应目录下</li><li>删除.git/index 文件： <code>rm -f .git/index</code></li><li>重建 .git/index 文件: <code>git read-tree</code> 或者直接 <code>git reset</code></li></ol><p>然后再重新执行部署命令即可。</p><h3 id="特殊解决办法"><a href="#特殊解决办法" class="headerlink" title="特殊解决办法"></a>特殊解决办法</h3><ul><li><p>问题分析：<br>本来以上 “一般解决办法” 就能有效解决问题，但是，我发现以上命令行执行后根本没效果，执行<code>rm -f .git/index</code>命令删除文件也会报错。<br>于是，我进入到我的博客目录<code>.deploy_git</code>文件下，发现里面根本不存在<code>.git/index</code>文件，啊！简直想😭，最后自己琢磨了老半天，终于解决了。</p></li><li><p>解决办法：</p></li></ul><ol><li>进入到<code>.deploy_git</code>文件下</li><li>在该文件下打开<code>git bash</code></li><li>直接执行<code>git reset</code>命令行</li><li>成功解决问题</li></ol><h3 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h3><p>这已经不是第一次git踩坑了，关于使用时偶尔就会遇到这些棘手的问题，以后会多总结这类踩坑日记，当然不可能不存在bug的，这才是我们存在的意义啊！🤭</p><div class="note info">本文参考了以下源文章：</div><p><a href="https://blog.csdn.net/HTL2018/article/details/106876940" class="LinkCard" target="_blank">hexo发生error：spawn failed错误的解决方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git报错index file corrupt和error：spawn failed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-移动端布局、事件</title>
      <link href="/posts/mobile-side-layout.html"/>
      <url>/posts/mobile-side-layout.html</url>
      
        <content type="html"><![CDATA[<div class="note info">前言:最近在用css时遇到了一些棘手的问题，所以总结一下。</div><h3 id="关于Unicode字体图标"><a href="#关于Unicode字体图标" class="headerlink" title="关于Unicode字体图标"></a>关于Unicode字体图标</h3><p>首先需要明确的是，Unicode字体图标是HTML，在vue里使用时渲染必须用v-html。</p><h3 id="关于图片自适应"><a href="#关于图片自适应" class="headerlink" title="关于图片自适应"></a>关于图片自适应</h3><p><img src="https://i.loli.net/2020/09/25/OiNoX4WUeCzlM82.png" alt></p><h3 id="关于移动端一个像素问题"><a href="#关于移动端一个像素问题" class="headerlink" title="关于移动端一个像素问题"></a>关于移动端一个像素问题</h3><p><img src="https://i.loli.net/2020/09/25/rSoymfUWEAwPltB.jpg" alt></p><h3 id="关于吸顶效果"><a href="#关于吸顶效果" class="headerlink" title="关于吸顶效果"></a>关于吸顶效果</h3><pre><code>position:sticky;top:0;</code></pre><h3 id="关于移动端事件"><a href="#关于移动端事件" class="headerlink" title="关于移动端事件"></a>关于移动端事件</h3><ul><li>移动端的onclick点击事件有300ms的延迟</li><li><p>移动端有ontouchstart事件，会比onclick先执行，如果在ontouchstart事件后触发了ontouchmove事件，那么onclick将不会执行（要注意这个细节）</p><ul><li>padding-top是按照父级宽度来计算的</li><li>rem根据根元素计算，与px转换比例基于根元素</li><li>em 根据父元素计算，与px转换比例基于父元素</li></ul></li></ul><h3 id="关于使用swiper轮播图布局写法"><a href="#关于使用swiper轮播图布局写法" class="headerlink" title="关于使用swiper轮播图布局写法"></a>关于使用swiper轮播图布局写法</h3><pre><code>.swiper-container &#123;    width: 100%;    height: 0;    padding-top: percentage( 400 / 1080 );    .swiper-wrapper &#123;      position: absolute;      left: 0;      top: 0    &#125;    img &#123;      max-width: 100%;    &#125;&#125;</code></pre><h3 id="关于flex布局的图例"><a href="#关于flex布局的图例" class="headerlink" title="关于flex布局的图例"></a>关于flex布局的图例</h3><p><img src="https://i.loli.net/2020/09/25/qFfyVJhOGeliukU.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> css知识点合集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于给hexo文章分类页面按钮仿书本样式美化</title>
      <link href="/posts/blog-categories-bookstyle.html"/>
      <url>/posts/blog-categories-bookstyle.html</url>
      
        <content type="html"><![CDATA[<div class="note info">前言：最近成迷于美化hexo博客样式，发现了这个超好看的样式，美化了一下，基于matery主题设置的，其他主题原理也一样可参考。</div><p>废话不多说，先上图：<br><img src="https://i.loli.net/2020/09/24/wrsvGo6CK5ZNRWx.png" alt="hover前"><br><img src="https://i.loli.net/2020/09/24/K728iQRAjrp1kDs.png" alt="hover后"><br>源网页：<br><a href="https://nekodeng.gitee.io/categories/" class="LinkCard" target="_blank">hexo文章分类页面按钮仿书本样式美化</a></p><ul><li>特点: 都是div+css美化效果，所以没啥难度，可以直接复制我以下的代码，或者做修改都可。</li></ul><h3 id="引入html代码"><a href="#引入html代码" class="headerlink" title="引入html代码"></a>引入html代码</h3><ul><li>1、首先，找到位置为<code>/layout/category-cloud.ejs</code>的文件，后面的html和css代码都放在此<code>category-cloud.ejs</code>文件即可。</li><li>2、然后，定位到href=”&lt;%- url_for(category.path) %&gt;”的a标签位置：<pre><code>&lt;!-- 定位到该位置 --&gt;&lt;a href=&quot;&lt;%- url_for(category.path) %&gt;&quot; title=&quot;&lt;%- category.name %&gt;: &lt;%- category.length %&gt;&quot;&gt;</code></pre></li><li><p>3、直接将该a标签里面的内容全部替换为以下代码：</p><pre><code>  &lt;div class=&quot;moleskine-wrapper&quot;&gt;      &lt;div class=&quot;moleskine-notebook&quot;&gt;          &lt;div class=&quot;chip notebook-cover center-align waves-effect waves-light          &lt;% if (isCategory &amp;&amp; category.name == page.category) &#123; %&gt; chip-active &lt;% &#125; else &#123; %&gt; chip-default &lt;% &#125; %&gt;&quot;                  style=&quot;background-color: &lt;%- color %&gt;;&quot;&gt;                                                             &lt;div class=&quot;notebook-skin                  &lt;% if (isCategory &amp;&amp; category.name == page.category) &#123; %&gt; chip-active &lt;% &#125; else &#123; %&gt; chip-default &lt;% &#125; %&gt;&quot;                  &gt;&lt;%- category.name %&gt;                                                &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;notebook-page dotted&quot;&gt;&lt;/div&gt;      &lt;/div&gt;  &lt;/div&gt;</code></pre></li></ul><h3 id="设置css样式"><a href="#设置css样式" class="headerlink" title="设置css样式"></a>设置css样式</h3><p>这部分同样放在此<code>category-cloud.ejs</code>文件即可。</p><pre><code>    &lt;style&gt;    /* 文章分类书本样式 */    .chip-container .tag-chips &#123;        display: flex;        flex-wrap: wrap;        justify-content: space-around;    &#125;    .chip-container .tag-chips a &#123;        margin: 0 7px 10px;    &#125;    .chip-container .chip &#123;        max-width: calc(100% / 4);        min-width: 10em;        height: 200px;        position: relative;        transition: .5s linear;        padding: 19px 0;        line-height: 20px;        z-index: 990;        border-radius: 5px 15px 15px 5px;        transform-origin: left center 0;    &#125;    .chip-container .notebook-cover::before &#123;        content: &quot;&quot;;        position: absolute;        width: 10px;        height: calc(100% + 2px);        top: -1px;        z-index: 100;        border-radius: 2px;        right: 25px;        transition: 2s ease;        /* background: linear-gradient(to right,#9c2e2b 0,#cc4b48 12%,#9c2e2b 25%,#cc4b48 37%,#9c2e2b 50%,#cc4b48 62%,#9c2e2b 75%,#cc4b48 87%,#9c2e2b 100%); */        background: linear-gradient(to right,#1e606e 0,#2e95aa 12%,#1e606e 25%,#2e95aa 37%,#1e606e 50%,#2e95aa 62%,#1e606e 75%,#2e95aa 87%,#1e606e 100%);    &#125;    .chip .notebook-skin &#123;        height: 50px;        width: 100%;        background: #e8e8e0;        margin-top: 42px;        padding: 10px 32px 64px 10px;        font-size: 19px;        position: relative;        z-index: 10;        color: #222;        text-align: left;        box-shadow: 0 1px 1px rgba(0,0,0,.2);    &#125;    .chip .notebook-skin:before &#123;        content: &#39;&#39;;        position: absolute;        width: 100%;        height: 15px;        left: 0;        bottom: 0;        background: #cddc39;    &#125;    .notebook-cover &#123;        background: #cc4b48;        height: 200px;        width: 140px;        position: absolute;        border-radius: 5px 15px 15px 5px;        z-index: 10;        transition: .5s linear;        transform-style: preserve-3d;        transform-origin: left center 0;    &#125;    .moleskine-wrapper &#123;        max-width: calc(100% / 4);        min-width: 10em;    &#125;    .moleskine-notebook:hover .notebook-cover &#123;        transform: rotateY(-50deg);        z-index: 99;        box-shadow: 20px 10px 50px rgba(0,0,0,.2);    &#125;    .moleskine-notebook &#123;        height: 200px;        position: relative;        display: flex;        flex-wrap: wrap;        justify-content: space-around;        transition: .5s linear;        border-radius: 5px 15px 15px 5px;        transform-origin: left center 0;    &#125;    .moleskine-notebook:hover &#123;        transform: rotateZ(-10deg);    &#125;    .notebook-page.dotted &#123;        background: linear-gradient(to bottom,#fbfae8 9px,#e4e4e4 1px);        background-size: 100% 10px;    &#125;    .chip-container .chip:hover &#123;        background: none;    &#125;    .notebook-page &#123;        height: 100%;        width: 140px;        position: absolute;        top: 10px;        background-color: #fbfae8;        z-index: 0;        border-radius: 5px 16px 16px 5px;        overflow: hidden;    &#125;    &lt;/style&gt;</code></pre><p>至此，结束。很简单，但超好看。</p><div class="note info">本文参考了以下博客：如果你使用的是和我一样的matery主题，则可以直接复制上面代码，再做酌情修改样式即可，其他主题的也一样，逻辑都是一样的。</div><p><a href="https://bestzuo.cn/" class="LinkCard" target="_blank">Sanarous’s Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 关于hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客文章分类页面样式优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于给hexo博客增加每日一言（诗句，影视名句，网易云热评等）</title>
      <link href="/posts/blog-poem-comment.html"/>
      <url>/posts/blog-poem-comment.html</url>
      
        <content type="html"><![CDATA[<div class="note info">前言：看到很多个人博客都带有每日一言功能，所以决定也弄一个，挺好看的。基于matery主题设置的，其他主题原理也一样可参考。</div><h3 id="每日一言API"><a href="#每日一言API" class="headerlink" title="每日一言API"></a>每日一言API</h3><ul><li>一言网（hitokoto.cn）创立于 2016 年，隶属于萌创团队，目前网站主要提供一句话服务。<br>简单来说，一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。 或是感动，或是开心，有或是单纯的回忆。来到这里，留下你所喜欢的那一句句话，与大家分享，这就是一言存在的目的。—节选自一言网<br>详细介绍请转步：<br><a href="https://hitokoto.cn/" class="LinkCard" target="_blank">一言网（hitokoto.cn）</a></li></ul><h3 id="封装一个获取接口"><a href="#封装一个获取接口" class="headerlink" title="封装一个获取接口"></a>封装一个获取接口</h3><p>官方的获取路径为：<code><a href="https://v1.hitokoto.cn/">https://v1.hitokoto.cn/</a></code>,可以自定义获取的参数类型。<br>例如我这里的<code>c=d&amp;c=h&amp;c=j</code>,就是获取的文学、影视、网易云的文本,若要自定义获取的类型，请参考官网请求参数部分文档。<br>也可以直接引入下面我的也可。注意：这部分js代码放在引入页面的ejs文件下,我存放的位置为<code>/layout/contact.ejs</code>,与后面的html代码放在一起也可。</p><pre><code>    &lt;script&gt;        $.get(&quot;https://v1.hitokoto.cn?c=d&amp;c=h&amp;c=j&quot;,function(datastatus)&#123;            if(status==&#39;success&#39;)&#123;                $(&#39;#poem&#39;).html(data.hitokoto)                if(data.from_who!=null)&#123;                    $(&#39;#info&#39;).html(data.from_who+&quot; · &quot;+《 &quot;+data.from+&quot; 》&quot;);                    &#125;                    else&#123;                        $(&#39;#info&#39;).html(&quot; “ &quot;+data.from+&quot;” &quot;);                    &#125;            &#125;            else&#123;$(&#39;#poem&#39;).html(&quot;获取出错啦&quot;);&#125;&#125;);    &lt;/script&gt;</code></pre><h3 id="引入html"><a href="#引入html" class="headerlink" title="引入html"></a>引入html</h3><p>同上,这部分html代码放在引入页面的ejs文件下,我存放的位置为<code>/layout/contact.ejs</code></p><pre><code>&lt;!-- 加入网易云音乐热门评论，实时更新 --&gt;&lt;div class=&quot;poem-wrap&quot;&gt;    &lt;div class=&quot;poem-border poem-left&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;poem-border poem-right&quot;&gt;    &lt;/div&gt;    &lt;h1&gt;热评&lt;/h1&gt;    &lt;p id=&quot;poem&quot;&gt;loading...&lt;/p&gt;    &lt;p id=&quot;info&quot;&gt;loading...&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="设置css样式"><a href="#设置css样式" class="headerlink" title="设置css样式"></a>设置css样式</h3><p>这部分放在一个全局css文件下即可。</p><pre><code>    /* 增加每日一言模块 */    .poem-wrap &#123;        position: relative;        width: 730px;        max-width: 80%;        border: 2px solid #797979;        border-top: 0;        text-align: center;        margin: 80px auto;    &#125;    .poem-left &#123;        left: 0;    &#125;    .poem-border &#123;        position: absolute;        height: 2px;        width: 27%;        background-color: #797979;    &#125;    .poem-right &#123;        right: 0;    &#125;    .poem-wrap h1 &#123;        position: relative;        margin-top: -20px;        display: inline-block;        letter-spacing: 4px;        color: #797979;    &#125;    .poem-wrap p:nth-of-type(1) &#123;        font-size: 25px;        text-align: center;        margin: 0 auto;    &#125;    .poem-wrap p &#123;        width: 70%;        margin: auto;        line-height: 30px;        color: #797979;        font-family: &quot;Linux Biolinum&quot;, &quot;Noto Serif SC&quot;, Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;    &#125;    .poem-wrap p:nth-of-type(2) &#123;        font-size: 18px;        margin: 15px auto;    &#125;    .bozhushuo &#123;        text-align: center;        font-size: 19px!important;        margin: 0 0 12px!important;        line-height: 1.9rem;        font-family: &quot;Linux Biolinum&quot;, &quot;Noto Serif SC&quot;, Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;    &#125;    .notice &#123;        margin: 30px auto;        padding: 20px;        border: 1px dashed #e6e6e6;        color: #969696;        position: relative;        display: inline-block;        width: 95%;        background: #fbfbfb50;        border-radius: 10px;        font-size: 16px;    &#125;    .notice-content &#123;        display: initial;        vertical-align: middle;    &#125;</code></pre><p>最后，上效果：<br><img src="https://i.loli.net/2020/09/24/baIZ2Wiq7LCPfjR.png" alt="每日一言"></p><div class="note info">本文参考了以下博客：如果你使用的是和我一样的matery主题，则可以直接复制上面代码，再做酌情修改样式即可，其他主题的也一样，逻辑都是一样的。</div><p><a href="https://bestzuo.cn/" class="LinkCard" target="_blank">Sanarous’s Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 关于hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客增加每日一言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于给hexo博客适配全局深色模式</title>
      <link href="/posts/blog-night-mode.html"/>
      <url>/posts/blog-night-mode.html</url>
      
        <content type="html"><![CDATA[<div class="note info">前言：目前，主流系统无论是Windows、MacOS、各大手机厂商系统都支持主题全局深色模式了，所以萌生了这个想法，将博客也是配全局深色模式。</div><h3 id="首先，选择适合自己主题的方案"><a href="#首先，选择适合自己主题的方案" class="headerlink" title="首先，选择适合自己主题的方案"></a>首先，选择适合自己主题的方案</h3><p>目前，比较主流的方案有两种：</p><ul><li>prefers-color-scheme 媒体查询</li><li>给body加class<br>基于我的matery主题，我选择了第二种，主要思想就是加上一个”body.dark”来限制深色模式下的样式。</li></ul><h3 id="制作深色模式按钮"><a href="#制作深色模式按钮" class="headerlink" title="制作深色模式按钮"></a>制作深色模式按钮</h3><p>在主题的<code>layout.ejs</code>文件中找到body标签的开始标签在后面加上这些js和html代码，这里我放的位置为：<code>/layout/layout.ejs</code></p><pre><code>    &lt;script&gt;        if (localStorage.getItem(&#39;dark&#39;) === &#39;1&#39;) &#123;        document.body.classList.add(&#39;dark&#39;);        &#125;        else if (new Date().getHours() &gt;= 22 || new Date().getHours() &lt; 7) &#123;        document.body.classList.add(&#39;dark&#39;);        &#125;         else if (matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches) &#123;        document.body.classList.add(&#39;dark&#39;);        &#125;    &lt;/script&gt;    &lt;a onclick=&quot;switchNightMode()&quot; id=&quot;sma&quot;&gt;        &lt;i class=&quot;fa fa-moon-o&quot; id=&quot;nightMode&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;    &lt;/a&gt;</code></pre><h3 id="按钮的css样式："><a href="#按钮的css样式：" class="headerlink" title="按钮的css样式："></a>按钮的css样式：</h3><pre><code>    /* 深色模式按钮设置 */    #sma &#123;        background: #000;        width: 38px;        height: 38px;        display: block;        position: fixed;        border-radius: 50%;        right: 15px;        bottom: 170px;        padding-top: 15px;        margin-bottom: 0;        z-index: 998;        cursor: pointer;    &#125;    #sma .fa-moon-o &#123;        position: absolute;        right: 8px;        bottom: 8px;        font-size: 1.48rem!important;    &#125;    #sma .fa-lightbulb-o  &#123;        position: absolute;        right: 13px;        bottom: 8px;        font-size: 1.5rem!important;    &#125;    .fa-moon-o:before &#123;        content: &quot;\f186&quot;;    &#125;    .fa-comments:before &#123;        content: &quot;\f086&quot;;    &#125;</code></pre><h3 id="按钮的js代码"><a href="#按钮的js代码" class="headerlink" title="按钮的js代码"></a>按钮的js代码</h3><p>放在独立的js文件里即可，这里我放在<code>/souce/js/matery.js</code>里面</p><pre><code>    // 深色模式设置    function switchNightMode() &#123;        var body = document.body;        if(body.classList.contains(&#39;dark&#39;))&#123;        document.body.classList.remove(&#39;dark&#39;);        localStorage.setItem(&#39;dark&#39;,&#39;0&#39;);        $(&#39;#nightMode&#39;).removeClass(&quot;fa-lightbulb-o&quot;).addClass(&quot;fa-moon-o&quot;);        return;        &#125; else &#123;        document.body.classList.add(&#39;dark&#39;);        localStorage.setItem(&#39;dark&#39;,&#39;1&#39;);        $(&#39;#nightMode&#39;).removeClass(&quot;fa-moon-o&quot;).addClass(&quot;fa-lightbulb-o&quot;);        return;        &#125;    &#125;</code></pre><h3 id="最后，加上覆盖样式"><a href="#最后，加上覆盖样式" class="headerlink" title="最后，加上覆盖样式"></a>最后，加上覆盖样式</h3><p>原理：就是在你觉得深色模式下需要变色的css 选择器前面加上一个<code>body.dark</code>选择器<br>需要改变：</p><ul><li>字体颜色变灰/黑色     color: rgba(255, 255, 255, 0.75);</li><li>背景颜色变灰/黑色     background-color: #282c34;</li><li>图片加一个暗色遮罩    filter: brightness(.7);</li></ul><div class="note info">注意：以下css覆盖样式代码是根据我自己喜好修改的，若需要可直接复制粘贴，大体上原理就是这样，你也可以根据自己喜好改变需要变色的地方和颜色。</div><pre><code>    /* 深色模式设置 */    /* 字体颜色变灰白色 */     body.dark .fas,    body.dark .title,    body.dark .row .text,    body.dark article .article-content .summary,    body.dark .card .card-image .card-title,    body.dark .fa-moon-o:before,    body.dark .fa-lightbulb-o:before,    body.dark article .article-tags .chip,    body.dark .chip-container .tag-title,    body.dark div.jqcloud a,    body.dark .friends-container .tag-title,    body.dark .frind-ship .title h1,    body.dark .card .card-content p,    body.dark .v[data-class=v] .vcount,    body.dark .v[data-class=v] .vcount .vnum,    body.dark pre code,    body.dark h1,    body.dark h2,    body.dark h3,    body.dark h4,    body.dark h5,    body.dark h6,    body.dark li,    body.dark p,    body.dark header .side-nav .mobile-head .logo-name,    body.dark header .side-nav .mobile-head .logo-desc,    body.dark header .side-nav .menu-list a,    body.dark .bg-cover .post-title,    body.dark a    &#123;        color: rgba(255, 255, 255, 0.6);    &#125;    /* 背景颜色变灰色 */    body.dark .card,    body.dark .block-with-text:after    &#123;        background-color: #282c34;    &#125;    /* 背景颜色变黑色 */    body.dark,    body.dark .v[data-class=v] .vcount,    body.dark #rewardModal .modal-content,    body.dark .modal,    body.dark header .side-nav,    body.dark header .side-nav .menu-list .m-nav-show    &#123;        background-color: #12121c;    &#125;    /* 改变透明度 */    body.dark .aplayer&#123;background: #2f3742!important;&#125;    body.dark img, body.dark strong &#123;        filter: brightness(.7);    &#125;</code></pre><div class="note info">本文参考了以下两篇文章：如果你使用的是和我一样的matery主题，则可以直接复制上面代码，再做酌情修改样式即可，其他主题的也一样，逻辑都是一样的。</div><p><a href="https://bestzuo.cn/posts/blog-night-mode.html" class="LinkCard" target="_blank">给博客适配全局深色模式</a><br><a href="https://crosschannel.cc/daily/hexo%E6%B7%BB%E5%8A%A0%E6%9A%97%E8%89%B2%E6%A8%A1%E5%BC%8F.html" class="LinkCard" target="_blank">面向小白的Hexo添加暗色模式教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 关于hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客适配全局深色模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于hexo博客的note标签美化</title>
      <link href="/posts/hexo-note.html"/>
      <url>/posts/hexo-note.html</url>
      
        <content type="html"><![CDATA[<div class="note info">前言：为了美化hexo博客文章，所以加入note标签并加以美化</div><h3 id="引入FontAwesome-v4-7-0-版本的-CSS-文件"><a href="#引入FontAwesome-v4-7-0-版本的-CSS-文件" class="headerlink" title="引入FontAwesome v4.7.0 版本的 CSS 文件"></a>引入FontAwesome v4.7.0 版本的 CSS 文件</h3><pre><code>&lt;link type=&#39;text/css&#39; rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css&quot; media=&#39;all&#39;/&gt;</code></pre><h3 id="添加一段自定义css代码，复制即可"><a href="#添加一段自定义css代码，复制即可" class="headerlink" title="添加一段自定义css代码，复制即可"></a>添加一段自定义css代码，复制即可</h3><pre><code>    /* note 公共样式 */    .note &#123;        position: relative;        padding: 15px;        margin-top: 10px;        margin-bottom: 10px;        border: initial;        border-left: 3px solid #eee;        background-color: #f9f9f9;        border-radius: 3px;        font-size: var(--content-font-size);    &#125;    .note:not(.no-icon):before &#123;        position: absolute;        font-family: FontAwesome;        font-size: larger;        top: 11px;        left: 15px;    &#125;    .note:not(.no-icon) &#123;        padding-left: 45px;    &#125;    .note.info &#123;        background-color: #eef7fa;        border-left-color: #428bca;    &#125;    .note.info:not(.no-icon):before &#123;        content: &quot;\f05a&quot;;        color: #428bca;    &#125;    .note.warning &#123;        background-color: #fdf8ea;        border-left-color: #f0ad4e;    &#125;    .note.warning:not(.no-icon):before &#123;        content: &quot;\f06a&quot;;        color: #f0ad4e;    &#125;    .note.primary &#123;        background-color: #f5f0fa;        border-left-color: #6f42c1;    &#125;    .note.primary:not(.no-icon):before &#123;        content: &quot;\f055&quot;;        color: #6f42c1;    &#125;    .note.danger &#123;        background-color: #fcf1f2;        border-left-color: #d9534f;    &#125;    .note.danger:not(.no-icon):before &#123;        content: &quot;\f056&quot;;        color: #d9534f;    &#125;</code></pre><h3 id="最后，在写-md-文件时以-html-标签方式引入即可"><a href="#最后，在写-md-文件时以-html-标签方式引入即可" class="headerlink" title="最后，在写 md 文件时以 html 标签方式引入即可"></a>最后，在写 md 文件时以 html 标签方式引入即可</h3><div class="note warning">注意：每个div标签结束后面必须空一行</div><pre><code>&lt;div class=&quot;note info&quot;&gt;这里是 info 标签样式&lt;/div&gt;&lt;div class=&quot;note info no-icon&quot;&gt;这里是不带符号的 info 标签样式&lt;/div&gt;&lt;div class=&quot;note primary&quot;&gt;这里是 primary 标签样式&lt;/div&gt;&lt;div class=&quot;note primary no-icon&quot;&gt;这里是不带符号的 primary 标签样式&lt;/div&gt;&lt;div class=&quot;note warning&quot;&gt;这里是 warning 标签样式&lt;/div&gt;&lt;div class=&quot;note warning no-icon&quot;&gt;这里是不带符号的 warning 标签样式&lt;/div&gt;&lt;div class=&quot;note danger&quot;&gt;这里是 danger 标签样式&lt;/div&gt;&lt;div class=&quot;note danger no-icon&quot;&gt;这里是不带符号的 danger 标签样式&lt;/div&gt;</code></pre><p>效果图：</p><div class="note info">这里是 info 标签样式</div><div class="note info no-icon">这里是不带符号的 info 标签样式</div><div class="note primary">这里是 primary 标签样式</div><div class="note primary no-icon">这里是不带符号的 primary 标签样式</div><div class="note warning">这里是 warning 标签样式</div><div class="note warning no-icon">这里是不带符号的 warning 标签样式</div><div class="note danger">这里是 danger 标签样式</div><div class="note danger no-icon">这里是不带符号的 danger 标签样式</div>]]></content>
      
      
      <categories>
          
          <category> 关于hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客note标签美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于hexo发布博客或评论的一些图片、音视频markdown语法</title>
      <link href="/posts/blog-audio-video-markdown.html"/>
      <url>/posts/blog-audio-video-markdown.html</url>
      
        <content type="html"><![CDATA[<div class="note info">适用于：对于在发布博客文章和基于valine评论系统发布评论时的markdown语法编写场景</div><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><ul><li>一般情况下，可以将自己的图片上传至一个指定图床，便于调用。<br>博主目前用的是<code>sm.sm</code>这个图床，免费5G空间，传输也快，支持jpg、png、jpeg等格式，还支持视频转gif格式，这个比较赞，访问也比较快，唯一注意的是，需要搭梯子才能上传，所以按需选择。</li><li>另外，推荐一个”综合图床”，也很好用，可以多重选择。<br>链接：<br><a href="https://www.99yyw.com/tu/" class="LinkCard" target="_blank">综合图床</a></li></ul><pre><code>![这里填写图片的描述信息](这里填写图片的路径，相对或决定路径都可以)</code></pre><h3 id="插入音频"><a href="#插入音频" class="headerlink" title="插入音频"></a>插入音频</h3><h5 id="1-使用audio标签"><a href="#1-使用audio标签" class="headerlink" title="1.使用audio标签"></a>1.使用audio标签</h5><div class="note info">注意：一般将音频文件传入云存储端，然后再引用，所以后缀名一般为.mp3格式或者其他。</div><pre><code>&lt;audio src=&quot;音频路径&quot; controls=&quot;&quot; preload=&quot;metadata&quot;&gt;&lt;/audio&gt;</code></pre><p>效果图：<br><img src="https://i.loli.net/2020/09/19/e19Kqy8j6HfZxFb.png" alt="使用audio标签"></p><h5 id="2-使用iframe标签（例如获取网易云音乐的链接）"><a href="#2-使用iframe标签（例如获取网易云音乐的链接）" class="headerlink" title="2.使用iframe标签（例如获取网易云音乐的链接）"></a>2.使用iframe标签（例如获取网易云音乐的链接）</h5><ul><li>这里我以获取网易云音乐的链接为例<br>首先，在音乐播放界面，点击<code>“生成外链播放器”</code><br><img src="https://i.loli.net/2020/09/19/NUO6i7aWQYuPmLp.png" alt="1.PNG"><br>然后，就可以选择自己喜欢的尺寸大小的iframe模块，并复制下方代码即可。<br><img src="https://i.loli.net/2020/09/19/4M2lLr6o1c8eCkp.png" alt="2.PNG"><pre><code>&lt;!-- 例如 --&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=1463165983&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</code></pre>效果图：<br><img src="https://i.loli.net/2020/09/19/DAhGjqyrEKJfct7.png" alt="使用iframe标签网易云音乐"></li></ul><h3 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h3><p>这里我以引入<code>B站视频</code>为例，为什么？因为好用还免费，真的很良心了，小破站牛啊~</p><h5 id="1-使用B站网页版内嵌代码"><a href="#1-使用B站网页版内嵌代码" class="headerlink" title="1.使用B站网页版内嵌代码"></a>1.使用B站网页版内嵌代码</h5><ul><li>以B站网页版已经提供了内嵌的 iframe 代码，我们只需要一键复制后就可以直接使用。<br><img src="https://i.loli.net/2020/09/19/FwRWjsYdlap2D4K.png" alt><br>效果图：<br><img src="https://i.loli.net/2020/09/19/EIgMt9SNG1YwbqT.png" alt><br>但是发现，这样直接引入样式比较残缺，而且移动端适配也不太好，所以…<h5 id="2-封装一个自适应的iframe框架"><a href="#2-封装一个自适应的iframe框架" class="headerlink" title="2.封装一个自适应的iframe框架"></a>2.封装一个自适应的iframe框架</h5><pre><code>  &lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt;    &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;视频地址去B站分享按钮下iframe里面的src属性值复制&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;    &lt;/iframe&gt;  &lt;/div&gt;</code></pre>这样，效果就更佳也能自适应移动端。<br><img src="https://i.loli.net/2020/09/19/z7JbvyYFP4hL2mI.png" alt></li></ul>]]></content>
      
      
      <categories>
          
          <category> 关于hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown语法 </tag>
            
            <tag> 博客插入图片和音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello HarmonyOS</title>
      <link href="/posts/harmony-os.html"/>
      <url>/posts/harmony-os.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>基于微内核的全场景分布式操作系统。<br><code>HarmonyOS</code>是一款“面向未来”、面向全场景（移动办公、运动健康、社交通信、媒体娱乐等）的分布式操作系统。在传统的单设备系统能力的基础上，HarmonyOS提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持多种终端设备。</p><h3 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h3><p>框架层为HarmonyOS的应用程序提供了<code>Java/C/C++/JS</code>等多语言的用户程序框架和Ability框架，以及各种软硬件服务对外开放的多语言框架API；同时为采用HarmonyOS的设备提供了C/C++/JS等多语言的框架API，不同设备支持的API与系统的组件化裁剪程度相关。</p><p>开发工具 Huawei DevEco Studio<br><code>DevEco Studio</code> 应该是基于IDEA社区版二次开发。</p><p><a href="https://gitee.com/openharmony/docs/tree/master/readme" class="LinkCard" target="_blank">代码仓库</a></p><p><a href="https://gitee.com/openharmony/docs/tree/master/readme" class="LinkCard" target="_blank">快速入门</a></p><p><a href="http://tools.harmonyos.com/mirrors/os/1.0/code-1.0.tar.gz" class="LinkCard" target="_blank">源码下载</a></p><h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h2><p>下载IDE工具后，根据开发文档说明进行环境搭建。</p><p><a href="https://developer.harmonyos.com/cn/develop/deveco-studio#download" class="LinkCard" target="_blank">IDE下载</a></p><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/hello_world-0000001054516888" class="LinkCard" target="_blank">开发文档</a></p><ul><li>配置npm镜像<pre><code>npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --globalnpm info express</code></pre>运行开发者工具 -&gt; 创建工程<br>目前只有TV Wearable和Lite Wearable的Deivce支持…<br>gradle构建无需配置镜像<br>模拟器下载需要开发者中心认证</li></ul><h2 id="3-最后，期待OS界大佬进行进一步分析"><a href="#3-最后，期待OS界大佬进行进一步分析" class="headerlink" title="3.最后，期待OS界大佬进行进一步分析"></a>3.最后，期待OS界大佬进行进一步分析</h2><ul><li>HarmonyOS更倾向于IOT的开发.比如TV,wear, 智能家居方向</li><li>应用层开发对android开发者极其友好</li><li>android开发者不要慌,现在又可以多换一个不锈钢铁盆了</li></ul>]]></content>
      
      
      <categories>
          
          <category> Harmonyos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Harmonyos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode setting sync配置及使用</title>
      <link href="/posts/vscode-setting-sync.html"/>
      <url>/posts/vscode-setting-sync.html</url>
      
        <content type="html"><![CDATA[<p>前言：vsCode最大的缺点就是每次换个电脑或者临时去个新环境,就要配置一下各种插件,所以使用vscode setting sync配置即可同步自己设置的插件等。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>点击VSCode的插件栏搜索Settings Sync然后安装<br><img src="https://i.loli.net/2020/09/18/lIvuQwXadfD7x4c.png" alt="1.PNG"></p></li><li><p>安装完之后会弹出一个登陆界面,这里点击login with github<br><img src="https://i.loli.net/2020/09/18/BO58MZhXYLUo2lj.png" alt="2.PNG"></p></li><li><p>点击后会自动弹出一个登陆页面,登上你的github账户即可</p></li></ul><p><img src="https://i.loli.net/2020/09/18/xysehwkg8nmuIo5.png" alt="3.PNG"></p><ul><li>需要重启vscode</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.这里如果你是在vscode insider下面第一次使用这个软件,不用去创建什么gits Tonken,直接F1或者ctrl + shift + p搜索sync</p><ul><li>再选择 Sync: Upload / Update Settings 后会直接生成一个gits id(记得存好这个id)</li></ul><p><img src="https://i.loli.net/2020/09/18/KZleMBLtVpO8Pjz.png" alt="4.PNG"></p><p>2.在vscode任意界面按 Alt + Shift + U即可上传当前配置，并生成一个gits id.此时终端会打印上传成功的日志信息<br>3.保存好gits id，在需要导入远程配置的电脑上安装好该插件，使用组合键 Alt + Shift + D 即可下载配置。</p>]]></content>
      
      
      <categories>
          
          <category> vscode使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh-key配置</title>
      <link href="/posts/ssh-key.html"/>
      <url>/posts/ssh-key.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-检查ssh-key-是否存在"><a href="#1-检查ssh-key-是否存在" class="headerlink" title="1.检查ssh key 是否存在"></a>1.检查ssh key 是否存在</h3><p><code>ls -al ~/.ssh</code><br>如果key存在，会有<code>id_rsa</code>和<code>id_rsa.pub</code>可以直接将key复制到远程GitHub上。</p><p>如果key不存在，生成key<br>在命令行中输入：<br><code>ssh-keygen -t rsa -C &#39;your_email@example.com&#39;</code>默认生成一个<br>密码，名称什么的都一路回车就OK了<br>将公有key(id_rsa.pub)复制到远程GitHub里，可以给你的key起一个名字</p><h3 id="2-查看公钥内容（即用来做ssh-key用的"><a href="#2-查看公钥内容（即用来做ssh-key用的" class="headerlink" title="2.查看公钥内容（即用来做ssh key用的)"></a>2.查看公钥内容（即用来做ssh key用的)</h3><p><code>$ cat ~/.ssh/id_rsa.pub</code><br>如果id_rsa.pub文件找不到，可以在终端中使用<code>open ~/.ssh</code> ，打开ssh文件，可以看到<code>id_rsa,id_rsa.pub</code>文件；也可以在前往中终端输入”<code>~/.ssh</code>“来查看是否存在id_rsa.pub文件</p><h3 id="3-配置多个ssh-key"><a href="#3-配置多个ssh-key" class="headerlink" title="3.配置多个ssh-key"></a>3.配置多个ssh-key</h3><ul><li>生成一个公司用的SSH-Key<br><code>ssh-keygen -t rsa -C &#39;youremail@yourcompany.com&#39; -f ~/.ssh/id-rsa</code><br>在~/.ssh/目录会生成id-rsa和id-rsa.pub私钥和公钥。</li><li>生成一个其他用的SSH-Key<br><code>ssh-keygen -t rsa -C &#39;youremail@your.com&#39; -f ~/.ssh/github-rsa</code><br>在~/.ssh/目录会生成github-rsa和github-rsa.pub私钥和公钥。</li><li>添加私钥<br><code>ssh-add ~/.ssh/id_rsa $ ssh-add ~/.ssh/github_rsa</code><br>如果执行ssh-add时提示”Could not open a connection to your authentication agent”，可以先执行命令：<br><code>$ ssh-agent bash</code><br>然后再运行ssh-add命令。<br><code>ssh-add ~/.ssh/id_rsa $ ssh-add ~/.ssh/github_rsa</code></li><li>修改配置文件<br>若.ssh目录(就是私钥所在的文件夹)下无config文件，那么创建<br><code>touch config</code><br>在config文件添加以下内容<pre><code># gitlabHost github.comPort 22HostName github.comPreferredAuthentications publickeyIdentityFile C:/Users/xxx/.ssh/github-rsaUser xxx</code></pre></li><li>配置文件参数<pre><code># Host : Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件（可以直接填写ip地址）# HostName : 要登录主机的主机名（建议与Host一致）# User : 登录名（如gitlab的username）# IdentityFile : 指明上面User对应的identityFile路径# Port: 端口号（如果不是默认22号端口则需要指定）</code></pre></li><li>测试<br><code>$ ssh -T git@github.com</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh-key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目上线流程</title>
      <link href="/posts/project-launch.html"/>
      <url>/posts/project-launch.html</url>
      
        <content type="html"><![CDATA[<p>域名：新网 万网<br>服务器及域名购买(略)</p><h2 id="安装各种环境"><a href="#安装各种环境" class="headerlink" title="安装各种环境"></a>安装各种环境</h2><p>1、任意命令行工具里输入ssh root@服务器公网IP</p><p>2、输入yes，然后输入服务器开机密码。密码处于安全考虑不会显示<br><img src="https://i.loli.net/2020/09/13/MtVHkWlQyn2IPNz.png" alt="1.PNG"></p><p>3、安装git yum install git<br><img src="https://i.loli.net/2020/09/13/EVCQ71ukzbBotFN.png" alt="2.PNG"></p><p><img src="https://i.loli.net/2020/09/13/zXUS6iu9j7deW3H.png" alt="3.PNG"><br>4、安装node高版本，安好之后就有node和npm<br><code>$ curl -sL https://rpm.nodesource.com/setup_10.x | sudo bash -</code><br><code>$ yum install nodejs</code><br>5、一般在data文件夹下放数据，通过touch index.html可以创建一个文件，使用自带的vi/vim工具可以进行编辑，cat命令只查看不编辑<br>6、安装httpserver <code>npm i http-server -g</code><br>7、 <code>http-server</code> 启动服务<br>8、安装pm2 让node进程保持后台运行 <code>npm i pm2 -g</code><br><code>pm2 start http-server</code> 让服务器保持运行<br><code>pm2 list/ls</code> 查看有哪些通过pm2运行的服务<br><code>pm2 delete 需要关闭服务的id</code> 停止服务</p><h2 id="通过nginx部署服务"><a href="#通过nginx部署服务" class="headerlink" title="通过nginx部署服务"></a>通过nginx部署服务</h2><p>1、安装nginx <code>yum install nginx -y</code><br>nginx的配置文件在etc/nginx/conf.d/*.conf这个文件里面<br><img src="https://i.loli.net/2020/09/13/E6kZqo7ywhxTM1j.png" alt="4.PNG"></p><p>基本配置：进入到 /etc/nginx/conf.d 新建一个 <strong>任意名字.conf</strong> 在里面写入server的配置<br><em>pwd</em> 查看当前所在的路径<br><em>i</em> 编辑 insert<br><em>:wq</em> 保存并退出</p><pre><code>server &#123;    listen 8000; // 端口    root /var/www/yourfolder/build/; // 指向你要访问的文件夹    location / &#123;        try_files $uri $uri/ /index.html;    &#125;    location /api/ &#123;        proxy_pass http://serverip:4444;    &#125;</code></pre><p>完成后保存，并重启nginx服务：<br><code>$ nginx -t</code><br>这时执行<br><code>$ nginx -c /etc/nginx/nginx.conf</code>  只需执行一次<br><code>$ nginx -s reload</code></p><p>2、解析域名，通过域名访问之前的IP地址：<br><img src="https://i.loli.net/2020/09/13/xTw7VKXbn98l2mO.png" alt="5.PNG"></p><p>3、通过git clone 项目地址来克隆自己的项目<br>4、npm i 安装项目所需的所有依赖<br>5、npm run serve 运行服务<br>6、npm run build 部署<br>解决nginx不能npm run build的问题：</p><pre><code>$ sudo /bin/dd if=/dev/zero of=/var/swap.1 bs=1M count=1024$ sudo /sbin/mkswap /var/swap.1$ sudo /sbin/swapon /var/swap.1</code></pre><p>7、在conf.d下面创建一个项目需要的配置文件，来指向项目目录下的dist文件夹下面的index文件<br>如果获取不到数据报错，需要设置nginx代理：<br><code>location /api &#123; proxy_pass 需要获取的数据来源地址;&#125;</code><br>8、遇到页面刷新报错就在conf.d里加入一个这样的location：</p><pre><code>location / &#123;  try_files $uri $uri/ /index.html;&#125;</code></pre><p>最后效果如下图：</p><p><img src="https://i.loli.net/2020/09/13/MEIBiWmRnUL7AOk.png" alt="6.PNG"></p><p>遇到nginx 403 forbidden问题解决办法<br>打开nginx.conf把用户名设置为主机名，一般是root</p><pre><code>$ vim nginx.conf      user root</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目上线流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目上线流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于图片加载优化</title>
      <link href="/posts/img-loading.html"/>
      <url>/posts/img-loading.html</url>
      
        <content type="html"><![CDATA[<h2 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h2><ul><li>不用图片</li><li>对于移动端来说,一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 base64 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3></li><li>利用Lodash</li></ul><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。</p><ul><li>_.debounce防抖函数<ul><li>参数<br>func (Function): 要防抖动的函数。<br>[wait=0] (number): 需要延迟的毫秒数。<br>[options={}] (Object): 选项对象。<br>[options.leading=false] (boolean): 指定在延迟开始前调用。<br>[options.maxWait] (number): 设置 func 允许被延迟的最大值。<br>[options.trailing=true] (boolean): 指定在延迟结束后调用。<br>返回<br>(Function): 返回新的 debounced（防抖动）函数。<br>```javascript<br>// 避免窗口在变动时出现昂贵的计算开销。<br>jQuery(window).on(‘resize’, _.debounce(calculateLayout, 150));</li></ul></li></ul><p>// 当点击时 <code>sendMail</code> 随后就被调用。<br>jQuery(element).on(‘click’, _.debounce(sendMail, 300, &#123;<br>  ‘leading’: true,<br>  ‘trailing’: false<br>&#125;));</p><p>// 确保 <code>batchLog</code> 调用1次之后，1秒内会被触发。<br>var debounced = _.debounce(batchLog, 250, &#123; ‘maxWait’: 1000 &#125;);<br>var source = new EventSource(‘/stream’);<br>jQuery(source).on(‘message’, debounced);</p><p>// 取消一个 trailing 的防抖动调用<br>jQuery(window).on(‘popstate’, debounced.cancel);</p><pre><code>自己封装防抖函数：```javascript// func是用户传入需要防抖的函数// wait是等待时间const debounce = (func, wait = 50) =&gt; &amp;#123;  // 缓存一个定时器id  let timer = 0  // 这里返回的函数是每次用户实际调用的防抖函数  // 如果已经设定过定时器了就清空上一次的定时器  // 开始一个新的定时器，延迟执行用户传入的方法  return function(...args) &amp;#123;    if (timer) clearTimeout(timer)    timer = setTimeout(() =&gt; &amp;#123;      func.apply(this, args)    &amp;#125;, wait)  &amp;#125;&amp;#125;</code></pre><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。</p><ul><li>thorttle节流函数<ul><li>参数<br>func (Function): 要节流的函数。<br>[wait=0] (number): 需要节流的毫秒。<br>[options={}] (Object): 选项对象。<br>[options.leading=true] (boolean): 指定调用在节流开始前。<br>[options.trailing=true] (boolean): 指定调用在节流结束后。<br>返回<br>(Function): 返回节流的函数。<br>```javascript<br>// 避免在滚动时过分的更新定位<br>jQuery(window).on(‘scroll’, _.throttle(updatePosition, 100));</li></ul></li></ul><p>// 点击后就调用 <code>renewToken</code>，但5分钟内超过1次。<br>var throttled = _.throttle(renewToken, 300000, &#123; ‘trailing’: false &#125;);<br>jQuery(element).on(‘click’, throttled);</p><p>// 取消一个 trailing 的节流调用。<br>jQuery(window).on(‘popstate’, throttled.cancel);</p><pre><code>自己封装节流函数：```javascript// func是用户传入需要防抖的函数// wait是等待时间const throttle = (func, wait = 50) =&gt; &amp;#123;  // 上一次执行该函数的时间  let lastTime = 0  return function(...args) &amp;#123;    // 当前时间    let now = +new Date()    // 将当前时间和上一次执行函数时间对比    // 如果差值大于设置的等待时间就执行函数    if (now - lastTime &gt; wait) &amp;#123;      lastTime = now      func.apply(this, args)    &amp;#125;  &amp;#125;&amp;#125;setInterval(  throttle(() =&gt; &amp;#123;    console.log(1)  &amp;#125;, 500),  1)</code></pre><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p><pre><code>&lt;link rel=&quot;preload&quot; href=&quot;http://example.com&quot;&gt;</code></pre><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。<br>对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。</p><p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。</p><p>因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。</p><p>并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片加载优化 </tag>
            
            <tag> 防抖/节流 </tag>
            
            <tag> 懒/预加载 </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JS获取当前页面的URL(网址信息)</title>
      <link href="/posts/get-url.html"/>
      <url>/posts/get-url.html</url>
      
        <content type="html"><![CDATA[<pre class=" language-lang-javascript"><code class="language-lang-javascript">var url;url = window.location.href; /* 获取完整URL */alert(url); /* http://127.0.0.1:8020/Test/index.html#testname=test */url = window.location.pathname; /* 获取文件路径（文件地址） */alert(url); /* /Test/index.html */url = window.location.protocol; /* 获取协议 */alert(url); /* http */url = window.location.host; /* 获取主机地址和端口号 */alert(url); /* http://127.0.0.1:8020/ */url = window.location.hostname; /* 获取主机地址 */alert(url); /* http://127.0.0.1/ */url = window.location.port; /* 获取端口号 */alert(url); /* 8020 */url = window.location.hash; /* 获取锚点（“#”后面的分段） */alert(url); /* #test?name=test */url = window.location.search; /* 获取属性（“?”后面的分段） */alert(url);/* 如果需要URL中的某一部分，可以自己进行处理 */url = window.location.pathname;url = url.substring(url.lastIndexOf('/') + 1, url.length);alert(url); /* /index.html *//*  * 如果页面使用了框架（frameset） * 要获取到指定页面的URL * 只要把window换成指定的页面即可 *//* 'frame'为指定页面的class名 */var url = window.parent.frames['frame'].location.href;/* 获取当前地址栏中显示的URL */var url = window.parent.location.href;/* window parent 可互换 */var url = parent.window.location.href;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS获取当前页面的URL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP+Mysql知识</title>
      <link href="/posts/php-mysql.html"/>
      <url>/posts/php-mysql.html</url>
      
        <content type="html"><![CDATA[<h2 id="PHP（HyperText-Preprocessor）"><a href="#PHP（HyperText-Preprocessor）" class="headerlink" title="PHP（HyperText Preprocessor）"></a>PHP（HyperText Preprocessor）</h2><p>是一种创建动态交互性站点的强有力的服务器端脚本语言。</p><ul><li>第一句 Hello World<pre><code>&lt;?php  echo &#39;hello word&lt;br&gt;&#39;; // echo(&#39;hello word&lt;br&gt;&#39;); //输出结果为?&gt;</code></pre>die()  &gt;&gt; 输出内容的同时结束程序</li></ul><p>1) 变量</p><pre><code>  $num = 20;  echo $num;</code></pre><p>2)for()</p><pre><code>for ($i=1; $i&lt;=5; $i++)&amp;#123;  echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;&amp;#125;</code></pre><p>3)while</p><pre><code>  $x = 1;  while($x &lt; 10)&amp;#123;    $x++;    echo $x;  &amp;#125;</code></pre><p>4) if else</p><pre><code>if (条件1)&#123;     条件1成立时执行的代码；&#125;elseif(条件2)&#123;     条件1不成立但条件2成立时执行的代码；&#125;else&#123;    条件1条件2都不成立时执行的代码；&#125;</code></pre><p>5)变量|函数：</p><p>其实PHP最经典，也是最核心的地方就是函数，PHP提供了超过一千种內建函数，参考手册点击前往;</p><ul><li><p>函数：function 关键字声明函数;</p></li><li><p>函数分成两个部分，一部分是函数体，另一部分是函数调用；</p></li><li><p>函数体：</p><pre><code>function(关键字) fnName(函数名任意值) ()(小括号,其中可以有形参)&#123;//待执行语句;return //如果遇到return关键字则终止函数运行，并将return后的值作为函数的返回值;&#125;</code></pre></li><li><p>函数调用:<br>目的：执行函数体中待执行语句;</p></li></ul><p>fnName(函数名) ()(小括号,期中可以传入实参)</p><pre><code>$x = 123fnName($x );</code></pre><ul><li>超级全局变量：</li></ul><p>这种变量在脚本的全局都可以使用：</p><ul><li><p>$GLOBALS</p></li><li><p>$_SERVER</p></li><li><p>$_REQUEST</p></li><li><p>$_POST</p></li><li><p>$_GET</p></li><li><p>$_FILES</p></li><li><p>$_ENV</p></li><li><p>$_COOKIE</p></li><li><p>$_SESSION<br>以上都是超级全局变量；</p></li></ul><ul><li><p>$_REQUEST会收集表单提交的信息；</p><pre><code>&lt;html&gt;  &lt;body&gt;      &lt;form action=&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;&quot;&gt;              &lt;!-- 利用$_SERVER获取当前脚本地址  --&gt;              &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;              &lt;input type=&quot;submit&quot; value=&quot;处理数据&quot;&gt;      &lt;/form&gt;      &lt;?php          if($_REQUEST)&#123;              $userName = $_REQUEST[&#39;user&#39;];              echo $userName;          &#125;       ?&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>$_POST|$_GET 用于收集表单数据，但是这里规定了发送方式，也就是表单上的method=’PSOT’|method=”GET”；</p><pre><code>&lt;html&gt;  &lt;body&gt;      &lt;form method=&quot;POST&quot; action=&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;&quot;&gt;              &lt;!-- 利用$_SERVER获取当前脚本地址  --&gt;              &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;              &lt;input type=&quot;submit&quot; value=&quot;处理数据&quot;&gt;      &lt;/form&gt;      &lt;?php          if($_POST)&#123;              $userName = $_POST[&#39;user&#39;];              echo $userName;          &#125;       ?&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre></li></ul><h3 id="php中的数据类型："><a href="#php中的数据类型：" class="headerlink" title="php中的数据类型："></a>php中的数据类型：</h3><p>共有八中数据类型：</p><p>1.boolean（布尔型）;<br>2.integer（整型）;<br>3.float(浮点型);<br>4.string(字符串)<br>5.array（数组）<br>6.object(对象)<br>7.resource（资源）<br>8.NULL（null）</p><ul><li><p>PHP为我们提供了和typeof一样功能的一个PHP方法gettype()<br>这个方法主要返回当前数据的数据类型;</p></li><li><p>同时还为我们提供了更有趣的方法:var_dump() 这个方法会返回给我们当前数据类型和数据值</p></li><li><p>当我们真正想要判断这个值的数据类型的时候我们用is系列的方法；这个系列的方法返回的是布尔值，用于if判断;</p><pre><code>is_int()  是不是整型;is_bool()是不是布尔值;is_string()是不是字符串;is_array()是不是数组类型；is_double()是不是浮点数；</code></pre></li></ul><h3 id="数组-对象"><a href="#数组-对象" class="headerlink" title="数组/对象"></a>数组/对象</h3><p>1.数组是啥？</p><p>用来储存多个数据的数据类型;</p><p>2.创建数组：</p><p>$arr = array(1,2,3,4,5)；</p><p>使用数组：</p><pre><code>$arr[0] //1$arr[1]//2$arr[2]//3$arr[3]//4$arr[4]//5</code></pre><p>手动数组赋值：</p><pre><code>$arr[0] = 11;</code></pre><ul><li>数组相关方法:<ul><li>获取数组长度：count()函数;</li></ul></li></ul><p>count($arr);//返回数组长度;</p><p>这样我们就可以写for循环了,数组中的内容我们就可以遍历出来了;</p><pre><code>for($x = 0 ; $x &lt; count($arr) ; $x++)&#123;     echo $arr[$x];&#125;</code></pre><ul><li>php关联数组：（用=&gt;链接起来）<pre><code>$testArray = array(&#39;name&#39; =&gt; &quot;zhangsan&quot;,&#39;age&#39; =&gt; 17 );echo $testArray[&#39;name&#39;].&#39;\&#39;s age is &#39;.$testArray[&#39;age&#39;];</code></pre></li><li><p>数组排序：<br>sort() || rsort() ;<br>sort（）:升序排列； rsort() :降序排列;</p></li><li><p>遍历关联数组：foreach();</p><ul><li>foreach()第一个参数为数组&gt;&gt; foreach($arr);</li><li>foreach()第二个参数为关键字as代表在数组中找到的值赋给后面的变量 &gt;&gt; foreach($arr as);</li><li>foreach()第三个和第四个参数为key和value ；也就是关联数组中的键和值 用 =&gt; 链接 &gt;&gt; froeach($arr as $key =&gt; value);</li></ul></li></ul><pre><code>  $arr = array(&#39;firstName&#39; =&gt; &#39;yang&#39;, &#39;lastName&#39; =&gt; &#39;huaizhi&#39;);  foreach ($arr as $key =&gt; $value) &#123;    echo $key.&#39;&lt;br&gt;&#39;;    echo $value.&#39;&lt;br&gt;&#39;;  &#125;</code></pre><ul><li>返回json <ul><li>json_encode()方法进行json格式的转码；</li><li>json_decode()方法对json进行解析</li></ul></li></ul><h2 id="数据库（database）："><a href="#数据库（database）：" class="headerlink" title="数据库（database）："></a>数据库（database）：</h2><p>按照数据结构来组织、存储和管理数据的仓库</p><ul><li><p>RDBMS：关系型数据库（MongoDB  非关系型数据库）</p><ul><li>DB2</li><li>Oracle</li><li>SQLServer—MSSQL</li><li>MySQL</li></ul></li><li><p>SQL：结构化查询语言</p><ul><li>DDL ：数据定义语言</li><li>DCL ：数据控制语言</li><li>DML ：数据操纵语言，INSERT（添加）、UPDATE（修改）、DELETE（删除）</li><li>DQL ：数据查询语言，SELECT（查询）</li><li>CRUD : 数据：添加（ Create）、查询（ Retrieve）、修改（ Update）、除（ Delete）</li></ul></li><li><p>概念：</p><ul><li>数据库：存储数据的仓库</li><li>表：仓库里面的房间</li><li>列（字段）：房间里的箱子</li><li>行（记录）：箱子里的数据</li><li>主键：唯一标识记录</li><li>外键：</li></ul></li></ul><h3 id="使用MySQL："><a href="#使用MySQL：" class="headerlink" title="使用MySQL："></a>使用MySQL：</h3><p>  a. 安装<br>  b. 启动MySQL数据库服务<br>  c. 使用Navicat管理MySQL数据库：NAVH-WK6A-DMVK-DKW3</p><ul><li>1.建立连接</li><li>2.创建数据库</li><li>3.在数据库中创建表<br>数据类型：<br>  数字：int double decimal numeric<br>  字符串：char  varchar  text<br>  日期时间：date、time、datetime、timestamp</li><li><p>4.CRUD<br>插入：</p><pre><code>INSERT INTO 表名(列名) VALUES (列值)</code></pre><p>修改：</p><pre><code>UPDATE 表名SET 列名=新列值, 列名=新列值WHERE 条件注意，不给修改的条件（WHERE子句）则会修改整张表的数据，这种修改是不可撤销的修改</code></pre><p>删除：</p><pre><code>DELETE FROM 表名WHERE 条件注意，不给删除的条件（WHERE子句）则会删除整张表的数据，这种删除是不可撤销</code></pre><p>查询：</p><pre><code>SELECT 列名FROM 表名WHERE 条件ORDER BY 排序列 ASC|DESCLIMIT 起始索引, 限定行数ASC-升序DESC-降序SELECT id, name, birthdayFROM studentsORDER BY id ASCLIMIT 3, 3模糊查询：    LIKE    SELECT id, name, birthday    FROM students    WHERE name LIKE &#39;李%&#39;</code></pre></li></ul><ul><li>创建用户表：<br>  列：编号、用户名、密码、昵称、出生日期、积分、等级、注册时间</li><li>使用SQL：<br>  向用户表中添加10条测试数据<br>  修改用户数据<br>  删除用户数据<br>  查询用户数据</li></ul><h3 id="PHP连接数据库操作："><a href="#PHP连接数据库操作：" class="headerlink" title="PHP连接数据库操作："></a>PHP连接数据库操作：</h3><pre><code>a. 建立连接  mysql_connect(servername,username,password);    -- servername 服务器名    -- username 登录数据库的用户名    -- password 密码b. 选择数据库    mysql_select_db(dbname)c. 设置编码d. 编写SQL语句e. 执行SQL语句  $result = mysql_query($sql);    -- 对 INSERT、UPDATE、DELETE 的SQL语句，返回的是布尔值：true表SQL语句执行成功，false表示SQL语句执行失败    -- 对 SELECT ，返回的是查询的结果集（虚拟的表格）f. 处理执行结果    -- 对于查询结果集，可以使用 mysql_fetch_assoc($result) 来读取查询结果集中的一行，放置到数组中保存g. 关闭连接    mysql_close();</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP+Mysql知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http知识</title>
      <link href="/posts/about-http.html"/>
      <url>/posts/about-http.html</url>
      
        <content type="html"><![CDATA[<h2 id="应用程序分类："><a href="#应用程序分类：" class="headerlink" title="应用程序分类："></a>应用程序分类：</h2><ul><li>B/S：Browser（浏览器）/ Server（服务器）</li><li>C/S：Client（客户端）/ Server（服务器）</li></ul><h2 id="http协议：基于TCP-IP的’无状态’通信协议"><a href="#http协议：基于TCP-IP的’无状态’通信协议" class="headerlink" title="http协议：基于TCP/IP的’无状态’通信协议"></a>http协议：基于TCP/IP的’无状态’通信协议</h2><p>前端（浏览器客户端）向后台（web服务器端）发送http请求获取数据</p><h2 id="http请求报文："><a href="#http请求报文：" class="headerlink" title="http请求报文："></a>http请求报文：</h2><ul><li><p>一个HTTP请求报文由4个部分组成：</p><ul><li>请求行（request line）、</li><li>请求头部（header）</li><li>空行</li><li>请求数据</li></ul></li><li><p>1.form的enctype属性为编码方式，常用有两种：</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li></ul></li><li>2.默认为application/x-www-form-urlencoded。</li><li>3.当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2…），然后把这个字串追加到url后面，用?分割，加载这个新的url。</li><li>4.当action为post时候，浏览器把form数据封装到http body中，然后发送到server。 如果没有type=file的控件，用默认的application/x-www-form-urlencoded就可以了。 但是如果有type=file的话，就要用到multipart/form-data了。</li><li>5.当action为post且Content-Type类型是multipart/form-data，浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件name)等信息，并加上分割符(boundary)。</li></ul><h2 id="http响应报文："><a href="#http响应报文：" class="headerlink" title="http响应报文："></a>http响应报文：</h2><p>Response Headers里的Content-Type指服务器告诉浏览器相应的数据，类型一般有这三种：</p><ul><li>application/x-www-form-urlencoded：数据被编码为名称/值对。这是标准的编码格式</li><li>multipart/form-data： 数据被编码为一条消息，页上的每个控件对应消息中的一个部分</li><li>text/plain： 数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符</li></ul><h2 id="Status-Code表示服务器发回的响应状态代码；"><a href="#Status-Code表示服务器发回的响应状态代码；" class="headerlink" title="Status-Code表示服务器发回的响应状态代码；"></a>Status-Code表示服务器发回的响应状态代码；</h2><h2 id="Reason-Phrase表示状态代码的文本描述。"><a href="#Reason-Phrase表示状态代码的文本描述。" class="headerlink" title="Reason-Phrase表示状态代码的文本描述。"></a>Reason-Phrase表示状态代码的文本描述。</h2><p>状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。<br>1xx：指示信息—表示请求已接收，继续处理。<br>2xx：成功—表示请求已被成功接收、理解、接受。<br>3xx：重定向—要完成请求必须进行更进一步的操作。<br>4xx：客户端错误—请求有语法错误或请求无法实现。<br>5xx：服务器端错误—服务器未能实现合法的请求。</p><ul><li>常见状态代码、状态描述的说明如下。<br>200 OK：客户端请求成功。<br>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。<br>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。<br>403 Forbidden：服务器收到请求，但是拒绝提供服务。<br>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。<br>500 Internal Server Error：服务器发生不可预期的错误。<br>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li></ul>]]></content>
      
      
      <categories>
          
          <category> http知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http知识 </tag>
            
            <tag> http请求 </tag>
            
            <tag> http响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当浏览器地址栏输入url地址后，敲下回车会发生什么？</title>
      <link href="/posts/parsing-url.html"/>
      <url>/posts/parsing-url.html</url>
      
        <content type="html"><![CDATA[<h3 id="当浏览器地址栏输入一个url网址后，敲下回车会发生什么？"><a href="#当浏览器地址栏输入一个url网址后，敲下回车会发生什么？" class="headerlink" title="当浏览器地址栏输入一个url网址后，敲下回车会发生什么？"></a>当浏览器地址栏输入一个url网址后，敲下回车会发生什么？</h3><ul><li><p>1.利用DNS域名解析系统进行域名解析，将域名解析成IP<br>因为域名只是一个别名，计算机只认识IP，所以需要DNS解析一下（如果有端口号需要识别端口号，否则进入默认端口：http协议默认端口号是80，https默认端口号是443）</p></li><li><p>2.查找ip对应的主机服务器<br>如果是第一次访问该服务器，会向网络供应商（移动、联通…）请求</p></li><li><p>3.TCP的三次握手，经过三次在客户端和服务器之间传递报文，建立连接</p></li><li><p>4.发起http请求，请求入口文件，后端接收到请求相关信息，返回入口文件</p></li><li><p>5.解析入口文件，同时如果有资源请求继续发送http请求…</p></li><li><p>6.过程中如果碰到css文件，js文件，需要去加载外部文件</p><ul><li>加载css，渲染html结构</li><li>加载js</li><li>执行js的逻辑，有ajax请求，在此去服务器请求数据</li><li>通过数据刷新DOM</li></ul></li><li><p>7.文件渲染完成（TCP的四次挥手，断开连接）</p></li></ul><p><img src="https://i.loli.net/2020/09/12/4TJIu2gLXBphMP7.png" alt="访问网页过程"></p>]]></content>
      
      
      <categories>
          
          <category> 一些面试常问问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器地址栏输入url地址发生的事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用流程</title>
      <link href="/posts/use-git.html"/>
      <url>/posts/use-git.html</url>
      
        <content type="html"><![CDATA[<p>写在前面的话：史上最浅显易懂的Git教程！推荐廖雪峰的教程！<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>分布式的版本管理系统</p><p>git init可以把当前目录初始化为一个git仓库，当初始化完成之后，在目录下就有一个叫.git的隐藏目录，这个目录咱们一般不会去多操作它，这个目录一旦删除，那就相当于当前目录就是一个普通的目录，而不再是一个git仓库。</p><p>初次运行git的时候可能需要配置全局的用户名和邮箱：</p><pre class=" language-lang-bash"><code class="language-lang-bash">$ git config --global user.name "John Doe"$ git config --global user.email johndoe@example.com</code></pre><p>只要全局配置了之后，在你的用户根目录下，就有一个.gitconfig的文件，直接修改这个文件和命令行修改，结果一样。</p><p>git的语义化commit</p><h3 id="公钥配置"><a href="#公钥配置" class="headerlink" title="公钥配置"></a>公钥配置</h3><p>在任意位置打开gitbash，输入$ ssh-keygen ，只需要通过这个命令回答问题的方式，就可以生成密钥对,会新增一个.ssh文件夹。 读法： ssh-key gen =&gt; generator<br>“密钥对” 保存位置 =&gt;用户目录/.ssh/</p><p>Generating public/private rsa key pair.<br>Enter file in which to save the key (/Users/Leo/.ssh/id_rsa): 这里一定是写带路径的名字/Users/Leo/.ssh/id_rsa_coding<br>在ssh目录下就会出现这样的<br>id_rsa_coding id_rsa_coding.pub 公钥，用于放在coding上的</p><p>可以添加公钥到git平台</p><p>新建一个 (这里没有点)config(这里没有扩展名) 文件， 这个文件关联服务器和密钥对，要配置多个平台就在这个文件里继续新增一条配置，不用新建config文件。</p><p>Host git.dev.tencent.com（这里的地址是你的git地址）<br>User Leo （这里的名字随便写）<br>PreferredAuthentications publickey （注意一个字母都不能少，而且区分大小写）<br>IdentityFile ~/.ssh/id_rsa_coding (这个就是你要使用哪一个密钥对, windows上也是全路径)</p><h3 id="git基本流程"><a href="#git基本流程" class="headerlink" title="git基本流程"></a>git基本流程</h3><p>git init: 初始化一个git仓库，如果做错了，显示隐藏文件，删除.git目录<br>git status: 查看状态<br>git add 文件名: 添加某个文件<br>git add .(-A): 添加所有修改<br>git checkout 文件名 在add之前回退<br>git reset —hard 在add之后回退<br>git commit -m ‘写你的消息’<br>git log 查看提交历史 按字母 q（uit）退出<br>git reset —hard 版本号 在commit之后回退到指定的版本<br>git diff(erence) 可以查看没add的不同<br>git remote add origin (git@git.dev.tencent.com:leochow/renzaoge.git 仓库地址)<br>git clone: 克隆远程仓库到本地<br>git branch 查看本地分支<br>git branch -r 查看远程分支<br>git branch -D 分支名 删除某个分支<br>git checkout 分支名： 切换到已有的分支<br>git checkout -b 分支名: 新建一个分支，并且切换到该分支<br>git push origin 远程分支名: 如果远程已经存在同名分支，则会有冲突或者合并，如果没有，就会创建一个远程分支，并且和当前分支是关联的</p><h3 id="pull-request-pr-新建-合并请求步骤"><a href="#pull-request-pr-新建-合并请求步骤" class="headerlink" title="pull request(pr), 新建 合并请求步骤"></a>pull request(pr), 新建 合并请求步骤</h3><h4 id="rebase-流程"><a href="#rebase-流程" class="headerlink" title="rebase 流程"></a>rebase 流程</h4><p>pre-1: 在基准分支（dev）上接取最新的代码 git pull origin dev<br>pre-2: 切换到自己的分支上 git checkout Leo/home</p><p>git rebase dev<br>解决冲突<br>git add -A<br>git rebase —continue<br>重复2，3，4<br>至到reabase完成<br>有可能本地自己的分支和远程分支还有冲突，这时候需要git pull …… 之后，解决冲突再push</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git使用流程 </tag>
            
            <tag> Git公钥配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-SCSS代码规范</title>
      <link href="/posts/css-scss.html"/>
      <url>/posts/css-scss.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-注释规范"><a href="#1-注释规范" class="headerlink" title="1 注释规范"></a>1 注释规范</h2><h2 id="2-缩进-空格-换行规范"><a href="#2-缩进-空格-换行规范" class="headerlink" title="2 缩进/空格/换行规范"></a>2 缩进/空格/换行规范</h2><p>(1)每个缩进使用4个空格，不允许使用 2 个空格 或 tab</p><pre class=" language-lang-css"><code class="language-lang-css">//正确.sample &#123;    display: flex;&#125;//错误.sample &#123;  display: flex;&#125;(2)选择器 与 花括号 之间必须包含空格```css//正确.sample &#123;    display: flex;&#125;//错误.sample&#123;    display: flex;&#125;</code></pre><p>(3)每条规则之间必须包含空行</p><pre class=" language-lang-css"><code class="language-lang-css">//正确.sample &#123;    display: flex;&#125;.sample1 &#123;    display: block;&#125;//错误.sample &#123;    display: flex;&#125;.sample1 &#123;    display: block;&#125;(4)属性名与冒号之间不允许包含空格， 冒号与属性值之间必须包含空格```css//正确display: flex;//错误display:flex;display : flex;display :flex;</code></pre><p>(5)逗号前不允许有空格，逗号后必须跟一个空格</p><pre><code>//正确font-family: Helvetica, Arial//错误font-family: Helvetica , Arialfont-family: Helvetica ,Arialfont-family: Helvetica, Arial</code></pre><p>(6)SCSS mixin的方法参数括号与 { 之间必须包含一个空格, 各参数间必须有一个空格</p><pre class=" language-lang-css"><code class="language-lang-css">//正确@mixin color-box($bg-color: $grey-light, $border-color: $grey) &#123;    background-color: $bg-color;    border: 1px solid $border-olor;&#125;//错误@mixin color-box($bg-color:$grey-light,$border-color:$grey) &#123;    background-color: $bg-color;    border: 1px solid $border-olor;&#125;</code></pre><p>(7) ‘+’ ‘~’ ‘&gt;’选择器前后必须跟一个空格</p><pre class=" language-lang-css"><code class="language-lang-css">//正确.radio-label + .radio-box &#123;&#125;//错误.radio-label+.radio-box &#123;&#125;</code></pre><p>(8)引用mixin和多层嵌套必须有一个空行</p><pre class=" language-lang-css"><code class="language-lang-css">//正确.sample &#123;    @include color-box;    margin: 15px;    &:hover &#123;      display: block;    &#125;&#125;//错误.sample &#123;    @include color-box;    margin: 15px;    &:hover &#123;      display: block;    &#125;&#125;</code></pre><p>(9)一组变量的定义，尽量以冒号对齐</p><pre class=" language-lang-css"><code class="language-lang-css">//推荐$link-hover-color        : #29e;$hover-color-gray        : #ebebeb;$icon-hover-color        : #4d4d4d;$btn-hover-color         : #f0f0f0;$btn-hover-color-form    : #f9f9f9;$btn-hover-color-cancel  : #f63737;//不推荐$link-hover-color : #29e;$hover-color-gray : #ebebeb;$icon-hover-color : #4d4d4d;$btn-hover-color : #f0f0f0;$btn-hover-color-form : #f9f9f9;$btn-hover-color-cancel : #f63737;</code></pre><p>(10)多个并行选择器使用同一规则，必须换行</p><pre class=" language-lang-css"><code class="language-lang-css">//正确.a,.b,.c &#123;    box-sizing: border-box;&#125;//错误.a, .b, .c &#123;    box-sizing: border-box;&#125;</code></pre><h2 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3 选择器"></a>3 选择器</h2><p>禁止使用ID应用于样式，应该使用class</p><pre class=" language-lang-css"><code class="language-lang-css">//正确.content &#123;    display: flex;&#125;//错误#content &#123;    display: flex;&#125;</code></pre><p>CSS选择器中避免标签名<br>选择器应该是准确和有语义的class(类)名，不推荐使用标签选择器。这样会更容易维护, 只需要修改你的标签名，而不是你的class<br>从分离的角度考虑,在表现层中不应该分配html标记/语义。</p><pre class=" language-lang-css"><code class="language-lang-css">//推荐.content &#123;    display: flex;    > .nav &#123;        flex: 1;    &#125;&#125;//不推荐.content &#123;    display: flex;    > nav &#123;        flex: 1    &#125;&#125;</code></pre><p>尽量精准的选择</p><pre class=" language-lang-css"><code class="language-lang-css">//推荐.content &#123;    display: flex;    > .nav &#123;        flex: 1;    &#125;&#125;//不推荐.content &#123;    display: flex;    .nav &#123;        flex: 1    &#125;&#125;</code></pre><p>选择器嵌套<br>正常的情况下，我们不推荐使用嵌套，如果需要使用嵌套，我们不推荐嵌套超过三层, 如果嵌套超过三层，应该考虑是不是哪里可以使用更精准更语义化的class。不推荐直接使用css的嵌套，而是使用SCSS的嵌套。</p><pre class=" language-lang-css"><code class="language-lang-css">//推荐.content &#123;    display: flex;    > .nav &#123;        flex: 1;        > .item &#123;            text-align: center;        &#125;    &#125;&#125;//不推荐.content .nav .item a &#123;    text-align: center;&#125;</code></pre><p>在CSS预处理器如LESS 和 SASS 里 media query 推荐直接在选择器的嵌套中使用，有助于保持媒体查询属于的上下文</p><pre class=" language-lang-css"><code class="language-lang-css">//推荐.content &#123;    font-size: 1.2rem;    @media screen and (min-width: 767px) &#123;        font-size: 1rem;    &#125;&#125;//不推荐.content &#123;    font-size: 1.2rem;&#125;@media screen and (min-width: 767px) &#123;    .content &#123;        font-size: 1rem;    &#125;&#125;</code></pre><p>属性选择器必须使用双引号</p><pre class=" language-lang-css"><code class="language-lang-css">//正确[class="icon-"] &#123;    font-size: 1rem;&#125;//错误[class='icon-'] &#123;    font-size: 1rem;&#125;</code></pre><h2 id="4-属性规范"><a href="#4-属性规范" class="headerlink" title="4 属性规范"></a>4 属性规范</h2><p>属性定义必须另起一行</p><pre class=" language-lang-css"><code class="language-lang-css">// 正确.selector &#123;    margin: 0;    padding: 0;&#125;// 错误.selector &#123; margin: 0; padding: 0; &#125;</code></pre><p>属性必须以分号结尾</p><pre class=" language-lang-css"><code class="language-lang-css">// 正确.selector &#123;    margin: 0;    padding: 0;&#125;// 错误.selector &#123;    margin: 0;    padding: 0&#125;</code></pre><p>属性值为0时，省略单位</p><pre class=" language-lang-css"><code class="language-lang-css">// 正确.box &#123;    padding: 0;&#125;// 错误.box &#123;    padding: 0px;&#125;</code></pre><p>使用16进制表示颜色，颜色值采用小写，#rrggbb的情况简写为#rgb，有透明度的情况使用rgba表示</p><pre class=" language-lang-css"><code class="language-lang-css">// 正确.box &#123;    background: rgba(0, 0, 255, .5);    color: #3ec;&#125;// 错误.box &#123;    background: white;    opacity: 0.5;    color: #33eecc;&#125;同一组属性尽量按照功能顺序书写，以 Formatting Model（布局方式、位置） > Box Model（尺寸） > Typographic（文本相关） > Visual（视觉效果） 的顺序书写，以提高代码的可读性Formatting Model 相关属性包括：display / position / top / right / bottom / left / float / overflow 等Box Model 相关属性包括：margin / border / padding / width / height 等Typographic 相关属性包括：font / line-height / text-align / word-wrap 等Visual 相关属性包括：background / color / transition / list-style 等```css// 推荐.sidebar &#123;    // formatting model    position: absolute;    top: 50px;    left: 0;    overflow-x: hidden;    // box model    width: 200px;    padding: 5px;    border: 1px solid #ddd;    // typographic    font-size: 14px;    line-height: 20px;    // visual    background: #f5f5f5;    color: #333;    transition: color 1s;&#125;</code></pre><p>font-family 属性</p><p>font-family 属性中的字体族名称应使用字体的英文 Family Name，其中如有空格，须放置在引号中。</p><pre class=" language-lang-css"><code class="language-lang-css">// 示例h1 &#123;    font-family: "Microsoft YaHei";&#125;</code></pre><p>font-family 不区分大小写，但在同一个项目中，同样的 Family Name 大小写必须统一。</p><pre class=" language-lang-css"><code class="language-lang-css">// 正确body &#123;    font-family: Arial, sans-serif;&#125;h1 &#123;    font-family: Arial, "Microsoft YaHei", sans-serif;&#125;// 错误body &#123;    font-family: arial, sans-serif;&#125;h1 &#123;    font-family: Arial, "Microsoft YaHei", sans-serif;&#125;</code></pre><p>font-family 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif )</p><pre class=" language-lang-css"><code class="language-lang-css">// 示例body &#123;    font-family: "Helvetica Neue", Helvetica, Arial, PingFangSC-Regular, "Microsoft Yahei", Verdana, sans-serif;&#125;</code></pre><p>不推荐在业务中重写font-family</p><p>url()中的路径不添加引号</p><pre class=" language-lang-css"><code class="language-lang-css">// 推荐.box &#123;    background-image: url(../imgs/banner.jpg);&#125;// 不推荐.box &#123;    background-image: url('../imgs/banner.jpg');&#125;</code></pre><p>推荐并适当缩写值<br>“适当”是因为缩写总是会包含一系列的值，而有时候我们并不希望设置某一值，反而造成了麻烦，那么这时候你可以不缩写，而是分开写。</p><p>// 有时我们只想设置一个容器水平居中，那么设置left，right就好，而top和bottom不是这个样式要关心的（如果设置了反倒会影响其他样式在这个容器上的使用）</p><pre class=" language-lang-css"><code class="language-lang-css">// 示例<div class="box center"></div>.box &#123;    margin-top: 10px;&#125;// 这种简写将会覆盖.box里的设置.center &#123;    margin: 0 auto;&#125;// 比如下面这个模块的样式设置，我们确实需要设置padding的所有项，于是我们就可以采用缩写.footer &#123;    padding: 12px 3px;&#125;</code></pre><p>对于属性值或颜色参数，省略小于 1 的小数前面的 0 （例如，.5 代替 0.5；-.5px 代替 -0.5px）</p><p>无边框设置</p><pre class=" language-lang-css"><code class="language-lang-css">// 正确.box &#123;    border: none;&#125;// 错误.box &#123;    border: 0; // 浏览器会进行多余的渲染，性能不佳&#125;</code></pre><p>层级(z-index)禁止随意设置，页面弹窗、气泡为最高级（最高级为999）；普通区块为10-90内10的倍数；同层的多个元素，在该层级内使用相同的 z-index 或递增。</p><p>禁止使用 !important (特殊情况除外，如覆盖第三方插件中的样式等)</p><p>禁止使用 filter</p><p>多个class里有一个或多个公共属性，应该将属性抽取到一个单独的class中或者使用泛选择器([attribute~=value], [attribute^=value],[attribute$=value],[attribute*=value])，泛选择器应确保不会有全局污染，避免多次书写重复代码</p><pre><code>    // 正确    &lt;div&gt;        &lt;span class=&quot;icon-book&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;icon-pen&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    [class^=&quot;icon-&quot;] &#123;        background-image: url(../imgs/sprite.png) no-repeat;    &#125;    .icon-book &#123;        background-positon: 0 -16px;    &#125;    .icon-pen &#123;        background-positon: -16px -16px;    &#125;    // 错误    &lt;div&gt;        &lt;span class=&quot;icon-book&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;icon-pen&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    .icon-book &#123;        background-image: url(../imgs/sprite.png) no-repeat;        background-positon: 0 -16px;    &#125;    .icon-pen &#123;        background-image: url(../imgs/sprite.png) no-repeat;        background-positon: -16px -16px;    &#125;</code></pre><h2 id="5-Hack规范"><a href="#5-Hack规范" class="headerlink" title="5 Hack规范"></a>5 Hack规范</h2><p>通常我们禁止在CSS的一个选择器中使用hack混编，如果你确实需要写hack, 我们应该有一个class： xxx-fix, 最好把所有的hack放在一个独立的文件, 通过JS特性检测或者直接添加到dom中。</p><pre class=" language-lang-css"><code class="language-lang-css">  // 错误  .selector &#123;      key: value;      key: fix-value\0; //ie 9-11  &#125;  // 正确  .selector &#123;      key: value;  &#125;  .selecor-ie-fix &#123;      key: fix-value\0; //ie 9-11  &#125;</code></pre><h2 id="6-命名规范"><a href="#6-命名规范" class="headerlink" title="6 命名规范"></a>6 命名规范</h2><h3 id="文件夹命名"><a href="#文件夹命名" class="headerlink" title="文件夹命名"></a>文件夹命名</h3><p>css文件夹命名应参照项目文件夹命名规则，命名总是以字母开头而不是数字，且字母一律小写，以中划线连接多个单词且不带其他标点符号。<br>如：input-number<br>有复数结构时，采取复数命名法。<br>如： style styles<br>|- components<br>|- input-number<br>|- inputNumber.html<br>|- inputNumber.js<br>|- styles<br>|- input_number.scss<br>|- images<br>|- menu</p><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>全站架构：(以下文件放在跟路径下的styles目录中)<br>基本共用 base.scss<br>布局、版面 layout.scss<br>主题 themes.scss<br>专栏 columns.scss<br>文字 font.scss<br>主要的 main.scss<br>表单 forms.scss<br>补丁 mend.scss<br>打印 print.scss<br>变量 variables.scss<br>功能函数 mixins.scss<br>色值 colors.scss<br>动画 animations.scss<br>字体 iconfont.scss<br>组件级 / 应用级：（放在组件/应用目录中）<br>css模块文件，其文件名必须与模块名一致。<br>css页面文件，其文件名必须与HTML文件名一致。<br>目的是让开发人员快速找到该页面或组件对应的css文件。<br>文件命名总是以字母开头而不是数字，且字母一律小写，以下划线连接且不带其他标点符号。<br>radio.scss<br>main-list.scss<br>main-detail.scss</p><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>命名变量的最佳方式就是使用抽象名词，尽量取消名字和值之间的直接关系。<br>使用’$’开头+ 语义化的变量名。<br>避免使用无意义的词，如: calendar<br>推荐变量的意义在前面，功能在后面</p><pre class=" language-lang-css"><code class="language-lang-css">// 不推荐$red: #F50707;$yellow: #B3F724;// 推荐$brand-color: #F50707;$accent-color: #B3F724;// 你可能会使用名称加-color的后缀来命名颜色的变量:// Base colors$base-color: #333;$brand-color: #F50707;$brand-80-color: rgba($color-brand, 0.8);$accent-color: #B3F724;// 或者使用header-或者footer-来命名一些特殊的区域：// Header$header-height: 100px;$header-background-color: $color-brand;// Footer$footer-height: 200px;$footer-background-color: #aaa;// 不推荐$z-index-modal$padding-body// 推荐$modal-z-index$body-padding</code></pre><h3 id="选择器命名"><a href="#选择器命名" class="headerlink" title="选择器命名"></a>选择器命名</h3><h4 id="推荐采用BEM方式命名"><a href="#推荐采用BEM方式命名" class="headerlink" title="推荐采用BEM方式命名"></a>推荐采用BEM方式命名</h4><pre><code>        // BE模式 block__element：块里的元素，如：nav（block）里的 a 标签(element)        &lt;nav class=&quot;g-nav&quot;&gt;            &lt;a href=&quot;#&quot; class=&quot;g-nav__item&quot;&gt;工作动态&lt;/a&gt;        &lt;/nav&gt;        .g-nav__item &amp;#123;        &amp;#125;</code></pre><pre><code>        // BM模式 block--modifier: 块元素加修饰符        // g-nav表示导航的通用样式，g-nav-top表示该导航特有的样式，g-nav--active示激活的nav        &lt;nav class=&quot;g-nav g-nav-top g-nav--active&quot;&gt;        &lt;/nav&gt;        .g-nav--active &amp;#123;        &amp;#125;</code></pre><pre><code>        // BEM模式 block__element--modifier nav块里的a元素加上active状态        &lt;nav class=&quot;g-nav&quot;&gt;            &lt;a href=&quot;#&quot; class=&quot;g-nav__item g-nav__item--active&quot;&gt;当前状态&lt;/a&gt;        &lt;/nav&gt;        .g-nav__item--active &amp;#123;        &amp;#125;</code></pre><p>BEM只允许出现B<strong>E—M,不允许出现B</strong>B<strong>B</strong>E—M   B<strong>E</strong>E<strong>E—M   B</strong>E—M—M—M<br>如果层级过多，可以使用以下方式：<br>B<strong>E—M &gt; B</strong>E—M &gt; B<strong>E—M(最多3层B</strong>E—M嵌套)</p><pre><code>    // 推荐    &lt;div class=&quot;c-card&quot;&gt;&lt;!-- B --&gt;        &lt;div class=&quot;c-card__header&quot;&gt;&lt;!-- B__E --&gt;            &lt;h2 class=&quot;c-card-title&quot;&gt;&lt;!-- B__E &gt; B --&gt;                &lt;i class=&quot;c-card-title__icon--small&quot;&gt;&lt;/i&gt;&lt;!-- B__E &gt; B__E--M --&gt;                &lt;i class=&quot;c-card-title__icon--big&quot;&gt;&lt;/i&gt;&lt;!-- B__E &gt; B__E--M --&gt;                &lt;span class=&quot;c-card-title__text-wrap&quot;&gt;Title text here&lt;/span&gt;&lt;!-- B__E &gt; B__E --&gt;            &lt;/h2&gt;        &lt;/div&gt;    &lt;/div&gt;    // 推荐    .c-card &#123;                      // B        &amp;__header &#123;                // B__E            &gt; .c-card-title &#123;      // B__E &gt; B                &amp;__icon--small &#123;   // B__E &gt; B__E--M                &#125;                &amp;__icon--big &#123;     // B__E &gt; B__E--M                &#125;                &amp;__text-wrap &#123;     // B__E &gt; B__E                &#125;            &#125;        &#125;    &#125;    // 不推荐    &lt;div class=&quot;c-card&quot;&gt;        &lt;div class=&quot;c-card__header&quot;&gt;            &lt;h2 class=&quot;c-card__header__title&quot;&gt;                &lt;i class=&quot;c-card__header__title__icon&quot;&gt;&lt;/i&gt;                &lt;span class=&quot;c-card__header__title__text&quot;&gt;Title text here&lt;/span&gt;            &lt;/h2&gt;        &lt;/div&gt;    &lt;/div&gt;    // 不推荐    .c-card &#123;        &amp;__header&#123;            &amp;__title &#123;                &amp;__icon &#123;                &#125;                &amp;__text &#123;                &#125;            &#125;        &#125;    &#125;</code></pre><ul><li>注意到以上示例中使用了c- 前缀。这个c代表’component’，给组件加上命名空间，它提高了代码的可读性。<br>类型 | 前缀 | 例子 | 描述<br>布局 | (g-) | g-header | (global)例如头部，尾部，主体，侧栏等<br>组件 | (c-) | c-card | (component)较大整体，如登录注册，搜索等<br>元件 | (u-) | u-btn | 不可再分个体，例如按钮，input框等<br>功能 | (f-) | f-clear | (function)使用频率较高样式，例如清除浮动<br>皮肤 | (s-) | s-nav | (skin) 只包含皮肤的样式<br>主线 | (ig-) | ig-header | (igoal)主线模块中组件Block的前缀<br>审批 | (ap-) | ap-header | (approve)审批模块中组件Block的前缀<br>…<br>命名时需要注意的点：<ul><li>规则命名中，一律采用小写加中划线的方式，不允许使用大写字母或_</li><li>命名避免使用中文拼音，应该采用更简明有语义的英文单词进行组合</li><li>命名注意缩写，但是不能盲目缩写</li><li>不允许通过1、2、3等序号进行命名</li><li>避免class与id重名</li><li>class用于标识某一个类型的对象，命名必须言简意赅</li><li>尽可能提高代码模块的复用，样式尽量用组合的方式</li><li>公共样式名不得包含业务名称</li></ul></li></ul><h3 id="mixins命名"><a href="#mixins命名" class="headerlink" title="mixins命名"></a>mixins命名</h3><p>见名知义<br>小写加中划线，不允许出现大小字母或_</p><pre class=" language-lang-css"><code class="language-lang-css">// 不推荐@mixin button($background: green) &#123;&#125;// 不推荐@mixin buttonBg($background: green) &#123;&#125;// 不推荐@mixin button_bg($background: green) &#123;&#125;// 推荐@mixin button-bg($background: green) &#123;&#125;</code></pre><p>多个参数之间用逗号分隔，给参数设置默认值</p><h2 id="7-重写规范"><a href="#7-重写规范" class="headerlink" title="7 重写规范"></a>7 重写规范</h2><p>我们不允许直接使用公共库的选择器进行重写，如果要进行重写，必须自己重新加一个新的选择器，并且，这个选择器不能对公共库有影响。</p><pre class=" language-lang-css"><code class="language-lang-css">  // 错误  .qf-xxx .qf-btn &#123;      //some rewriting code  &#125;  // 正确  .qf-xxx__qf-btn &#123;      //some rewriting code  &#125;</code></pre><p>使用的时候用qf-btn 和 qf-xxx__qf-btn两个class, 所以在写组件的时候，为了考虑组件的通用性和可重写性，建议组件开发人员，都提供一个外部的样式输入接口</p>]]></content>
      
      
      <categories>
          
          <category> CSS-SCSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS-SCSS代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-this</title>
      <link href="/posts/js-this.html"/>
      <url>/posts/js-this.html</url>
      
        <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this是js的关键字<br>他是根据执行上下文（执行环境）动态指向当前调用的对象；<br>谁调用，就指谁</p><p>一、全局作用域下：this始终指向window对象</p><p>二、函数作用域下：函数被谁调用，this就指向谁</p><p>三、对象中的函数作用域下：this指向该方法所属的对象</p><p>四、在构造函数中：this始终指向新对象</p><p>五、自执行函数中：this指向window</p><p>六、箭头函数中：this是在定义是绑定到了父级对象上，不是在执行过程中绑定的</p><p>注意：匿名函数的this就指向window，没有其他结果</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 1,全局this指windowconsole.log(this); // windowfunction foo() &#123;    console.dir(this);&#125;// 2，全局函数的this也指windowfoo(); // window// 3,事件处理函数this指事件触发对象document.body.onclick = foo; // body// 4,对象方法里的this 指对象本身var obj =  &#123;foo&#125;; // &#123;foo: foo&#125;obj.foo(); // obj// 4.1, 谁调用就指谁var obj1 = &#123;&#125;;obj1.foo = obj.foo;obj1.foo(); // obj1var obj2 = &#123;&#125;;//5,匿名函数的this指window(obj2.foo = obj1.foo)();  // window(obj2.foo)();function () &#123;    // this window    obj2.foo(); // obj2           &#125;</code></pre><h3 id="js改变this指向的3种方法-call-apply-bind"><a href="#js改变this指向的3种方法-call-apply-bind" class="headerlink" title="js改变this指向的3种方法: call apply bind"></a>js改变this指向的3种方法: call apply bind</h3><h4 id="call-thisObj-参数1，参数2-…"><a href="#call-thisObj-参数1，参数2-…" class="headerlink" title="call(thisObj, 参数1，参数2 …)"></a>call(thisObj, 参数1，参数2 …)</h4><p>方法可以指定this 的指向（即函数执行时所在的的作用域），然后再指定的作用域中，执行函数</p><p>方法的参数，应该是对象obj,如果参数为空或null,undefind,则默认传参全局对象</p><p>第一个参数是this指向的对象，第二个及后面的是函数回调所需的入参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var person = &#123;    name: 'zhangsan',    age: 20&#125;function say(x, y)&#123;    console.log(this.name)    console.log(this.age)    console.log(x, y)&#125;say.call(person, 1, 2) // zhangsan// 20// 1 2</code></pre><h4 id="apply-thisObj-参数1，参数2-…"><a href="#apply-thisObj-参数1，参数2-…" class="headerlink" title="apply(thisObj, [参数1，参数2 …])"></a>apply(thisObj, [参数1，参数2 …])</h4><p>第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。</p><p>第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。在apply方法中，必须以数组形式添加。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var person = &#123;    name: 'zhangsan',    age: 20&#125;function say(x, y)&#123;    console.log(this.name)    console.log(this.age)    console.log(x, y)&#125;say.apply(person, [1, 2])// zhangsan// 20// 1 2</code></pre><h4 id="bind-thisObj-参数1，参数2-…"><a href="#bind-thisObj-参数1，参数2-…" class="headerlink" title="bind(thisObj, 参数1，参数2 …)"></a>bind(thisObj, 参数1，参数2 …)</h4><p>bind 用于将函数体内的this绑定到某个对象，然后返回一个新函数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var person = &#123;    name: 'zhangsan',    age: 20&#125;function say(x, y)&#123;    console.log(this.name)    console.log(this.age)    console.log(x, y)&#125;say.bind(person, 1, 2)();// zhangsan// 20// 1 2</code></pre><h4 id="三种方法的比较"><a href="#三种方法的比较" class="headerlink" title="三种方法的比较"></a>三种方法的比较</h4><ol><li><p>call 、 apply 、bind 均能改变this 指向</p></li><li><p>bind 每次执行产生一个新函数，call、apply 不会</p></li><li><p>call ,bind 接收多个参数绑定到函数并且参数单一传入，apply 接收方式为数组</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
            <tag> call/apply/bind方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础-数组</title>
      <link href="/posts/js-array.html"/>
      <url>/posts/js-array.html</url>
      
        <content type="html"><![CDATA[<p>Array 对象<br>Array 对象用于在变量中存储多个值:</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var cars = ["Saab", "Volvo", "BMW"];</code></pre><p>第一个数组元素的索引值为 0，第二个索引值为 1，以此类推。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组：一组数据（一个变量来承载）<br>数组对象是一个有序的数据，数据可以是 [原始类型] 或 [对象类型]集合。相对于变量，数组可用于在一个变量中存储多个变量值。<br>数组中的每一项都有一个数字附于其上，被称为索引。在 JavaScript 中，数组索引从 0 开始，并可以使用多种 [方法]操作.。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> var str = "Hello world"; // 一个变量存放一个数据 var arr = [1,2,3,4,5,6,7,8,9]; arr[arr.length] = 20 //往数组结尾插入元素</code></pre><h3 id="数组有两种定义方式"><a href="#数组有两种定义方式" class="headerlink" title="数组有两种定义方式"></a>数组有两种定义方式</h3><p>因为js是弱类型语言，所以数组也是弱类型，同一个数组变量里可以有各种不同类型的元素</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> var arr = [];   //字面量的方式var arr = new Array();   //构造函数的方式var arr = new Array(10);//一个参数指数组长度为10var arr = new Array(10，20，30);//多个参数指定义数组元素</code></pre><p>数组的长度    arr.length<br>数组的索引（下标）从0开始    arr[0]  - arr[arr.length-1]</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript"> var arr = [9,2,35,5,74,12,43,4]; for(var i = 0; i < arr.length; i++)&#123;    console.log(arr[i]);&#125;for...in（ES5） 遍历稀疏数组的时候不会遍历到undefined var arr = [9,2,35,5,74,12,43,4]; for(var key in arr)&#123;    console.log(typeof key); //string    console.log(arr[key]);&#125;for...of（ES6）//直接取数组元素的值 var arr = [9,2,35,5,74,12,43,4]; for(var value of arr)&#123;    console.log(value);&#125;</code></pre><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>就是包含从0开始的不连续索引的数组。也就是说数组中大部分的内容值都未被使用（或都为零）。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//生成稀疏数组的方法var arr = new Array(3);   //数组没有元素，但是length是3console.log(arr);    // [empty × 3]//另一种生成稀疏数组的方法var arr = []arr[1000] = 1 //数组的长度为1001，但是实际的元素只有1个</code></pre><p>实际上，JavaScript并没有常规的数组，所有的数组其实就是个对象，只不过会自动管理一些”数字”属性和length属性罢了。</p><p>说的更直接一点，JavaScript中的数组根本没有索引，因为索引应该是数字，而JavaScript中数组的索引其实是字符串：arr[1]其实就是arr[“1”]，给arr[“1000”] = 1，arr.length也会自动变为1001。<br>这些表现的根本原因就是：JavaScript中的对象就是字符串到任意值的键值对。注意键只能是字符串。</p><h3 id="数组是引用类型"><a href="#数组是引用类型" class="headerlink" title="数组是引用类型"></a>数组是引用类型</h3><p>基本数据类型：number、string、boolean、undefined、null<br>引用数据类型：object（array也属于object）、function</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> var str = "Hello World"; var str2 = str;//内存开辟另外一段空间存放str2 var arr = [1,2,3,4,5,6,7,8,9]; var arr2 = arr;//arr和arr2指向同一段存储空间 var arr1 = [1,2,3]; var arr2 = arr1; arr1[arr1.length] = 4;console.log(arr1);console.log(arr2);//arr和arr2指向同一段存储空间</code></pre><h3 id="函数的值传递和引用传递"><a href="#函数的值传递和引用传递" class="headerlink" title="函数的值传递和引用传递"></a>函数的值传递和引用传递</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">function fn1(a)&#123;     a++; &#125; var num = 10; fn1(num); console.log(num); function fn2(arr)&#123;     arr[arr.length] = 20; &#125; var arr1 = [1,2,3]; fn2(arr1); console.log(arr1);</code></pre><p>数组API<br><a href="https://upload-images.jianshu.io/upload_images/15859737-d937a19e6edd7ed9.png?imageMogr2/auto-orient/strip|imageView2/2/w/829/format/webp">https://upload-images.jianshu.io/upload_images/15859737-d937a19e6edd7ed9.png?imageMogr2/auto-orient/strip|imageView2/2/w/829/format/webp</a></p><h3 id="数组常用API"><a href="#数组常用API" class="headerlink" title="数组常用API"></a>数组常用API</h3><p>（concat\join\reverse\slice\splice\toString\sort）</p><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>连接两个或更多的数组，并返回结果。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [1,2,3];var arr1 = [4,5,6];var arr3 = [7,8,9]var arr2 = arr.concat(arr1, arr3);console.log(arr2);</code></pre><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = arr.join("-");console.log(str);</code></pre><h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p>删除并返回数组的最后一个元素</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//操作的是数组本身var num = arr.pop();console.log(num);console.log(arr); //[1,2]</code></pre><h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p>向数组的末尾添加一个或更多元素，并返回新的长度。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var len = arr.push(4);console.log(len); // 3console.log(arr); //[1,2,4]</code></pre><h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p>删除并返回数组的第一个元素</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var fruits = ["Banana", "Orange", "Apple", "Mango"];fruits.shift()//Orange,Apple,Mango</code></pre><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p>向数组的开头添加一个或更多元素，并返回新的长度。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var fruits = ["Banana", "Orange", "Apple", "Mango"];fruits.unshift("Lemon","Pineapple");//Lemon,Pineapple,Banana,Orange,Apple,Mango</code></pre><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>颠倒数组中元素的顺序。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//修改的是数组本身arr.reverse();console.log(arr);</code></pre><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p>从某个已有的数组返回选定的元素</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//var arr5 = arr.slice(1, 2); //含头不含尾//var arr5 = arr.slice(-3,-1); //负值指倒数第几个var arr5 = arr.slice(-3); //一个参数代表截取到末尾console.log(arr5);</code></pre><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>对数组的元素进行排序<br>默认排序顺序为按字母升序.<br>注意：当数字是按字母顺序排列时”40”将排在”5”前面。<br>使用数字排序，你必须通过一个函数作为参数来调用。<br>函数指定数字是按照升序还是降序排列。<br>这种方法会改变原始数组！</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var fruits = ["Banana", "Orange", "Apple", "Mango"];fruits.sort();//Apple,Banana,Mango,Orange</code></pre><h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p>删除元素，并向数组添加新元素。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr6 = [2,3,45,6,7,8];//arr6.splice(1,1); //从下标为1开始,截取1个//arr6.splice(1,1,1);arr6.splice(1,0,1,3,4,5);console.log(arr6);</code></pre><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>把数组转换为字符串，并返回结果。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str1 = arr6.toString();console.log(str1);</code></pre><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。<br>注意： indexOf() 方法区分大小写。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="Hello world, welcome to the universe.";var n=str.indexOf("welcome");//13</code></pre><h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p>方法用于检测数组中的元素是否满足指定条件（函数提供）。<br>some() 方法会依次执行数组的每个元素：<br>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。<br>如果没有满足条件的元素，则返回false。<br>注意： some() 不会对空数组进行检测。<br>注意： some() 不会改变原始数组。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var ages = [3, 10, 18, 20];function checkAdult(age) &#123;    return age >= 18;&#125;function myFunction() &#123;    document.getElementById("demo").innerHTML = ages.some(checkAdult);&#125;//true</code></pre><h4 id="案例1："><a href="#案例1：" class="headerlink" title="案例1："></a>案例1：</h4><p>定义一个30项的数组， 按顺序分别赋予从2开始的偶数；<br>在每间隔 5个数 之后，求出前五个数的平均值；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var sum = 0;var arr = new Array(30);for(var i = 0; i < arr.length; i++)&#123;    arr[i] = (i+1) * 2;    //只要当前元素有值,那就可以累加    sum += arr[i];    //下标为4,9,14,19的时候应该计算平均值,并且重新从0开始加    if(i%5 === 4)&#123;        var avg = sum/5;        sum = 0;        console.log(avg);    &#125;&#125;</code></pre><h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2:"></a>案例2:</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = new Array(5); //行数for(var i = 0; i < arr.length; i++)&#123;    //每一趟循环代表一行    var subArr = new Array(5);    for(var j = 0; j < subArr.length; j++)&#123;        subArr[j] = 5*i+j+1;    &#125;    arr[i] = subArr;&#125;console.log(arr);//坐下半角 i >= j/* i   j   subArr[j]0  0-4   1-5        j+1+i*51  0-4   6-102  0-4   11-15 */var arr = [1,2,3,5,6,10];var num = 4;//把n跟数组每一个元素比较大小,直到找到比n大的数,那么就插入//for(var i in arr)&#123;//for(var i = 0; i < arr.length; i++)&#123;for(var i = 0, len = arr.length; i < len; i++)&#123;    if(num < arr[i])&#123;        //从i位置插入        arr.splice(i,0,num);        break;    &#125;&#125;console.log(arr);</code></pre><h3 id="es5新增API"><a href="#es5新增API" class="headerlink" title="es5新增API"></a>es5新增API</h3><h4 id="2个索引方法："><a href="#2个索引方法：" class="headerlink" title="2个索引方法："></a>2个索引方法：</h4><p>indexOf() 和 lastIndexOf()</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [3,5,42,1,33,1,43,5];console.log(arr);console.log(arr.indexOf(1)); //从左往右寻找（括号内是要查找的元素,最后输出该元素的索引）console.log(arr.lastIndexOf(1)); //从右往左寻找</code></pre><h4 id="5个迭代方法："><a href="#5个迭代方法：" class="headerlink" title="5个迭代方法："></a>5个迭代方法：</h4><p>forEach()、map()、filter()、some()、every()</p><h5 id="（1）forEach"><a href="#（1）forEach" class="headerlink" title="（1）forEach()"></a>（1）forEach()</h5><p>方法用于调用数组的每个元素，并将元素传递给回调函数。<br>注意: forEach() 对于空数组是不会执行回调函数的。</p><p>//语法：array.forEach(function(currentValue, index, arr), thisValue)<br>//currentValue必需。当前元素<br>//index 可选。当前元素的索引值。<br>//arr可选。当前元素所属的数组对象。<br>//thisValue 可选。传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [3,5,42,1,33,1,43,5];    console.log(arr);arr.forEach(function(item,index)&#123;    console.log(item, index);&#125;);</code></pre><h5 id="2-map"><a href="#2-map" class="headerlink" title="(2) map()"></a>(2) map()</h5><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。<br>map() 方法按照原始数组元素顺序依次处理元素。<br>注意： map() 不会对空数组进行检测。<br>注意： map() 不会改变原始数组。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//语法：array.map(function(currentValue,index,arr), thisValue)var arr = [3,5,42,1,33,1,43,5];console.log(arr);var arr2 = arr.map(function(item, index)&#123;    return item * 2;&#125;);console.log(arr2);</code></pre><h5 id="3-filter"><a href="#3-filter" class="headerlink" title="(3) filter()"></a>(3) filter()</h5><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br>注意： filter() 不会对空数组进行检测。<br>注意： filter() 不会改变原始数组。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//语法：array.filter(function(currentValue,index,arr), thisValue)var arr = [3,5,42,1,33,1,43,5];console.log(arr);var arr2 = arr.filter(function(item, index)&#123;      return item < 10;  &#125;)  console.log(arr2);</code></pre><h5 id="4-some"><a href="#4-some" class="headerlink" title="(4) some()"></a>(4) some()</h5><p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。<br>some() 方法会依次执行数组的每个元素：<br>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。<br>如果没有满足条件的元素，则返回false。<br>注意： some() 不会对空数组进行检测。<br>注意： some() 不会改变原始数组。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//语法：array.some(function(currentValue,index,arr),thisValue)var arr = [3,5,42,1,33,1,43,5];console.log(arr);var isBig = arr.some(function(item, index)&#123;    return index>10;&#125;);console.log(isBig);</code></pre><h5 id="5-every"><a href="#5-every" class="headerlink" title="(5) every()"></a>(5) every()</h5><p>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。<br>every() 方法使用指定函数检测数组中的所有元素：<br>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。<br>如果所有元素都满足条件，则返回 true。<br>注意： every() 不会对空数组进行检测。<br>注意： every() 不会改变原始数组。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//语法：array.every(function(currentValue,index,arr), thisValue)var arr = [3,5,42,1,33,1,43,5];            console.log(arr);var isBig = arr.every(function(item, index)&#123;                return index<10;            &#125;)            console.log(isBig);</code></pre><h4 id="2个归并方法："><a href="#2个归并方法：" class="headerlink" title="2个归并方法："></a>2个归并方法：</h4><p>reduce()、reduceRight()</p><h5 id="（1）reduce"><a href="#（1）reduce" class="headerlink" title="（1）reduce()"></a>（1）reduce()</h5><p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br>reduce() 可以作为一个高阶函数，用于函数的 compose。<br>注意: reduce() 对于空数组是不会执行回调函数的。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//语法：array.reduce(function(total（必需。初始值, 或者计算结束后的返回值) //currentValue（必需。当前元素）, currentIndex, arr), initialValue)//归并var arr = [3,5,42,1,33,1,43,5];console.log(arr);//上一次迭代返回的结果作为下一次的prevvar sum = arr.reduce(function(prev, next)&#123;    return prev+next;&#125;,0);console.log(sum);</code></pre><h5 id="2-reduceRight"><a href="#2-reduceRight" class="headerlink" title="(2) reduceRight()"></a>(2) reduceRight()</h5><p>reduceRight方法的功能和 reduce功能是一样的，不同的是 reduceRight从数组的末尾向前将数组中的数组项做累加。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//二元数组归并为一元数组var arr = [    [1,2,3],    [4,5,6],    [7,8,9]]var arr1 = arr.reduceRight(function(prev, next)&#123;    return prev.concat(next.reverse());&#125;,[]);console.log(arr1);</code></pre><h3 id="数组去重的三种方法"><a href="#数组去重的三种方法" class="headerlink" title="数组去重的三种方法"></a>数组去重的三种方法</h3><p>方法1：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [2,3,4,2,2,2,2,3,4,2,5,6,8];console.log(arr);//i  起点值0,终点值length-2for(var i = 0; i < arr.length-1; i++)&#123;    //j  起始值i+1，终点值  length-1    for(var j = i+1; j < arr.length; j++)&#123;        if(arr[i] === arr[j])&#123;            //当删除一个值之后,后面的值得索引会全部减一            //所以需要j--抵消for循环的j++            arr.splice(j--, 1);            //j--;        &#125;    &#125;&#125;console.log(arr);</code></pre><p>方法2：利用对象</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//利用对象的属性名不能重复的特点var arr = [2,3,4,2,2,2,2,3,4,2,5,6,8];console.log(arr);var obj = &#123;&#125;;for(var i = 0; i < arr.length; i++)&#123;    //判断obj里面有没有arr[i]这个属性    if(!obj[arr[i]])&#123;        //obj[arr[i]]不存在,第一次遍历到arr[i]        //赋值        obj[arr[i]] = 1;    &#125;else&#123;        //obj[arr[i]]已经存在了,arr[i]曾经被遍历到过        arr.splice(i--, 1);    &#125;&#125;console.log(arr);</code></pre><p>方法3：ES6</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [2,3,4,2,2,2,2,3,4,2,5,6,8];console.log(arr);//Set默认就不允许重复var arr2 = Array.from(new Set(arr));console.log(arr2);</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 稀疏数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-设计模式</title>
      <link href="/posts/design-patterns.html"/>
      <url>/posts/design-patterns.html</url>
      
        <content type="html"><![CDATA[<p>设计模式：代码经验的总结<br>设计模式都是面向对象的</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂函数就是做一个对象创建的封装，并将创建的对象return出去</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function newObj(name,age)&#123;    var o = new Object();    o.name = name;    o.age = age;    return o;&#125;var obj = newObj();</code></pre><h3 id="单例模式：只允许存在一个实例的模式"><a href="#单例模式：只允许存在一个实例的模式" class="headerlink" title="单例模式：只允许存在一个实例的模式"></a>单例模式：只允许存在一个实例的模式</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var Instance = (function()&#123;    var obj;    return function()&#123;        if(obj === undefined) obj = new Date();        return obj;    &#125;&#125;)();var ibs = Instance();</code></pre><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>又称发布订阅者模式，经典案例：事件监听，一个元素同时监听多个同类型事件，元素对象即为发布者，每一个事件处理函数即为订阅者。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换，从而避免很多if语句，曾经学过最简单的策略模式雏形就是使用数组的方式解决传入数字得到对应星期几问题的算法。</p><p>比如公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> var obj = &#123;    "A": function(salary) &#123;        return salary * 4;    &#125;,    "B" : function(salary) &#123;        return salary * 3;    &#125;,    "C" : function(salary) &#123;        return salary * 2;    &#125;&#125;;var calculateBouns =function(level,salary) &#123;    return obj[level](salary);&#125;;console.log(calculateBouns('A',10000)); // 40000</code></pre><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问，为了不暴露执行对象的部分代码</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> //三个对象//用户委托快捷方式打开exe//为了不暴露执行对象的部分代码//男孩委托快递小哥给女孩送礼物var girl = function(name)&#123;    this.name = name;&#125;//隐藏复杂，不愿意修改的的方法var boy = function(girl)&#123;    this.girl = girl;    this.send = function(gift)&#123;        alert("你好："+this.girl.name+",给你一个"+gift);    &#125;&#125;var proxyBro = function(girl)&#123;    this.send = function(gift)&#123;        new boy(girl).send(gift);    &#125;&#125;var pro = new proxyBro(new girl("Lisa"));pro.send("么么哒");pro.send("玫瑰花");</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂模式 </tag>
            
            <tag> 代理模式（proxy） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>express应用程序生成器</title>
      <link href="/posts/express.html"/>
      <url>/posts/express.html</url>
      
        <content type="html"><![CDATA[<h3 id="express-应用程序生成器"><a href="#express-应用程序生成器" class="headerlink" title="express 应用程序生成器"></a>express 应用程序生成器</h3><p>安装：$ npm install express-generator -g</p><p>npm list -g —depth=0 查看全局安装的插件</p><p>npx 临时使用的命令，临时安装插件时使用，用完之后删除</p><p>npx express-generator backend -e 添加对 ejs 模板引擎的支持,会生成以下文件：<br><a href="https://upload-images.jianshu.io/upload_images/15859737-a6e8e7a41460b756.png?imageMogr2/auto-orient/strip|imageView2/2/w/204/format/webp">https://upload-images.jianshu.io/upload_images/15859737-a6e8e7a41460b756.png?imageMogr2/auto-orient/strip|imageView2/2/w/204/format/webp</a></p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//创建HTTP错误请求var createError = require('http-errors');//expressvar express = require('express');//原生模块pathvar path = require('path');//express的cookie处理的中间键(middleware)var cookieParser = require('cookie-parser');//日志中间键var logger = require('morgan');//引用首页的路由var indexRouter = require('./routes/index');//引用users的路由var usersRouter = require('./routes/users');var app = express();// view engine setup 设置view渲染引擎为ejsapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');//app.use是express实例上的方法，表示应用中间键app.use(logger('dev'));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, 'public')));//把路由也当初中间键来挂载app.use('/', indexRouter);app.use('/users', usersRouter);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123;  next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123;  // set locals, only providing error in development  res.locals.message = err.message;  res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;;  // render the error page  res.status(err.status || 500);  res.render('error');&#125;);module.exports = app;</code></pre>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> express应用程序生成器 </tag>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp</title>
      <link href="/posts/gulp.html"/>
      <url>/posts/gulp.html</url>
      
        <content type="html"><![CDATA[<h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2><p>gulp是基于Nodejs的自动任务运行器<br>能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤</p><h3 id="使用流程："><a href="#使用流程：" class="headerlink" title="使用流程："></a>使用流程：</h3><p>安装nodejs -&gt; 全局安装gulp -&gt; 项目安装gulp以及gulp插件 -&gt; 配置gulpfile.js -&gt; 运行任务</p><h3 id="1-安装-nodejs"><a href="#1-安装-nodejs" class="headerlink" title="1.安装 nodejs"></a>1.安装 nodejs</h3><p>node -v<br>npm -v<br>npm install <package-name> -g （—save-dev）<br>-g 全局安装<br>—save 局部安装并保存到package.json配置中<br>-dev 存在package.json的devDependencies配置项里，意思是生产环境依赖的模块</package-name></p><p>npm install -g cnpm —registry=<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a><br>可以使用 cnpm 替代 npm 来安装资源</p><h3 id="2-全局安装-gulp"><a href="#2-全局安装-gulp" class="headerlink" title="2.全局安装 gulp"></a>2.全局安装 gulp</h3><p>npm install gulp@3 -g<br>或：<br>cnpm install gulp@3 -g</p><p>测试：gulp -v</p><h3 id="3-在项目目录下生成-package-json-文件："><a href="#3-在项目目录下生成-package-json-文件：" class="headerlink" title="3.在项目目录下生成 package.json 文件："></a>3.在项目目录下生成 package.json 文件：</h3><p>npm init<br>或<br>cnpm init</p><h3 id="4-在项目目录中本地安装-gulp："><a href="#4-在项目目录中本地安装-gulp：" class="headerlink" title="4.在项目目录中本地安装 gulp："></a>4.在项目目录中本地安装 gulp：</h3><p>npm install gulp —save-dev<br>本地安装成功后，会生成 node_modules 文件夹</p><h3 id="5-在项目目录中本地安装-gulp-插件https-www-npmjs-com"><a href="#5-在项目目录中本地安装-gulp-插件https-www-npmjs-com" class="headerlink" title="5.在项目目录中本地安装 gulp 插件https://www.npmjs.com"></a>5.在项目目录中本地安装 gulp 插件<a href="https://www.npmjs.com">https://www.npmjs.com</a></h3><p>（1）压缩CSS：gulp-minify-css<br>npm install gulp-minify-css —save-dev</p><p>（2）压缩JS：gulp-uglify<br>npm install —save-dev gulp-uglify</p><p>（3）压缩Html：gulp-htmlmin<br>npm install —save-dev gulp-htmlmin</p><p>（4）将ES6转换为ES5：gulp-babel<br>npm install —save-dev gulp-babel @babel/core @babel/preset-env</p><h4 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h4><p>npm install —save-dev gulp-concat</p><h4 id="gulpfile-js中修改js任务"><a href="#gulpfile-js中修改js任务" class="headerlink" title="gulpfile.js中修改js任务"></a>gulpfile.js中修改js任务</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript">var concat = require("gulp-concat");gulp.task("js", function()&#123;    gulp.src("src/js/**/*.js") .pipe(babel(&#123;   presets: ['@babel/env'] &#125;))    .pipe(concat('all.js'))    .pipe(uglify())    .pipe(gulp.dest("dist/js"))    .pipe(connect.reload());&#125;);</code></pre><h4 id="服务器：gulp-connect"><a href="#服务器：gulp-connect" class="headerlink" title="服务器：gulp-connect"></a>服务器：gulp-connect</h4><p>npm install —save-dev gulp-connect</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var connect = require('gulp-connect');gulp.task('server', function() &#123;    connect.server(&#123;        livereload: true,        port: 2333    &#125;);&#125;);</code></pre><h4 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript">gulp.task("img", function()&#123;    gulp.src('src/images/**/*')    .pipe(gulp.dest('dist/images'))&#125;)gulp.task("default", ["sass", "html", "minijs", "connect", "watch", "img"]);</code></pre><h4 id="sass转css-gulp-sass"><a href="#sass转css-gulp-sass" class="headerlink" title="sass转css gulp-sass"></a>sass转css gulp-sass</h4><p>npm install —save-dev gulp-sass</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var sass = require('gulp-sass');gulp.task('sass', function()&#123;    gulp.src('src/css/*.scss')    .pipe(sass())    .pipe(gulp.dest('dist/css'))&#125;);</code></pre><h4 id="watch：监听文件的的变化执行对应的任务"><a href="#watch：监听文件的的变化执行对应的任务" class="headerlink" title="watch：监听文件的的变化执行对应的任务"></a>watch：监听文件的的变化执行对应的任务</h4><p>给每一个任务加上pipe(connect.reload())</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">gulp.task('watch',function()&#123;    gulp.watch('./src/css/*.scss',['sass']);    gulp.watch('./src/*.html',['html']);    gulp.watch('./src/css/*.css',['css']);    gulp.watch('./src/js/*.js',['js']);&#125;)gulp.task("default", ["sass", "html", "js", "connect", "watch"]);</code></pre><h4 id="gulpfile-js"><a href="#gulpfile-js" class="headerlink" title="gulpfile.js"></a>gulpfile.js</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript">const gulp = require('gulp');const minifyCss = require('gulp-minify-css');const uglify = require('gulp-uglify');const babel = require('gulp-babel');const htmlmin = require('gulp-htmlmin');gulp.task('default', function() &#123;    // 将你的默认的任务代码放在这    console.log('gulp启动成功');&#125;);gulp.task("hello", function()&#123;    console.log("hello gulp");&#125;);gulp.task("html", function()&#123;    gulp.src("src/index.html")      .pipe(htmlmin(&#123;        removeComments: true,//清除HTML注释        collapseWhitespace: true,//压缩HTML        collapseBooleanAttributes: true,//省略布尔属性的值 input标签的 checked="true"        removeEmptyAttributes: true,//删除所有空格作属性值 input 标签        removeScriptTypeAttributes: true,//删除script标签的type="textjavascript"        removeStyleLinkTypeAttributes: true,//删除style标签和link标签的type="text/css"        minifyJS: true,//压缩页面JS        minifyCSS: true//压缩页面CSS       &#125;)    )    .pipe(gulp.dest("dist"))&#125;);gulp.task("css", function()&#123;  gulp.src("src/css/*.css")      .pipe(minifyCss())      .pipe(gulp.dest("dist/css"));&#125;);gulp.task("js", function()&#123;  gulp.src("src/js/*.js")  .pipe(uglify())  .pipe(gulp.dest("dist/js"));&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/posts/git.html"/>
      <url>/posts/git.html</url>
      
        <content type="html"><![CDATA[<p>写在前面的话：史上最浅显易懂的Git教程！推荐廖雪峰的教程！<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p><h3 id="Git是什么？"><a href="#Git是什么？" class="headerlink" title="Git是什么？"></a>Git是什么？</h3><p>Git是目前世界上最先进的分布式版本控制系统。</p><h3 id="SVN与Git的最主要的区别"><a href="#SVN与Git的最主要的区别" class="headerlink" title="SVN与Git的最主要的区别?"></a>SVN与Git的最主要的区别?</h3><p>SVN的存储需要依赖一个服务器，而git所有的东西是放在线上的。节约成本，省时省力</p><h3 id="Git命令："><a href="#Git命令：" class="headerlink" title="Git命令："></a>Git命令：</h3><p>命令 1 . git config —global user.name “你的git名称”</p><p>命令2. git config —global user.email “你的git验证邮箱”</p><p>命令 1 . cd D: 进入 相应的磁盘</p><p>命令 2 . mkdir ‘你自己定义的文件夹名’</p><p>命令 3 . cd ‘你自己定义的文件夹名’</p><p>命令 4. pwd 显示（你自己定义的文件夹名）的路径</p><p>git init 初始化<br>git add ‘文件名’<br>git commit -m ‘我提交时候的备注（相当于注释）’<br>git status 查看commit状态<br>git remote add origin https: // github.com/你的账号/你的项目名称<br>git push -u origin master 将本地的库推送到master<br>git push origin —all push本地所有分支代码<br>分支 （就是推送到服务器上）<br>git pull 拉取远程版本库代码<br>git clone 将服务器端的数据克隆过来</p><p>git log （ 修改日志）</p><p>git reset —hard HEAD^ 退回到上个版本 如果需要退回好多版本就在后面加上 ^ 例： git reset —hard HEAD^^退回两个版本。</p><p>git reflog 查看操作记录</p><p>rm b.txt 这个是删除b文件的命令</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支( branches ) 是指在开发主线中分离出来，做进一步开发而不影响到原来主线。</p><p>git init 命令运行时默认创建一个分支，并命名为 master</p><p>git branch<br>— 查看所有分支</p><p>git branch <branch-name><br>— 创建分支</branch-name></p><p>git checkout <branch-name><br>— 切换分支</branch-name></p><p>git merge <branch-name><br>— 合并分支</branch-name></p><p>git branch -d <branch-name><br>— 删除分支</branch-name></p><p>如果输入$ git remote add origin git@github.com:djqiang（github帐号名）/gitdemo（项目名）.git 提示出错信息：fatal: remote origin already exists.</p><p>解决办法如下：</p><p>1、先输入$ git remote rm origin</p><p>2、再输入$ git remote add origin git@github.com:djqiang/gitdemo.git 就不会报错了！</p><p>3、如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’. 我们需要修改gitconfig文件的内容</p><p>4、找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc</p><p>5、找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS基本介绍</title>
      <link href="/posts/nodejs.html"/>
      <url>/posts/nodejs.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、NodeJS基本介绍"><a href="#一、NodeJS基本介绍" class="headerlink" title="一、NodeJS基本介绍"></a>一、NodeJS基本介绍</h3><p> 1、NodeJS是为了开发高性能的服务器而诞生的一种技术</p><p> 2、是运行在服务端的 JavaScript，基于V8引擎（谷歌浏览器的版本）进行运行 </p><p> 3、使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效</p><p>node官网 <a href="https://nodejs.org">https://nodejs.org</a><br>node中文网 <a href="http://nodejs.cn">http://nodejs.cn</a><br>Node.js 的包管理器 npm，是全球最大的开源库生态系统<br><em>注意：NodeJS不是语言，是运行环境！！</em></p><h4 id="引擎-engine是什么？"><a href="#引擎-engine是什么？" class="headerlink" title="引擎 engine是什么？"></a>引擎 engine是什么？</h4><ul><li>Node是一个基于 <strong>Chrome V8</strong> 引擎的 JavaScript <strong>运行环境</strong>（服务器端的浏览器）</li><li>内核里有引擎：渲染引擎（渲染dom结构）、脚本引擎（运行脚本语言）<br>脚本引擎最流行的就是chrome V8引擎，快、高效<br>| <strong>内核</strong> | <strong>浏览器</strong>          | Cool     | company      |<br>| ———— | —————————- | ———— | —————— |<br>| trident  | IE                  | -ms-     | microsoft    |<br>| webkit   | safari、chrome(l)   | -webkit- | apple/google |<br>| blink    | chrome(h)、opera(h) |          | google       |<br>| presto   | opera(l)            | -o-      | opera        |<br>| gecko    | firefox             | -mz-     | mozilla      |</li></ul><h3 id="二、前端学习node的意义"><a href="#二、前端学习node的意义" class="headerlink" title="二、前端学习node的意义"></a>二、前端学习node的意义</h3><p> 1、 开发沟通：开发时更容易理解后端实现，降低交流成本<br> 2、 后端开发：想写些自己感兴趣的项目时，可以自己独立完成，即使没有后端支持，且成本特别低。<br> 3、 中间层开发：为了进一步的前后端分离，提高性能，使用nodejs做中间层是一个非常好的实践（由于nodejs具有异步io的特点）</p><h3 id="三、使用node的方式"><a href="#三、使用node的方式" class="headerlink" title="三、使用node的方式"></a>三、使用node的方式</h3><p> 1、 在node交互模式下运行（类似于命令窗口），这种方式类似于浏览器控制台，一般是用于运行单独的代码段。<br> 2、 单独创建一个node文件，其实就是一个不包含bom与dom的js文件，然后使用node 文件名.js来运行，当然你也可以不给js后缀，这种方式一般是用于运行一个独 立的nodejs文件</p><h3 id="四、前端要掌握的nodejs核心内容"><a href="#四、前端要掌握的nodejs核心内容" class="headerlink" title="四、前端要掌握的nodejs核心内容"></a>四、前端要掌握的nodejs核心内容</h3><p> 1、file模块 +  http模块</p><p> 2、File+http模块 构建静态的webserver</p><p> 3、使用nodejs的web框架express构建主流的ApiServer</p><h3 id="五、file模块"><a href="#五、file模块" class="headerlink" title="五、file模块"></a>五、file模块</h3><p>1、创建文件夹—fs.mkdir(path[, options], callback)　</p><p>　　path - 要创建的文件夹路径</p><p>　　options 参数可以是：</p><p>　　　　recursive - 是否以递归的方式创建目录，默认为 false。</p><p>　　　　mode - 设置目录权限，默认为 0777。</p><p>　　callback - 文件夹创建完成后的回调函数，创建成功是没有参数的，如果创建失败会有个错误对象作为参数</p><p>2、读取文件夹—fs.readdir(path, callback)</p><p>3、 删除空文件夹—fs.rmdir(path, callback)</p><p>4、写入(创建)文件—-fs.writeFile(filename,data,callback)</p><p>　　filename:写入文件名</p><p>　　data:写入文件的数据(String|Buffer)</p><p>　　callback(err):错误信息参数</p><p>5、读取文件内容—fs.readFile(filename,callback)</p><p>6、向文件中追加内容—fs.appendFile(filename,data,callback)</p><p>7、删除文件—fs.unlink(path,callback)</p><h3 id="六、HTTP模块构建流程"><a href="#六、HTTP模块构建流程" class="headerlink" title="六、HTTP模块构建流程"></a>六、HTTP模块构建流程</h3><p> 1、导入http模块      var http = require(‘http’)<br> 2、使用http模块创建一个服务器  http.creatServer(fn).listen(端口号)<br> 3、给服务器添加请求处理函数fn—&gt;绑定端口 </p><p>可以参考：Node.js到底是做什么的？这是我看到最好的解释了。<a href="https://www.cnblogs.com/suhaihong/p/6598308.html">https://www.cnblogs.com/suhaihong/p/6598308.html</a></p>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS基本介绍 </tag>
            
            <tag> file模块 </tag>
            
            <tag> http模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS正则表达式</title>
      <link href="/posts/regular-expression.html"/>
      <url>/posts/regular-expression.html</url>
      
        <content type="html"><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>（英语：Regular Expression，在代码中常简写为regex、regexp或RE）<br>语法<br>/正则表达式主体/修饰符(可选)</p><h4 id="正则的第一种写法"><a href="#正则的第一种写法" class="headerlink" title="正则的第一种写法"></a>正则的第一种写法</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript">var reg=new RegExp('a');var str='abcdefg';alert(reg.test(str));   //返回bool值，代表是否匹配成功</code></pre><h4 id="正则表达式的第二种写法"><a href="#正则表达式的第二种写法" class="headerlink" title="正则表达式的第二种写法"></a>正则表达式的第二种写法</h4><p>perl风格 古老的语言</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var re = /a/var str='abcdefg';re.test(str);</code></pre><h3 id="中括号：匹配其中的某一个字符"><a href="#中括号：匹配其中的某一个字符" class="headerlink" title="[ ] 中括号：匹配其中的某一个字符"></a>[ ] 中括号：匹配其中的某一个字符</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = prompt();var reg = /[abcde]/;//匹配是否有abcde中的字符console.log(reg.test(str));</code></pre><p>[ a-z ] 匹配所有小写字母<br>[0-9] == \d 匹配任意一个数字( )</p><p>小括号：分组：小括号里面的内容作为整体进行匹配<br>小括号用于分组，竖线作为间隔代表“或者”的含义<br>/(ab) | (cd)/ 匹配’ab’ 或者 ‘cd’<br>/(a|b)cd/ 匹配 ‘acd’ 或者 ‘bcd’<br>注意：小括号、竖线不要放在 [ ] 内（无意义）</p><p>| : 或，跟js中的（||）一样<br>^：排除（除了） 类似js中的（！）<br>^ (不在中括号里)匹配字符串开头<br>$ 匹配结尾</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var reg = /^[a-z]$/;//小写字母 开头并且小写字母结尾,中间不能有字符(完整匹配)/^$/这样的正则代表完整匹配</code></pre><h3 id="转义字符：元字符"><a href="#转义字符：元字符" class="headerlink" title="转义字符：元字符"></a>转义字符：元字符</h3><p>\d —— [0-9] 数字<br>\w ——-[a-z0-9_A-Z] 数字，字母，下划线<br>\s —- 空白字符</p><p>\D ——-<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup> 非数字<br>\W ——-<sup><a href="#fn_a-z0-9_" id="reffn_a-z0-9_">a-z0-9_</a></sup> 非数字，字母，下划线<br>\ S ——-非空白字符</p><p>. ——-全部字符<br>b ——-匹配单词边界<br>\B ——-匹配 非 单词边界<br>\0(数字0) ——-匹配 NUL 字符<br>\n ——-匹配 换行符<br>\f ——-匹配 换页符<br>\r ——-匹配 回车符<br>\t ——-匹配 制表符<br>\v ——-匹配 垂直制表符<br>\u4e00 - \u9fa5 验证中文</p><h3 id="量词：（单位名称）"><a href="#量词：（单位名称）" class="headerlink" title="量词：（单位名称）"></a>量词：（单位名称）</h3><p>{n} —-匹配n次</p><p>{n,m} —-最少n次，最多m次；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">QQ号验证  /^[1-9]\d&#123;4,10&#125;$/</code></pre><p>{n,} —-最少n次，最多不限</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">+  == &#123;1,&#125;最少为一个</code></pre><p>? {0,1} 可有可无，最多一个</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">*  &#123;0,&#125; 可以有也可以没有，个数不限</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">/(ab|cd)&#123;2&#125;/ 匹配字符串"ab" 或者 "cd" 的2次，或者abcd 结果为:abab cdcd abcd cdab</code></pre><h3 id="匹配大小写不一样的字母怎么办？"><a href="#匹配大小写不一样的字母怎么办？" class="headerlink" title="匹配大小写不一样的字母怎么办？"></a>匹配大小写不一样的字母怎么办？</h3><p>var re=new RegExp(‘a’,’i’)<br>正则对象中有一个参数，可以传入对应的值，i 代表让正则不区分大小写；<br>i：忽略大小写<br>var re= /a/i</p><p>g：全局查找<br>reg = /\d+/ g<br>g: 代表全局所有 （global）</p><p>m： 多行查找（必须与g一起实用,并且,当使用^和$模式时才会起作用）</p><h3 id="正则对象的方法："><a href="#正则对象的方法：" class="headerlink" title="正则对象的方法："></a>正则对象的方法：</h3><h4 id="1-test方法"><a href="#1-test方法" class="headerlink" title="1.test方法"></a>1.test方法</h4><p>该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false</p><h4 id="2-compile方法"><a href="#2-compile方法" class="headerlink" title="2.compile方法"></a>2.compile方法</h4><p>该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var reg=/[abc]/gi;console.log(reg.test('a'));reg=/[cde]/gi;console.log(reg.test('a'));reg.compile(reg);console.log(reg.test('a'));</code></pre><h4 id="3-exec方法"><a href="#3-exec方法" class="headerlink" title="3.exec方法"></a>3.exec方法</h4><p>返回的是一个数组，数组元素为匹配的子字符串</p><h3 id="支持正则的字符串方法"><a href="#支持正则的字符串方法" class="headerlink" title="支持正则的字符串方法"></a>支持正则的字符串方法</h3><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>查找第一次匹配的子字符串的位置，如果找到就返回一个number类型的index值，否则返回-1</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>该方法用来将字符串中的某些子串替换为需要的内容，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串</p><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>将一个字符串拆分成一个数组，它接受一个正则或者子字符（串）作为参数，返回一个数组</p><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><p>接受一个正则作为参数，用来匹配一个字符串，返回一个数组</p><p>例子：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">    var reg = new RegExp("b");//写法1    var str = prompt();    var reg = /b/;// 写法2  匹配是否存在b    var reg = /[abcde]/;//匹配是否有abcde中的字符    var reg = /[a-z]/;//匹配所有小写字母    var reg = /(ab)|(cd)/;//ab  或 cd    var reg = /(a|b)cd/;//acd  或bcd    var reg = /[^a-z]/;//不能有小写字母    var reg = /^[a-z]/;//小写字母开头    var reg = /^[a-z]$/;//小写字母 开头并且小写字母结尾,中间不能有字符(完整匹配)    var reg = /\d/;//匹配0-9的数字[0-9];    var reg = /./;//匹配所有字符    var reg = /\./;//转义字符z    var reg = /\d&#123;6&#125;/;//6个数字（超过也为true）    var reg = /a\d&#123;6,8&#125;a/;//六到8个数字,前后做好限定,否则会自动过滤掉多余的数字    var reg = /^[1-9]\d&#123;4,10&#125;$/;//5-11位,完整匹配    var reg = /\w/;//-[a-z0-9_A-Z]     数字，字母，下划线    var reg = /\s/;//空格    var reg = /\D/;//不为数字    var reg = /^\d+.&#123;3,&#125;$/;// 必须以数字开头,数量一个以上,紧接着任意字符至少三个,并以之结尾    var reg = /^\d?$/;//以数字开头 一个数字或者没有  &#123;0,1&#125; 可有可无，最多一个    var reg = /^\d*$/;//&#123;0,&#125; 可以有也可以没有，个数不限    var reg = /zhangsan/i;//i：忽略大小写    var reg = /\d+/g;//g: 代表全局所有  （global）    console.log(reg.test(str));</code></pre><h3 id="案例-密码强度"><a href="#案例-密码强度" class="headerlink" title="案例:密码强度"></a>案例:密码强度</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">            // html代码如下            // input type="text" id="pwd"     input标签            // button 登录 button             button标签            //js代码如下            var input = document.querySelector("#pwd");            var numReg = /\d+/;            //var letterReg = /^[a-zA-Z]$/;            var letterReg = /[a-z]+/i;            var charReg = /[^0-9a-z]+/i;            //存储三个正则的验证结果            document.querySelector("button").onclick = function()&#123;                var arr = [];                var pwd = input.value;                arr.push(numReg.test(pwd));                arr.push(letterReg.test(pwd));                arr.push(charReg.test(pwd));                console.log(arr);                var arr1 = arr.filter(function(item)&#123;                    return item;                &#125;)                if(arr1.length === 1) alert("弱");                else if(arr1.length === 2) alert("中");                if(arr1.length === 3) alert("强");            &#125;</code></pre><h3 id="附：扩展正则案例"><a href="#附：扩展正则案例" class="headerlink" title="附：扩展正则案例"></a>附：扩展正则案例</h3><p>只能用数字开头，长度在6—18位之间 /^\d.{5,17}$/</p><p>以字母开头，数字结尾，中间任意一个字符 /^[a-z].\d$/i</p><p>密码不能少于6位的字符 /^.{6,}$/</p><p>以a开头 b字符至少出现2个，至多出现6个(b连续出现) /^a.*b{2,6}/</p><p>变量的命名正则表达式(不能用数字开头 由字母、数字、下划线 、][\w/</p><p>开头为0的2或者三位数字加上 - 开头为非零的八位数字结尾是1到4位的分机号<br>/^0\d{2,3}-[1-9]\d{7}-\d{1,4}$/</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS使用流程</title>
      <link href="/posts/use-nodejs.html"/>
      <url>/posts/use-nodejs.html</url>
      
        <content type="html"><![CDATA[<h3 id="一些命令行："><a href="#一些命令行：" class="headerlink" title="一些命令行："></a>一些命令行：</h3><p>ls:   查看当前目录有哪些文件,加上-a显示所有文件(夹)<br>ll:   同ls,只是显示方式不一样<br>clear:    清屏</p><p>pwd:  print work directory, 打印工作目录的路径</p><p>cd  目录: 进入某个目录, 如果不跟用户名，直接进行用户的根目录</p><p>mkdir   目录名：创建一个目录</p><p>touch   文件名：创建一个文件</p><p>rm -rf  文件或者目录名： 删除一个文件或者一个目录</p><p>npm init:   初始一个项目， 加-y参数可以不用提示直接创建package.json</p><p>在package.json  里可以添加任意的执行脚本。</p><p>如果node项目要监听代码的修改，可以使用 nodemon</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// http是node原生模块，不需要安装可以直接引入const http = require('http')​// 使用http.createServer的方法创建一个serverconst app = http.createServer((req, res) => &#123;res.end('hello 1901!')&#125;)// 让server运行起来吧！！！app.listen(3000, () => &#123;console.log('server is running on http://localhost:3000')&#125;)</code></pre><p>一般在项目中，不会使用原生的方式来写应用。推荐有一些nodejs的框架</p><p>express</p><p>koa</p><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><p>首先要安装npm i express -S</p><p>创建一个基本的express应用</p><p>// 从express包里引入express方法, 这个不是原生的模块，所以需要先安装npm i express -S<br>const express = require(‘express’)<br>​<br>// 创建一个express实例<br>const app = express()<br>​<br>// 定义一个路由，这个路由是通过get方法访问，当访问的时候，服务器发送一个响应给客户端<br>app.get(‘/‘, (req, res) =&gt; {<br>res.send(‘hello express’)<br>})<br>​<br>// 要让app运行起来，需要监听<br>app.listen(3000, () =&gt; {<br>console.log(‘server is running on <a href="http://localhost:3000">http://localhost:3000</a>‘)<br>})</p><p>就可以通过<a href="http://localhost:3000访问，你将看到页面上有hello">http://localhost:3000访问，你将看到页面上有hello</a> express</p><p>npm list -g —depth=0 查看全局安装</p><p>npx 临时使用的命令</p><p>__dirname 当前文件所在的目录<br>peocess.cwd() 命令开始执行时的目录</p>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS使用流程 </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS函数</title>
      <link href="/posts/js-function.html"/>
      <url>/posts/js-function.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数：一个工具，被封装好可重复执行的一段代码块，函数的功能相对单一"><a href="#函数：一个工具，被封装好可重复执行的一段代码块，函数的功能相对单一" class="headerlink" title="函数：一个工具，被封装好可重复执行的一段代码块，函数的功能相对单一"></a>函数：一个工具，被封装好可重复执行的一段代码块，函数的功能相对单一</h2><p>把某一段代码放在函数里面进行封装，可以避免在非必要情况下调用该代码，也就是说我们可以让一段代码在特定情况下再去执行，而且每次需要执行这一段代码的时候只需调用一下这个函数即可（函数名）<br>我们在需要的时候可以调用一个封装好的函数，函数内的一些代码就会被执行，功能就会被实现</p><h3 id="系统函数："><a href="#系统函数：" class="headerlink" title="系统函数："></a>系统函数：</h3><p>parseInt()   alert()  prompt()  eval()</p><h3 id="函数的声明和使用"><a href="#函数的声明和使用" class="headerlink" title="函数的声明和使用"></a>函数的声明和使用</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">//通过function关键字声明一个函数，跟上函数名，一堆小括号，一堆花括号，花括号里面放代码块//提升到顶部function test()&#123;    //可重复执行的代码块&#125;  test();//表达式定义法//不会提升var test1 = function()&#123;    //可重复执行的代码块&#125;for (var i = 0; i < 10; i++) &#123;    test1();&#125;</code></pre><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>形参：形式参数，声明函数的时候写在小括号里面的参数，无需var<br>1.实参：实际参数，在函数调用的时候需要传递实际有值得参数<br>2.实参个数大于形参，多余实参自动舍弃<br>3.形参个数大于形参，多余形参默认为undefined<br>4.实参副本arguments：可以在函数内部使用arguments接收所传递过来的参数，是一个集合</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function test()&#123;    console.log(arguments);    console.log(arguments.length);&#125;        test(1,2,3,5,6) // 打印 1,2,3,5,6   长度为5</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="作用域：变量的作用范围"><a href="#作用域：变量的作用范围" class="headerlink" title="作用域：变量的作用范围"></a>作用域：变量的作用范围</h4><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>作用范围为整个程序的执行范围<br>在函数体外部定义的变量就是全局变量<br>在函数体内部不使用var定义的也是全局变量</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>作用范围是某个函数体内部<br>在函数体内部通过var关键字定义的变量或者形参，都是局部变量<br>当局部变量与全局变量重名时，在函数体内部局部变量优先于全局变量</p><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>变量的声明会提升至当前作用域的最顶端，但不会提升赋值</p><h3 id="return关键字"><a href="#return关键字" class="headerlink" title="return关键字"></a>return关键字</h3><p>1.结束函数的执行<br>2.交回函数执行权<br>3.返回一个结果到全局</p><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>是一种数据结构，指的是数据存取的方式，当定义一个变量时，内存会开辟一段空间<br>栈（ Stack）：先进后出（FILO），在栈顶做插入（压栈）和删除操作（出栈）。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>先进先出（FIFO），在队头做删除操作,在队尾做插入操作。</p><h4 id="堆和它们不同，代码执行时系统动态分配，不存在是先进后出还是先进先出。"><a href="#堆和它们不同，代码执行时系统动态分配，不存在是先进后出还是先进先出。" class="headerlink" title="堆和它们不同，代码执行时系统动态分配，不存在是先进后出还是先进先出。"></a>堆和它们不同，代码执行时系统动态分配，不存在是先进后出还是先进先出。</h4><h3 id="执行环境执行栈（也称执行上下文–execution-context）"><a href="#执行环境执行栈（也称执行上下文–execution-context）" class="headerlink" title="执行环境执行栈（也称执行上下文–execution context）"></a>执行环境执行栈（也称执行上下文–execution context）</h3><p>当JavaScript解释器初始化执行代码时，它首先默认进入全局执行环境，从此刻开始，函数的每次调用都会创建一个新的执行环境，每一个执行环境都会创建一个新的环境对象压入栈中。<br>当执行流进入一个函数时，函数的环境对象就会被压入一个环境栈中（execution stack）。在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>内层环境可以访问外层中的变量和函数，而外层环境不能访问内层的变量和函数</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>程序调用自身的编程技巧称为递归（ recursion）。<br>递归，就是在运行的过程中调用自己，本质就是循环。<br>构成递归需具备的条件</p><ol><li>子问题须与原始问题为同样的事，且更为简单；</li><li>不能无限制地调用本身，须有个出口，化简为非递归状况处理。<br>由于递归是函数本身一层一层压栈，导致先入栈的不能出栈，空间占满以后就会造成堆栈溢出</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>1、利用递归求100的阶乘<br>2、编写函数计算任意数字的阶乘（两种方法）<br>3、函数和循环结合打印任意乘法表<br>4、编写函数实现：两个数平方的阶乘相加的和<br>要求：三个函数实现，一个求阶乘，一个求平方，第三个函数利用这两个函数求出最终结果<br>5、如果一个数恰好等于它的因数（除自身以外）之和，则称该数为“完全数” perfect number。<br>请列出m~n（m&lt;n）的所有完全数（要求用两个函数实现）</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> function </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS程序执行</title>
      <link href="/posts/program-execution.html"/>
      <url>/posts/program-execution.html</url>
      
        <content type="html"><![CDATA[<p> 顺序结构：按照由上到下的顺序一行一行地执行的程序结构<br> 分支结构：根据不同的条件判断来决定程序执行走向的结构（也叫选择结构）<br> 循环结构：需要重复执行同一操作的程序结构称为循环结构。</p><h3 id="if-判断逻辑语句"><a href="#if-判断逻辑语句" class="headerlink" title="if 判断逻辑语句"></a>if 判断逻辑语句</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">if(true)&#123;    //会执行的语句&#125;if(false)&#123;    //会跳过不执行的语句&#125;if(判断条件)&#123; //当if括号中结果为true时执行语句1，否则执行语句2    //语句1&#125;else&#123;    //语句2&#125;if(判断条件1)&#123; //当条件1结果为true时执行语句1    //语句1&#125;else if(判断条件2)&#123; //当条件1结果为false而且条件2结果为true时执行语句2    //语句2&#125;else&#123; //当条件1条件2结果都为false时执行语句3    //语句3&#125;</code></pre><p>我们都知道，if括号中只需要布尔类型值。那么在if判断中，所有的数据类型都会被隐式转换为布尔类型。<br>注意：0、-0、null、””、false、undefined 或者 NaN在if条件里结果为false</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>除了+运算符具有两层含义以外，- <em> /只有数学意义，所以当进行- </em> /运算的时候默认会将运算符两侧的数据类型隐式转换为数字类型，再进行运算。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var a = 2, b = "2";if(a == b)&#123;    alert("a和b相等");    // 会弹  &#125;if(a === b)&#123;    alert("a和b相等");    // 不会弹  &#125;if(1 == true)&#123;    alert("数字1是true");&#125;if(a = b)&#123;    alert("a和b相等");&#125;//一个等号代表赋值操作，结果为等号右边的值</code></pre><h3 id="switch-case多分支语句"><a href="#switch-case多分支语句" class="headerlink" title="switch case多分支语句"></a>switch case多分支语句</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">switch(语句)&#123;  //语句的结果与每一条case内容进行匹配    case 1:       alert(1);           break;        case 2:             alert(2);             break;        case 3:            alert(3);            break;        default:            alert(0);&#125;</code></pre><p>注意switch的应用场景（有多个确定值需要判断的时候）；<br>注意case穿透，要加break语句（如果程序没有发现break语句，那么解析器会继续向下解析）;</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var a = 1;switch(a)&#123;     case 1:       alert(1);    case 2:        alert(2);    case 3:        alert(3);    default:        alert(0);&#125;//每一个alert都会被执行，而且alert会阻断程序进程</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>1.判断一个整数，属于哪个范围：大于0；小于0；等于0<br>2.判断一个整数是偶数还是奇数，并输出判断结果<br>3.开发一款软件，根据公式（身高-108）*2=体重，可以有10斤左右的浮动。来观察测试者体重是否合适<br>4.判断一个三位数是否是水仙花数（如：153 = 1^3 + 5^3 + 3^3，那么153就是水仙花数）</p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>1.点击切换div颜色<br>2.输入分数，判定成绩等级<br>3.输入年份，计算某一年是否是闰年<br>4.输入月份，显示当月的天数，要求：利用case穿透简化代码<br>5.输入数字，显示星期几，如：输入0，弹出星期日，以此类推（两种方法）<br>6.设计一个猜拳游戏：<br>假设： 1代表石头 2代表剪刀 3代表 布<br>计算机每次随机出现1—3中的任意一个数（parseInt (Math.random()*3) + 1）<br>玩家也有三种状态，用玩家出的数和计算机出的数进行比对，按照游戏规则比出胜负。</p><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p>1.根据一个数字日期，判断这个日期是这一年的第几天<br>例如： 20160211，计算后结果为42<br>2.制作一个表单，包括用户名，密码，电话<br>要求：<br>1）做好看点<br>2）点击保存按钮时，使用JS判断用户的联系电话是否为纯数字，如果用户输入有错误，使用alert()弹框警告<br>3）判断用户名是否填写，如果空白，使用alert弹框警告<br>4）判断密码长度，必须大于8位，否则alert警告<br>提示：通过length属性取得字符串的长度</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "hello";str.length // 得到长度</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> if/else </tag>
            
            <tag> switch/case </tag>
            
            <tag> 显/隐式转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS循环结构</title>
      <link href="/posts/js-loop.html"/>
      <url>/posts/js-loop.html</url>
      
        <content type="html"><![CDATA[<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">while(条件)&#123;    //条件成立就会反复执行这里的代码&#125;var count = 0;while(count < 10)&#123;    count++;    document.write("Hello world");&#125;</code></pre><p>注意死循环： 没有终止条件的循环即为死循环，在代码中应尽量避免死循环</p><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">do&#123;    //先执行一遍代码    //while条件成立再继续反复执行&#125;while(条件)</code></pre><h3 id="while和do…while循环的区别"><a href="#while和do…while循环的区别" class="headerlink" title="while和do…while循环的区别"></a>while和do…while循环的区别</h3><p>do…while循环至少会执行一遍，不管条件是否成立，但是while循环如果初始条件不成立一遍也不会执行。</p><h3 id="break和continue关键字"><a href="#break和continue关键字" class="headerlink" title="break和continue关键字"></a>break和continue关键字</h3><p>break：跳出循环体，整个循环结束<br>continue：结束本次循环进入下一次循环体</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">for (var i = 0; i < 10; i++) &#123;    console.log(i);&#125;</code></pre><p>如下图所示：注意for循环时的执行顺序,并且：for循环1，2，4步是可选的<br><!-- ![for的循环执行顺序](JS循环结构/for.png) --><br><img src="https://i.loli.net/2020/09/12/4homTRBp1gKLOe9.png" alt="loop.png"></p><h3 id="三种循环的联系和区别"><a href="#三种循环的联系和区别" class="headerlink" title="三种循环的联系和区别"></a>三种循环的联系和区别</h3><p>1、都是会反复执行的代码块<br>2、大部分情况下可以互相替换<br>3、do…while至少执行一次，while和for有可能0次，while不太能确定执行次数，for可以</p><h3 id="练习（while和for两种方式）"><a href="#练习（while和for两种方式）" class="headerlink" title="练习（while和for两种方式）"></a>练习（while和for两种方式）</h3><p>1.打印100以内所有偶数的和<br>2.求出1-1/2+1/3-1/4…..1/100的和<br>3.打印出1000-2000年中所有的闰年，并以每行四个数的形式输出<br>4.打印九九乘法表<br>5.求1+2!+3!+…+20!的值<br>6.有一个棋盘，有64个方格，在第一个方格里面放1粒芝麻重量是0.00001kg，第二个里面放2粒，第三个里面放4，按每一个格子是前一个格子的二倍（第四个格子放8个）计算，问棋盘上放的所有芝麻的重量是多少？<br>7.打印100–200之间所有能被3或者7整除的数<br>8.计算100的阶乘</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> while </tag>
            
            <tag> do...while </tag>
            
            <tag> break和continue </tag>
            
            <tag> for </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery</title>
      <link href="/posts/jquery.html"/>
      <url>/posts/jquery.html</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery-语法"><a href="#jQuery-语法" class="headerlink" title="jQuery 语法"></a>jQuery 语法</h2><p>jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。<br>基础语法： $(selector).action()</p><h3 id="美元符号定义-jQuery"><a href="#美元符号定义-jQuery" class="headerlink" title="美元符号定义 jQuery"></a>美元符号定义 jQuery</h3><p>选择符（selector）”查询”和”查找” HTML 元素<br>jQuery 的 action() 执行对元素的操作<br>jQuery 中所有选择器都以美元符号开头：$()</p><h3 id="文档就绪事件"><a href="#文档就绪事件" class="headerlink" title="文档就绪事件"></a>文档就绪事件</h3><p>$(document).ready(function(){</p><p>   // 开始写 jQuery 代码…</p><p>});</p><p>简洁写法（与以上写法效果相同）:<br>$(function(){</p><p>   // 开始写 jQuery 代码…</p><p>});<br>这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作</p><pre><code>    &lt;div&gt;123&lt;/div&gt;    &lt;div class=&quot;div1&quot;&gt;456&lt;/div&gt;    &lt;div id=&quot;div2&quot;&gt;789&lt;/div&gt;    &lt;p class=&quot;p1&quot;&gt;qeq&lt;/p&gt;    &lt;p&gt;xxx&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        var div = $(&quot;div&quot;);        console.log(div);           // console.log(jQuery);        console.log($(&quot;div&quot;).eq(1));//选择第一个div        console.log($(&quot;div:eq(2)&quot;));//选择第二个div        //:eq     匹配一个给定索引值的元素,单个元素        console.log($(&quot;div&quot;).html());//div的内容        console.log($(&quot;*&quot;));//查找所有的元素        console.log($(this));//选取当前的HTML元素        console.log($(&quot;p.p1&quot;));//选择class=&quot;p1&quot;的p标签        console.log($(&quot;p:first&quot;));//选择第一个p标签        console.log($(&quot;ul li:first&quot;));//选择ul下的第一个li        $(&quot;p:first&quot;).dblclick(function()&#123;            alert(&quot;双击！&quot;);        &#125;)        console.log($(&quot;div&quot;)[0]);//转换为原生js        console.log($(&quot;div&quot;).get(0));转换为原生js        $(&quot;div&quot;).eq(1).html(&quot;我QQ(#`O′)&quot;).addClass(&quot;box1&quot;).css(&quot;color&quot;,&quot;red&quot;);        var div2 = document.querySelector(&quot;#div2&quot;);        console.log($(&quot;div2&quot;));//转换为jQuery        console.log($(&quot;ul&quot;).children(&quot;.two&quot;));//ul下class=&quot;two&quot;的li        console.log($(&quot;ul&quot;).find(&quot;.two&quot;));//ul下的class=&quot;two&quot;的所有元素    &lt;/script&gt;</code></pre><p>1.jQuery选择器<br><a href="https://upload-images.jianshu.io/upload_images/15859737-b0b882c867eebb34.png?imageMogr2/auto-orient/strip|imageView2/2/w/732/format/webp">https://upload-images.jianshu.io/upload_images/15859737-b0b882c867eebb34.png?imageMogr2/auto-orient/strip|imageView2/2/w/732/format/webp</a></p><p>2.jQuery事件<br><a href="https://upload-images.jianshu.io/upload_images/15859737-b0a12d607a4c78c3.png?imageMogr2/auto-orient/strip|imageView2/2/w/657/format/webp">https://upload-images.jianshu.io/upload_images/15859737-b0a12d607a4c78c3.png?imageMogr2/auto-orient/strip|imageView2/2/w/657/format/webp</a></p>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome调试</title>
      <link href="/posts/chrome-debug.html"/>
      <url>/posts/chrome-debug.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-console-table"><a href="#1-console-table" class="headerlink" title="1.console.table();"></a>1.console.table();</h3><p>将数组打开展示。<br><img src="https://i.loli.net/2020/09/13/BgC2neTEO7fVIrN.png" alt="1.PNG"></p><h3 id="2-console-time"><a href="#2-console-time" class="headerlink" title="2.console.time()"></a>2.console.time()</h3><p>代码运行时间,console.timeEnd()放在结尾<br><img src="https://i.loli.net/2020/09/13/hoYGDM2Jive1ysW.png" alt="2.PNG"></p><h3 id="3-monitorEvents（）"><a href="#3-monitorEvents（）" class="headerlink" title="3.monitorEvents（）;"></a>3.monitorEvents（）;</h3><p>事件执行顺序。</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-cookie</title>
      <link href="/posts/cookie.html"/>
      <url>/posts/cookie.html</url>
      
        <content type="html"><![CDATA[<h2 id="cookie-会话跟踪技术"><a href="#cookie-会话跟踪技术" class="headerlink" title="cookie 会话跟踪技术"></a>cookie 会话跟踪技术</h2><p>一个网站从打开到浏览（包括这个网站的其他子页面）到最后关闭浏览器整个过程叫一个“会话”。<br>在一次会话从开始到结束的整个过程，全程跟踪记录客户端的状态（例如：是否登录、购物车信息、是否已下载、是否 已点赞、视频播放进度等等）。  </p><p>多次请求页面，数据共享<br><img src="https://i.loli.net/2020/09/12/mTN329IUQzA6ZS8.png" alt="cookie.png"></p><h3 id="cookie的存取"><a href="#cookie的存取" class="headerlink" title="cookie的存取"></a>cookie的存取</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">document.cookie = "username=zhangsan"; //存 cookieconsole.log(document.cookie); // 取 cookie</code></pre><h3 id="cookie的修改与删除"><a href="#cookie的修改与删除" class="headerlink" title="cookie的修改与删除"></a>cookie的修改与删除</h3><p>修改：再次写一个同名cookie，即可覆盖修改了<br>删除：将expires值比如取为-1，时效写为以前的日期</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 存cookie function setCookie() &#123;     tools.cookie("user", "张三", &#123;path: "/"&#125;);&#125;// 取cookiefunction getCookie () &#123;    var user = tools.cookie("user");    console.log(user);&#125;// 删除cookiefunction deleteCookie () &#123;    // 把cookie的过期时间设置为以前的日期    tools.cookie("user", "", &#123;expires: -1, path: "/"&#125;);&#125;</code></pre><h3 id="而使用cookie技术的目的就是：解决HTTP无状态的问题"><a href="#而使用cookie技术的目的就是：解决HTTP无状态的问题" class="headerlink" title="而使用cookie技术的目的就是：解决HTTP无状态的问题"></a>而使用cookie技术的目的就是：解决HTTP无状态的问题</h3><ul><li>注意：cookie是http/https协议下的技术，不支持本地file文件对cookie操作（但是貌似火狐浏览器是个例外）</li><li>HTTP（无状态的协议）,基于TCP协议的一种高级协议, 用于客户端和服务器直接的通信</li></ul><h3 id="cookie的时效：-expires"><a href="#cookie的时效：-expires" class="headerlink" title="cookie的时效： expires"></a>cookie的时效： expires</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var d = new Date();d.setDate(d.getDate() + 2); //例如设置到过期的日期为2天后document.cookie = "username=zhangsan;expires="+d;</code></pre><h3 id="cookie的路径：path"><a href="#cookie的路径：path" class="headerlink" title="cookie的路径：path"></a>cookie的路径：path</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">document.cookie = "name=zhangsan;path=/"; //将存的cookie设置存储在/根路径下，确保该网站下的每个页面都可以取这个cookie&#125;</code></pre><h3 id="cookie的特点"><a href="#cookie的特点" class="headerlink" title="cookie的特点"></a>cookie的特点</h3><p>1.只能使用文本，不能中文，不能存对象<br>2 单条存储有大小限制 4KB<br>3 数量限制(一般浏览器，限制大概在50条左右)<br>4 读取有域名限制 不可跨域读取，只能由来自 写入cookie的 同一域名 的网页可进行读取。<br>5 时效限制 每个cookie都有时效，最短的有效期是，会话级别：就是当浏览器关闭，那么cookie立即销毁</p><h3 id="encodeURIComponent和decodeURIComponent方法"><a href="#encodeURIComponent和decodeURIComponent方法" class="headerlink" title="encodeURIComponent和decodeURIComponent方法"></a>encodeURIComponent和decodeURIComponent方法</h3><ul><li>因为cookie的特点不能使用中文，所以存的时候若有中文要重新编码</li></ul><ol><li><p>encodeURIComponent用于编码,可将中文转化为其他字符，例如encodeURIComponent(‘张三’)，结果为”%E5%BC%A0%E4%B8%89”</p></li><li><p>decodeURIComponent反之用于解码<br>decodeURIComponent(“%E5%BC%A0%E4%B8%89”); // 张三</p></li></ol><pre class=" language-lang-javascript"><code class="language-lang-javascript">var username = "张三";username = encodeURIComponent(username);document.cookie = "username="+username;console.log(document.cookie);</code></pre><h3 id="若非要存取一个对象类型的cookie"><a href="#若非要存取一个对象类型的cookie" class="headerlink" title="若非要存取一个对象类型的cookie"></a>若非要存取一个对象类型的cookie</h3><ul><li>前面说了，cookie的特点为只能存取文本，若非要存取一个对象类型的cookie，则要进行转换<br>```javascript<br>var obj = &#123;<br>  “name”:”zhangsan”,<br>  “age”: 18<br>&#125;;<br>// 存cookie<br>tools.cookie(“cart”, JSON.stringify(obj), &#123;”path”: “/“, “expires”: 5&#125;);</li></ul><p>// 取cookie<br>var obj2 = JSON.parse(tools.cookie(“cart”));<br>console.log(obj2);</p><pre><code>### 封装一个存取cookie的函数（记忆，面试可能会问到）```javascriptvar tools = &amp;#123;/* cookie的操作（存取） * @param key   string  存取的key值 * @param [value] string  如果传入value，那么就是 存cookie; 不传就是 取cookie; 就可以根据是否有value值来判断是存 或者 取 cookie，然后进行相应的操作 * @paran [option] object  &amp;#123;expires, path&amp;#125; * @return  string 取cookie的时候返回的当前cookie的值 */cookie : function (key, value, option) &amp;#123;  if(value === undefined)&amp;#123;    // 1.取cookie    var cookie = document.cookie;    var arr = cookie.split(&quot;; &quot;); // 因为cookie格式为key和value中间以=连接    var obj = &amp;#123;&amp;#125;;    arr.forEach(function(ele)&amp;#123;        var subarr = ele.split(&quot;=&quot;);        obj[subarr[0]] = decodeURIComponent(subarr[1]);    &amp;#125;)    // 判断obj对象里面有没有这个key    return obj[key] ? obj[key] : &quot;&quot;;  &amp;#125;  else&amp;#123;    //2.存cookie    var str = key+&quot;=&quot;+encodeURIComponent(value);    if(option)&amp;#123;        // path        if(option.path)&amp;#123;            str += &quot;;path=&quot;+option.path;        &amp;#125;        // expires        if(option.expires) &amp;#123;            var date = new Date();            // 把过期日期设置为option.expires天之后            date.setDate(date.getDate() + option.expires);            str += &quot;;expires=&quot; + date;        &amp;#125;    &amp;#125;    document.cookie = str;  &amp;#125;&amp;#125;&amp;#125;// 以后就可以引用这个写好的方法// 例如：//存cookie// tools.cookie(&quot;name&quot;, &quot;张三&quot;, &amp;#123;&quot;path&quot;: &quot;/&quot;, &quot;expires&quot;: 5&amp;#125;); //取cookie // console.log(tools.cookie(&quot;name&quot;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> path </tag>
            
            <tag> expires </tag>
            
            <tag> 封装存取cookie的函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-模块化</title>
      <link href="/posts/amd-cmd.html"/>
      <url>/posts/amd-cmd.html</url>
      
        <content type="html"><![CDATA[<p>函数封装 —-&gt; 对象 —-&gt; 立即执行函数 —-&gt; 模块化规范</p><p>是一种项目的构架模式， 这种构架模式让JS代码重用性变得非常高，让项目构架的一些复杂问题全部得以解决。 例如，多个script标签不会再出现了，我们只要用一个script标签进行引入就可以了。</p><p>模块化那有两个规范，AMD规范和CMD规范，当然还有针对于nodejs后台的commonJS规范;</p><h3 id="1-首先对于依赖："><a href="#1-首先对于依赖：" class="headerlink" title="1. 首先对于依赖："></a>1. 首先对于依赖：</h3><p>AMD提前执行(不管什么时候用， 先加载过来) //特点 : 前期消耗网络资源大， 但是后期运行效率高.</p><p>CMD需求执行(有用我再去加载) //特点:整个自选消耗曲线比较平缓。</p><h3 id="2-CMD-推崇依赖就近，AMD-推崇依赖前置。"><a href="#2-CMD-推崇依赖就近，AMD-推崇依赖前置。" class="headerlink" title="2. CMD 推崇依赖就近，AMD 推崇依赖前置。"></a>2. CMD 推崇依赖就近，AMD 推崇依赖前置。</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript"> // CMDdefine(function(require, exports, module) &#123;var a = require('./a')a.doSomething()// 此处略去 100 行var b = require('./b') // 依赖可以就近书写b.doSomething()// ...&#125;)</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript"> // AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好a.doSomething()// 此处略去 100 行b.doSomething()...&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化规范 </tag>
            
            <tag> AMD/CMD </tag>
            
            <tag> 依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础-string内置对象</title>
      <link href="/posts/js-string.html"/>
      <url>/posts/js-string.html</url>
      
        <content type="html"><![CDATA[<p>String 对象用于处理文本（字符串）。<br>String 对象创建方法： new String()。<br>语法：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var txt = new String("string");//或者更简单方式：var txt = "string";</code></pre><h3 id="string对象方法表："><a href="#string对象方法表：" class="headerlink" title="string对象方法表："></a>string对象方法表：</h3><p><a href="https://upload-images.jianshu.io/upload_images/15859737-01b5d756294501e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/670/format/webp">https://upload-images.jianshu.io/upload_images/15859737-01b5d756294501e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/670/format/webp</a></p><h3 id="ASCII表："><a href="#ASCII表：" class="headerlink" title="ASCII表："></a>ASCII表：</h3><p><a href="https://upload-images.jianshu.io/upload_images/15859737-4f1aa1dfab830324.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1155/format/webp">https://upload-images.jianshu.io/upload_images/15859737-4f1aa1dfab830324.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1155/format/webp</a></p><h3 id="一些常用方法"><a href="#一些常用方法" class="headerlink" title="一些常用方法"></a>一些常用方法</h3><p>charAt() 方法可返回指定位置的字符。第一个字符位置为 0, 第二个字符位置为 1,以此类推</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "HELLO WORLD";var n = str.charAt(2)//L</code></pre><p>charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。字符串中第一个字符的位置为 0， 第二个字符位置为 1，以此类推。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "HELLO WORLD";var n = str.charCodeAt(0);//72</code></pre><p>concat() 方法用于连接两个或多个字符串。<br>该方法没有改变原有字符串，但是会返回连接两个或多个字符串新字符串。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str1 = "Hello ";var str2 = "world!";var n = str1.concat(str2);//Hello world!</code></pre><p>fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var n = String.fromCharCode(65);//A</code></pre><p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。<br>如果没有找到匹配的字符串则返回 -1。<br>注意： indexOf() 方法区分大小写。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="Hello world, welcome to the universe.";var n=str.indexOf("welcome");//13</code></pre><p>lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，如果指定第二个参数 start，则在一个字符串中的指定位置从后向前搜索。<br>注意： 该方法将从后向前检索字符串，但返回是从起始位置 (0) 开始计算子字符串最后出现的位置。 看它是否含有字符串。<br>开始检索的位置在字符串的 start 处或字符串的结尾（没有指定 start 时）。<br>如果没有找到匹配字符串则返回 -1 。<br>注意：lastIndexOf() 方法是区分大小写的！</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="I am from runoob，welcome to runoob site.";var n=str.lastIndexOf("runoob");//28</code></pre><p>includes() 方法用于判断字符串是否包含指定的子字符串。<br>如果找到匹配的字符串则返回 true，否则返回 false。<br>注意： includes() 方法区分大小写。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "Hello world, welcome to the Runoob。";var n = str.includes("world");//true</code></pre><p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="The rain in SPAIN stays mainly in the plain"; var n=str.match(/ain/g);//ain,ain,ain</code></pre><p>repeat() 方法字符串复制指定次数。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "Runoob";str.repeat(2);//RunoobRunoob</code></pre><p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。该方法不会改变原始字符串</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="Visit Microsoft! Visit Microsoft!";var n=str.replace("Microsoft","Runoob");//Visit Runoob!Visit Microsoft!</code></pre><p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="Visit Runoob!"; var n=str.search("Runoob");//6</code></pre><p>slice(start, end) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。<br>使用 start（包含） 和 end（不包含） 参数来指定字符串提取的部分。<br>字符串中第一个字符位置为 0, 第二个字符位置为 1, 以此类推。<br>提示： 如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="Hello world!";var n=str.slice(1,5);/ello</code></pre><p>split() 方法用于把一个字符串分割成字符串数组。<br>提示： 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。<br>注意： split() 方法不改变原始字符串。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="How are you doing today?";var n=str.split(" ");//How,are,you,doing,today?</code></pre><p>startsWith() 方法用于检测字符串是否以指定的子字符串开始。<br>如果是以指定的子字符串开头返回 true，否则 false。<br>startsWith() 方法对大小写敏感。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "Hello world, welcome to the Runoob.";var n = str.startsWith("Hello");//true</code></pre><p>substr() 方法可在字符串中抽取从 开始 下标开始的指定数目的字符。<br>提示： substr() 的参数指定的是子串的开始位置和长度，因此它可以替代 substring() 和 slice() 来使用。<br>注意： substr() 方法不会改变源字符串</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="Hello world!";var n=str.substr(2,3)//llo</code></pre><p>比较：<br>substr() 方法用于在字符串中抽取从 开始 下标开始的指定数目的字符。<br>substring() 提取字符串中介于两个指定下标之间的字符，方法返回的子串包括 开始 处的字符，但不包括 结束 处的字符。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="Hello world!";document.write(str.substr(3)+"<br>");//lo world!document.write(str.substring(3,7));//lo w</code></pre><p>toLowerCase() 方法用于把字符串转换为小写。<br>toUpperCase() 方法用于把字符串转换为大写。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str="Runoob";document.write(str.toLowerCase());var str="Runoob";document.write(str.toUpperCase());</code></pre><p>trim() 方法用于删除字符串的头尾空格。<br>注意：trim() 方法不会改变原始字符串。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "       Runoob        ";alert(str.trim());//Runoob</code></pre><p>toString() 返回一个字符串。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = 123;var res = str.toString();//"123"</code></pre><p>案例：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//var str = "I say: 'I am a boy'";var str = 'I say: "I am a boy"';console.log(str.length);console.log(str[2]);console.log(str.charCodeAt(0)); //返回str第0个的ASCII编码console.log(String.fromCharCode(65)); //利用编码得到字符</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string对象方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-闭包和继承</title>
      <link href="/posts/closure-inheritance.html"/>
      <url>/posts/closure-inheritance.html</url>
      
        <content type="html"><![CDATA[<p>函数在创建的时候会创建两个对象，一个是函数对象本身，另一个是作用域链对象<br>函数在调用的时候会创建一个执行环境对象（活动对象）</p><h2 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h2><p>闭包可以在全局函数里面操作另一个作用域的局部变量, 既能重复使用，又不会污染全局<br>闭包有三步：</p><p>1、外层函数嵌套内层函数<br>2、内层函数使用外层函数的局部变量<br>3、把内层函数作为外层函数的返回值</p><p>图例展示：<br>1-预解析<br><img src="https://i.loli.net/2020/09/13/uEgYM9xGc6tbPZW.png" alt="1-预解析.png"></p><p>2-调用时<br><img src="https://i.loli.net/2020/09/13/lzGn5KN4yYZpReO.png" alt="2-调用时.png"></p><p>3-调用后<br><img src="https://i.loli.net/2020/09/13/1FQXrTwCpkH3abS.png" alt="3-调用后.png"></p><p>4-fn调用时<br><img src="https://i.loli.net/2020/09/13/SIjo2mkyeBEv4wQ.png" alt="4-fn调用时.png"></p><p>5-fn调用后<br><img src="https://i.loli.net/2020/09/13/S24RgQIqUwEPnHv.png" alt="5-fn调用后.png"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类共享父类的属性和方法,js的继承都是基于原型实现的</p><h3 id="1-原型链继承：子类的原型指向父类的实例"><a href="#1-原型链继承：子类的原型指向父类的实例" class="headerlink" title="1. 原型链继承：子类的原型指向父类的实例"></a>1. 原型链继承：子类的原型指向父类的实例</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript"> function Cat()&#123;&#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';var cat = new Cat();console.log(cat.name);cat.say();cat.eat('fish');console.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true</code></pre><p>特点：<br>非常纯粹的继承关系，实例是子类的实例，也是父类的实例<br>父类新增原型方法/原型属性，子类都能访问到<br>简单，易于实现</p><p>缺点：<br>要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中<br>无法实现多继承<br>来自原型对象的引用属性是所有实例共享的<br>创建子类实例时，无法向构造函数传参</p><h3 id="2-构造继承（call、apply继承）"><a href="#2-构造继承（call、apply继承）" class="headerlink" title="2. 构造继承（call、apply继承）"></a>2. 构造继承（call、apply继承）</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript"> function Cat(name)&#123;    Animal.call(this,name);&#125;var cat = new Cat("Tom");console.log(cat.name);cat.say();console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true</code></pre><p>特点：<br>解决了1中，子类实例共享父类引用属性的问题<br>创建子类实例时，可以向父类传递参数<br>可以实现多继承（call多个父类对象）</p><p>缺点：<br>实例并不是父类的实例，只是子类的实例<br>只能继承父类的实例属性和方法，不能继承原型属性/方法<br>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p><h3 id="3-拷贝继承"><a href="#3-拷贝继承" class="headerlink" title="3. 拷贝继承"></a>3. 拷贝继承</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Cat(name)&#123;    var animal = new Animal(name);    for(var key in animal)&#123;        Cat.prototype[key] = animal[key];    &#125;&#125;// Test Codevar cat = new Cat("Tom");console.log(cat.name);cat.say();console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true</code></pre><p>特点：<br>支持多继承</p><p>缺点：<br>效率较低，内存占用高（因为要拷贝父类的属性）<br>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p><h3 id="4-组合继承（原型链和构造继承的组合）"><a href="#4-组合继承（原型链和构造继承的组合）" class="headerlink" title="4. 组合继承（原型链和构造继承的组合）"></a>4. 组合继承（原型链和构造继承的组合）</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Cat(name)&#123;    Animal.call(this,name);&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat;// Test Codevar cat = new Cat();console.log(cat.name);cat.say();console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true</code></pre><p>特点：<br>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法<br>既是子类的实例，也是父类的实例<br>不存在引用属性共享问题<br>可传参<br>函数可复用</p><p>缺点：<br>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p><h3 id="5-寄生组合继承"><a href="#5-寄生组合继承" class="headerlink" title="5. 寄生组合继承"></a>5. 寄生组合继承</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Cat(name)&#123;    Animal.call(this);    this.name = name;&#125;(function()&#123;    // 创建一个没有实例方法的类    var Super = function()&#123;&#125;;    Super.prototype = Animal.prototype;    //将实例作为子类的原型    Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);cat.say();console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true</code></pre><p>特点：堪称完美<br>缺点：实现较为复杂</p><h3 id="6-ES6继承（语法糖）"><a href="#6-ES6继承（语法糖）" class="headerlink" title="6. ES6继承（语法糖）"></a>6. ES6继承（语法糖）</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">class Animal&#123;    constructor(name)&#123;        this.name = name;    &#125;    say()&#123;        alert("My name is "+this.name);    &#125;    eat(food)&#123;        alert(this.name+" is eating "+food);    &#125;&#125;class Cat extends Animal&#123;    constructor(name)&#123;        super(name);    &#125;&#125;var  tom = new Cat("Tom");tom.say();tom.eat("apple");console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础-json</title>
      <link href="/posts/about-json.html"/>
      <url>/posts/about-json.html</url>
      
        <content type="html"><![CDATA[<p>json简单说就是javascript中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构。</p><p>1、对象：对象在js中表示为“{}”括起来的内容，数据结构为 {key：value,key：value,…}的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象.key 获取属性值，这个属性值的类型可以是 数字、字符串、数组、对象几种。</p><p>2、数组：数组在js中是中括号“[]”括起来的内容，数据结构为 [“java”,”javascript”,”vb”,…]，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。</p><p>举例：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var students = ["小明","小红"];var ages = [18,17];var stuJson = [    &#123;        "name":"xiaoming",        "age":18,        "likes":["抽烟","喝酒","烫头"]    &#125;,    &#123;        name:"xiaohong",        age:17    &#125;,    &#123;        name:"xiaogang",        age:70    &#125;];</code></pre><p>根据json打印表格：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//发送了一个请求,服务器返回jsonvar list = [    &#123;        "name":"显示器",        "price": 800    &#125;,    &#123;        "name":"鼠标",        "price": 9.9    &#125;,    &#123;        "name":"键盘",        "price": 666    &#125;];var table = "<table>";for(var i = 0; i < list.length; i++)&#123;    table += "<tr>";    //遍历list[i](对象)    for(var key in list[i])&#123;        table += "<td>"+ list[i][key] +"</td>";    &#125;    table += "</tr>";&#125;table += "</table>";document.write(table);</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-ajax</title>
      <link href="/posts/ajax.html"/>
      <url>/posts/ajax.html</url>
      
        <content type="html"><![CDATA[<h2 id="Ajax（-Asynchronous-Javascript-And-XML）"><a href="#Ajax（-Asynchronous-Javascript-And-XML）" class="headerlink" title="Ajax（ Asynchronous Javascript And XML）"></a>Ajax（ Asynchronous Javascript And XML）</h2><h3 id="注意同步和异步的区分"><a href="#注意同步和异步的区分" class="headerlink" title="注意同步和异步的区分"></a>注意同步和异步的区分</h3><ul><li><p>同步 sync： 首先，JS 是单线程的语言，所谓“单线程”就是一根筋，对于拿到的程序，一行一行的执行，前面的执行完成，后面的傻傻的等着。若前面的代码没执行完就会造成堵塞，后面的没法执行。</p></li><li><p>异步 async： 而AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。异步代码执行的时候就不会阻塞后面的代码执行。</p></li><li><p>记住： 同步执行代码总是优先于异步执行代码，同步代码在异步代码之前执行。</p><ul><li>因为碰到异步代码时，会将异步代码另行存到一个异步队列里面，然后将这个异步队列放到同步代码的最后，才执行<br>例如：Ajax和setTimeout和setInterval这些是异步执行的</li></ul></li></ul><h3 id="Ajax-优势"><a href="#Ajax-优势" class="headerlink" title="Ajax 优势:"></a>Ajax 优势:</h3><p>1.不需要插件支持（一般浏览器且默认开启 JavaScript 即可）；<br>2.用户体验极佳（不刷新页面即可获取可更新的数据）；<br>3.提升 Web 程序的性能（在传递数据方面做到按需放松，不必整体提交）；<br>4.减轻服务器和带宽的负担（将服务器的一些操作转移到客户端）；</p><h3 id="Ajax-的不足"><a href="#Ajax-的不足" class="headerlink" title="Ajax 的不足:"></a>Ajax 的不足:</h3><p>1.不同版本的浏览器度 XMLHttpRequest 对象支持度不足(比如 IE5 之前)；<br>2.前进、后退的功能被破坏（因为 Ajax 永远在当前页，不会记录前后页面）；<br>3.搜索引擎的支持度不够（因为搜索引擎爬虫还不能理解 JS 引起变化数据的内容）；</p><p>json是一种数据格式，由对象，数组互相嵌套组成，属性名必须加双引号，数据传输格式</p><h3 id="ajax-readyState"><a href="#ajax-readyState" class="headerlink" title="ajax.readyState:"></a>ajax.readyState:</h3><p>0 － （未初始化）还没有调用send()方法<br>1 － （载入）已调用send()方法，正在发送请求<br>2 － （载入完成）send()方法执行完成，已经接收到全部响应内容<br>3 － （交互）正在解析响应内容<br>4 － （完成）响应内容解析完成，可以在客户端调用了</p><h3 id="HTTP-状态码-ajax-status"><a href="#HTTP-状态码-ajax-status" class="headerlink" title="HTTP 状态码 ajax.status"></a>HTTP 状态码 ajax.status</h3><p>101——客户要求服务器根据请求转换HTTP协议版本<br>200——交易成功<br>304——客户端已经执行了GET，但文件未变化<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>400——错误请求，如语法错误<br>404——没有发现文件、查询或UR<br>405——用户在Request-Line字段定义的方法不允许<br>500——服务器产生内部错误<br>505——服务器不支持或拒绝支请求头中指定的HTTP版本</p><h3 id="GET，POST方式比较"><a href="#GET，POST方式比较" class="headerlink" title="GET，POST方式比较"></a>GET，POST方式比较</h3><p>只是不同的发送和请求数据的方式<br>GET：参数有长度限制，<a href="http://www.taobao.com?id=">http://www.taobao.com?id=</a>… , 明文传输<br>POST：参数无限制，放在请求体里, 更安全</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// get方式var ajax = new XMLHttpRequest();ajax.open("GET","url",true);ajax.send(null);ajax.onreadystatechange = function()&#123;if(ajax.readyState == 4 && ajax.status == 200)&#123;     var json = JSON.parse(ajax.responseText);    fn(json);&#125;// post方式var ajax = new XMLHttpRequest();ajax.open("POST","url",true);ajax.setRequestHeader("Content-type","application/x-www-form-urlencoded");ajax.send("name=zhangsan&age=18");ajax.onreadystatechange = function()&#123;if(ajax.readyState == 4 && ajax.status == 200)&#123;     var json = JSON.parse(ajax.responseText);    fn(json);&#125;</code></pre><h3 id="封装一个Ajax的get和post方式"><a href="#封装一个Ajax的get和post方式" class="headerlink" title="封装一个Ajax的get和post方式"></a>封装一个Ajax的get和post方式</h3><h4 id="ajax的get方式："><a href="#ajax的get方式：" class="headerlink" title="ajax的get方式："></a>ajax的get方式：</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript">/* ajax请求get * @param url     string   请求的路径 * @param query   object   请求的参数query * @param succCb  function 请求成功之后的回调 * @param failCb  function 请求失败的回调 * @param isJson  boolean  true： 解析json  false：文本请求  默认值true  */ajaxGet : function (url, query, succCb, failCb, isJson) &#123;    // 拼接url加query    if(query) &#123;        url += "?";        for(var key in query)&#123;            url += key+"="+query[key]+"&";        &#125;        // 把最后一个&删掉        url = url.slice(0, -1);    &#125;    // 1、创建对象    var ajax = new XMLHttpRequest();    // 2、建立连接    ajax.open("GET", url, true);    // 3、发送请求    ajax.send(null);    // 4、监听状态的改变    ajax.onreadystatechange = function()&#123;        if(ajax.readyState === 4)&#123;            if(ajax.status === 200)&#123;                // 用户传了回调才执行                // isJson默认值为true，要解析json                if(isJson === undefined)&#123;                    isJson = true;                &#125;                var res = isJson ? JSON.parse(ajax.responseText) : ajax.responseText;                succCb && succCb(res);            &#125;else&#123;                // 请求失败                failCb && failCb();            &#125;        &#125;    &#125;&#125;// 调用该方法实例：//tools.ajaxGet("03-ajax.php", &#123;"name": "lisi"&#125;, function(res)&#123;console.log(res);&#125;, function() &#123;&#125;,false);</code></pre><h4 id="ajax的post方式："><a href="#ajax的post方式：" class="headerlink" title="ajax的post方式："></a>ajax的post方式：</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript">/* ajax请求post * @param url     string   请求的路径 * @param query   object   请求的参数query * @param succCb  function 请求成功之后的回调 * @param failCb  function 请求失败的回调 * @param isJson  boolean  true： 解析json  false：文本请求  默认值true  */ajaxPost: function(url, query, succCb, failCb, isJson)&#123;    var ajax = new XMLHttpRequest();    ajax.open("POST", url, true);    // 设置请求头数据传输格式    ajax.setRequestHeader("Content-type","application/x-www-form-urlencoded");    // 把query拼接成urlencoded    var str = "";    for(var key in query)&#123;        str += key + "=" + query[key] + "&";    &#125;    str = str.slice(0,-1);    ajax.send(str);    ajax.onreadystatechange = function () &#123;        if(ajax.readyState === 4) &#123;            if(ajax.status === 200)&#123;                // 判断isJson是否传进来了                isJson = isJson === undefined ? true : isJson;                succCb && succCb(isJson ? JSON.parse(ajax.responseText) : ajax.responseText);            &#125;        &#125;    &#125;&#125;// 调用该方法实例：//tools.ajaxGet("03-ajax.php", &#123;"name": "lisi"&#125;, function(res)&#123;console.log(res);&#125;, function() &#123;&#125;,false);</code></pre><h3 id="同源策略："><a href="#同源策略：" class="headerlink" title="同源策略："></a>同源策略：</h3><p>浏览器安全策略，保障非同源资源之间数据访问的安全性。<br>默认不允许非同源的资源直接访问。<br>URL：<br>协议://域名:端口/路径名称?查询字符串#位置标识符<br>同源：协议、域名、端口完全一致，只要三个中有任何一个不一致，则是非同源<br>非同源资源间需要进行访问，则需要实现跨域。</p><h2 id="解决资源跨域访问："><a href="#解决资源跨域访问：" class="headerlink" title="解决资源跨域访问："></a>解决资源跨域访问：</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>cross-origin resource sharing<br>服务器端：设置响应头信息：Access-Control-Allow-Origin:*<br>前端： ajax可解决GET/POST跨域需求</p><h4 id="GET方式："><a href="#GET方式：" class="headerlink" title="GET方式："></a>GET方式：</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript"></code></pre><h4 id="POST方式"><a href="#POST方式" class="headerlink" title="POST方式:"></a>POST方式:</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript"></code></pre><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>利用script标签的src属性在引入外部JS时不受同源策略限制的特性，来实现跨域。<br>JSONP只能处理GET请求方式的跨域<br>后端：<br>由服务器端构建一个字符串：字符串中的内容是能够在 JS 中执行的函数调用的结构<br>前端：</p><ol><li>创建 script 元素</li><li>设置 src 属性，传递 callback 参数指明全局回调函数的名称</li><li>添加到 body 中</li><li>创建全局函数，用于处理响应数据</li><li><p>删除 script 元素</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">/* jsonp ajax请求* @param  url  string 请求路径* @param  cb    string  全局函数名* @param  query  object  请求参数*/ajaxJsonp : function(url, cb, query) &#123; // 1、 创建script标签 var script  = document.createElement("script"); // 2、拼接url和回调函数以及请求参数 url += "?cb="+cb; if(query)&#123;     for(var key in query)&#123;         url += "&"+key+"="+query[key];     &#125; &#125; // 3、设置script的src属性 script.src = url; // 4、 把script添加到body中 document.body.appendChild(script); document.body.removeChild(script);&#125;</code></pre></li></ol><h3 id="promise（ES6）"><a href="#promise（ES6）" class="headerlink" title="promise（ES6）"></a>promise（ES6）</h3><p>承诺：—-&gt; 兑现 （resolve） 或 失信（rejected）<br>用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。它允许你为异步操作的成功和失败分别绑定相应的处理方法。这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。</p><p>一个 Promise有以下几种状态:<br>pending: 初始状态，既不是成功，也不是失败状态。<br>fulfilled: 意味着操作成功完成。<br>rejected: 意味着操作失败。</p><h4 id="创建Promise对象："><a href="#创建Promise对象：" class="headerlink" title="创建Promise对象："></a>创建Promise对象：</h4><p>var promise = new Promise( executor );<br>executor: 是一个函数，该函数在创建Promise对象的同时被调用执行。<br>executor:<br>语法：function(resolve, reject) {…}</p><ul><li>resolve：将Promise对象状态修改为 fulfilled，可以传递参数到then方法的第一个函数中</li><li>reject：将Promise对象状态修改为 rejected，可以传递参数到 then 方法的第二个函数中</li></ul><h4 id="API："><a href="#API：" class="headerlink" title="API："></a>API：</h4><ul><li><p>Promise.prototype.then(onfulfilled, onrejected) 方法：<br>— onfulfilled 绑定的是成功时执行的函数<br>— onrejected 绑定的是失败时执行的函数</p></li><li><p>Promise.all(iterable)<br>— iterable : 可迭代对象（数组）<br>— 返回Promise对象<br>— 当数组中所有Promise对象都完成时，回调执行成功的函数，当只要有一个执行失败时，就回调执行失败的函数。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">ajaxGetPromise : function(url, query, isJson)&#123;return new Promise(function(resolve, reject) &#123;// 拼接url加queryif(query) &#123;    url += "?";    for(var key in query)&#123;        url += key+"="+query[key]+"&";    &#125;    // 把最后一个&删掉    url = url.slice(0, -1);&#125;// 1、创建对象var ajax = new XMLHttpRequest();// 2、建立连接ajax.open("GET", url, true);// 3、发送请求ajax.send(null);// 4、监听状态的改变ajax.onreadystatechange = function()&#123;if(ajax.readyState === 4)&#123;    if(ajax.status === 200)&#123;        // 用户传了回调才执行        // isJson默认值为true，要解析json        if(isJson === undefined)&#123;            isJson = true;        &#125;        var res = isJson ? JSON.parse(ajax.responseText) : ajax.responseText;        resolve(res);    &#125;else&#123;        // 请求失败        reject();    &#125;&#125;&#125;&#125;)&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> cors </tag>
            
            <tag> jsonp </tag>
            
            <tag> promise </tag>
            
            <tag> 同步/异步 </tag>
            
            <tag> GET/POST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中的事件绑定、事件监听、事件委托</title>
      <link href="/posts/event-bind-listen-delegation.html"/>
      <url>/posts/event-bind-listen-delegation.html</url>
      
        <content type="html"><![CDATA[<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。</p><p>在JavaScript中，有三种常用的绑定事件的方法：</p><p>1.在DOM元素中直接绑定；<br>2.在JavaScript代码中绑定；<br>3.绑定事件监听函数。</p><h3 id="在DOM中直接绑定事件"><a href="#在DOM中直接绑定事件" class="headerlink" title="在DOM中直接绑定事件"></a>在DOM中直接绑定事件</h3><p>我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。好多不一一列出了。如果想知道更多事件类型请查看， DOM事件 。</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;hello()&quot;&gt;&lt;script&gt;function hello()&#123;alert(&quot;hello world!&quot;);&#125;&lt;/script&gt;</code></pre><h3 id="在JavaScript代码中绑定事件"><a href="#在JavaScript代码中绑定事件" class="headerlink" title="在JavaScript代码中绑定事件"></a>在JavaScript代码中绑定事件</h3><p>在JavaScript代码中（即 script 标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn&quot;).onclick = function()&#123;alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; </code></pre><h3 id="使用事件监听绑定事件"><a href="#使用事件监听绑定事件" class="headerlink" title="使用事件监听绑定事件"></a>使用事件监听绑定事件</h3><p>绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。下面详细介绍，事件监听。</p><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。</p><p>起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范。</p><h3 id="W3C规范"><a href="#W3C规范" class="headerlink" title="W3C规范"></a>W3C规范</h3><p>语法：</p><p>element.addEventListener(event, function, useCapture)</p><p>event : （必需）事件名，支持所有 DOM事件 。</p><p>function：（必需）指定要事件触发时执行的函数。</p><p>useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。</p><p>注：IE8以下不支持。</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn1&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn1&quot;).addEventListener(&quot;click&quot;,hello);function hello()&#123;alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; </code></pre><h3 id="IE标准"><a href="#IE标准" class="headerlink" title="IE标准"></a>IE标准</h3><p>语法：</p><p>element.attachEvent(event, function)</p><p>event：（必需）事件类型。需加“on“，例如：onclick。</p><p>function：（必需）指定要事件触发时执行的函数。</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn2&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn2&quot;).attachEvent(&quot;onclick&quot;,hello);function hello()&#123;alert(&quot;hello world!&quot;);&#125;&lt;/script&gt;</code></pre><h3 id="事件监听的优点"><a href="#事件监听的优点" class="headerlink" title="事件监听的优点"></a>事件监听的优点</h3><p>1、可以绑定多个事件。</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn3&quot;&gt;&lt;script&gt;var btn3 = document.getElementById(&quot;btn3&quot;);btn3.onclick = function()&#123;alert(&quot;hello 1&quot;); //不执行&#125;btn3.onclick = function()&#123;alert(&quot;hello 2&quot;); //执行&#125;&lt;/script&gt;//常规的事件绑定只执行最后绑定的事件。&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn4&quot;&gt;&lt;script&gt;var btn4 = document.getElementById(&quot;btn4&quot;);btn4.addEventListener(&quot;click&quot;,hello1);btn4.addEventListener(&quot;click&quot;,hello2);function hello1()&#123;alert(&quot;hello 1&quot;);&#125;function hello2()&#123;alert(&quot;hello 2&quot;);&#125;&lt;/script&gt;//两个事件都执行了。</code></pre><p>2、可以解除相应的绑定</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;&lt;script&gt;var btn5 = document.getElementById(&quot;btn5&quot;);btn5.addEventListener(&quot;click&quot;,hello1);//执行了btn5.addEventListener(&quot;click&quot;,hello2);//不执行btn5.removeEventListener(&quot;click&quot;,hello2);function hello1()&#123;    alert(&quot;hello 1&quot;);&#125;function hello2()&#123;    alert(&quot;hello 2&quot;);&#125;&lt;/script&gt;</code></pre><h3 id="封装事件监听"><a href="#封装事件监听" class="headerlink" title="封装事件监听"></a>封装事件监听</h3><pre><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;//绑定监听事件function addEventHandler(target,type,fn)&#123;    if(target.addEventListener)&#123;        target.addEventListener(type,fn);    &#125;else&#123;        target.attachEvent(&quot;on&quot;+type,fn);    &#125;&#125;//移除监听事件function removeEventHandler(target,type,fn)&#123;    if(target.removeEventListener)&#123;        target.removeEventListener(type,fn);    &#125;else&#123;        target.detachEvent(&quot;on&quot;+type,fn);    &#125;&#125;//测试var btn5 = document.getElementById(&quot;btn5&quot;);addEventHandler(btn5,&quot;click&quot;,hello1);//添加事件hello1addEventHandler(btn5,&quot;click&quot;,hello2);//添加事件hello2removeEventHandler(btn5,&quot;click&quot;,hello1);//移除事件hello1</code></pre><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn6&quot;&gt;var btn6 = document.getElementById(&quot;btn6&quot;);document.onclick = function(event)&#123;    event = event || window.event;    var target = event.target || event.srcElement;    if(target == btn6)&#123;        alert(btn5.value);    &#125;&#125;</code></pre><p>上面只是个例子，代码尽可能的简化了。在实际的代码中 我们可能用到jQuery的live()、delegate()、bind()、on()等。</p><h3 id="事件委托优点"><a href="#事件委托优点" class="headerlink" title="事件委托优点"></a>事件委托优点</h3><p>1、提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。</p><h4 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h4><pre><code>&lt;ul id=&quot;list&quot;&gt;  &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt;  &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt;  &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);item1.onclick = function()&#123;alert(&quot;hello item1&quot;);&#125;item2.onclick = function()&#123;alert(&quot;hello item2&quot;);&#125;item3.onclick = function()&#123;alert(&quot;hello item3&quot;);&#125;&lt;/script&gt;</code></pre><h4 id="事件委托-1"><a href="#事件委托-1" class="headerlink" title="事件委托"></a>事件委托</h4><pre><code>&lt;ul id=&quot;list&quot;&gt;  &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt;  &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt;  &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123;var target = event.target;if(target == item1)&#123;alert(&quot;hello item1&quot;);&#125;else if(target == item2)&#123;alert(&quot;hello item2&quot;);&#125;else if(target == item3)&#123;alert(&quot;hello item3&quot;);&#125;&#125;)&lt;/script&gt;</code></pre><p>2、动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。</p><h4 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h4><pre><code>&lt;ul id=&quot;list&quot;&gt;  &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt;  &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt;  &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);var item = list.getElementsByTagName(&quot;li&quot;);for(var i=0;i&lt;item.length;i++)&#123;(function(i)&#123;item[i].onclick = function()&#123;alert(item[i].innerHTML);&#125;&#125;)(i)&#125;var node=document.createElement(&quot;li&quot;);var textnode=document.createTextNode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; </code></pre><p>点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。</p><h4 id="事件委托-2"><a href="#事件委托-2" class="headerlink" title="事件委托"></a>事件委托</h4><pre><code>&lt;ul id=&quot;list&quot;&gt;  &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt;  &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt;  &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123;var target = event.target;if(target.nodeName == &quot;LI&quot;)&#123;alert(target.innerHTML);&#125;&#125;)var node=document.createElement(&quot;li&quot;);var textnode=document.createTextNode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt;</code></pre><p>当点击item4时，item4有事件响应。说明事件委托可以为新添加的DOM元素动态的添加事件。</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件绑定 </tag>
            
            <tag> 事件监听 </tag>
            
            <tag> 事件委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-面向对象（构造函数、原型）</title>
      <link href="/posts/object-oriented.html"/>
      <url>/posts/object-oriented.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h2><p>对象是类的实例，类是对象的抽象<br>对象的本质：属性和方法的集合<br>学过的对象<br>Array、String、Math、Date …….</p><h3 id="创建对象的方式："><a href="#创建对象的方式：" class="headerlink" title="创建对象的方式："></a>创建对象的方式：</h3><h4 id="1、字面量-var-obj"><a href="#1、字面量-var-obj" class="headerlink" title="1、字面量 var obj = {}"></a>1、字面量 var obj = {}</h4><h4 id="2、通过new运算符-var-obj-new-Object"><a href="#2、通过new运算符-var-obj-new-Object" class="headerlink" title="2、通过new运算符 var obj = new Object()"></a>2、通过new运算符 var obj = new Object()</h4><h4 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h4><p>用来构造（创建）对象的函数<br>他在声明的时候跟普通函数没有区别<br>用new运算符加上函数的调用，调用的结果就是一个对象<br>构造函数中的this指的是即将要new的那个对象<br>构造函数就是封装一个函数,可以用来通过new的方式得到一系列特征相同的对象</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Student(name)&#123;  //再构造函数里,this值即将要new的那个对象  //给this这个对象新增自定义属性和方法  this.name = name;  this.speak = function()&#123;    alert(this.name);    &#125;  &#125;let stu = new Student("xiaohong");//实例化对象  //关于使用new实例化对象时：发生了以下四件事情    //1.开辟申请一块空间来存储对象    //2.把this设置为当前对象    //3.设置属和方法的值    //4.将this对象返回  console.log(stu);  stu.speak();let stu1 = new Student("xiaohei");  console.log(stu1);  stu1.speak();</code></pre><h4 id="4、ES6语法糖（class…）"><a href="#4、ES6语法糖（class…）" class="headerlink" title="4、ES6语法糖（class…）"></a>4、ES6语法糖（class…）</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript">class Student &#123;  //构造  constructor (name) &#123;    this.name = name;  &#125;  //speak默认就在原型上  speak () &#123;    alert(this.name);  &#125;&#125;let stu = new Student("xiaogang");console.log(stu);//Student name: "xiaogang" __proto__: Objectstu.speak();</code></pre><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>原型是函数的伴生体</p><p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法</p><p>prototype（原型）属性指向的对象就是原型对象</p><p>js中万物皆对象，因此原型也是对象，可以通过原型实现对象属性的继承</p><p>实例化一个对象后该对象就有一个<strong>proto</strong>属性，且指向实例化对象的构造函数的prototype属性<br>创建一个函数后该函数就有一个prototype属性，且指向该函数的原型对象的<strong>proto</strong>属性</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> function fn(a,b)&#123;&#125; console.dir(fn); function Student(name)&#123;     this.name = name;     this.speak = function()&#123;         alert(this.name);     &#125; &#125; //Student的原型对象 Student.prototype.say = function()&#123;     alert("I am" + this.name); &#125; Student.prototype.age = 18; let stu = new Student("xiaohong"); let stu1 = new Student("xiaohei"); console.log(stu.speak === stu1.speak); //stu.say(); //stu1.say(); console.log(stu.say === stu1.say); console.dir(Student); console.log(stu, stu1); //原型链 console.log(stu.__proto__ === Student.prototype); console.log(Student.prototype.__proto__ === Object.prototype); let str = stu.toString(); console.log(str);</code></pre><p>对于上面js代码里的原型链解释如链接图所示：<br><a href="https://upload-images.jianshu.io/upload_images/15859737-d8659a4ce2872ad0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp">https://upload-images.jianshu.io/upload_images/15859737-d8659a4ce2872ad0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp</a><br>也证明了函数作为特殊的对象，是函数也是对象，即万物皆是对象。</p><h3 id="几个必记的属性和方法"><a href="#几个必记的属性和方法" class="headerlink" title="几个必记的属性和方法"></a>几个必记的属性和方法</h3><p>constructor prototype里面的constructor指向当前对象的构造函数</p><p>proto === [[prototype]] 指向父类的prototype</p><p>prototype 指向当前对象的原型对象</p><p>instanceof 运算符，判断当前对象是否是另一个对象的实例</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Fn()&#123;&#125;//var Fn = new Function();//console.dir(Fn);//console.log(Fn.__proto__ === Function.prototype)console.log(Fn instanceof Function); //trueconsole.log(Fn instanceof Object); //truevar fn = new Fn();console.log(fn instanceof Fn);console.log(fn instanceof Function); //false 原型链没有指向Functionconsole.log(fn instanceof Object);</code></pre><p>hasOwnProperty 判断对象上是否存在某个属性，并且这个方法会过滤到原型上的属性</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Student (name)&#123;    this.name = name;&#125;Student.prototype.say = function()&#123;    alert(this.name);&#125;var stu = new Student("xiaohong");console.log(stu.hasOwnProperty("name")); //nameconsole.log(stu.hasOwnProperty("say")); //falseconsole.log(stu.hasOwnProperty("speak")); //false</code></pre><p>isPrototypeOf 检查一个对象是否存在于另一个对象的原型链上</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Student (name)&#123;    this.name = name;&#125;Student.prototype.say = function()&#123;    alert(this.name);&#125;var stu = new Student("xiaohong");console.log(Student.prototype.isPrototypeOf(stu)) // true   console.log(Function.prototype.isPrototypeOf(stu)) // falseconsole.log(Object.prototype.isPrototypeOf(stu)) // true</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1.改写面向对象程序，要让所有函数不能嵌套；<br>2.提取变量，让函数正常运行；<br>3.改写面向对象，将方法写在prototype上；<br>4.注意this指向问题。</p><h2 id="对象的三大特点（封装、继承、多态）"><a href="#对象的三大特点（封装、继承、多态）" class="headerlink" title="对象的三大特点（封装、继承、多态）"></a>对象的三大特点（封装、继承、多态）</h2><h3 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h3><p>1、写对象<br>2、用对象<br>把一些相关的对象和属性放到一起即封装到一起，用一个变量抽象出来，那么这就完成了这个对象的封装</p><h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>子对象可以使用父对象的一些属性和方法</p><h3 id="多态：又分为重载-和-重写"><a href="#多态：又分为重载-和-重写" class="headerlink" title="多态：又分为重载 和 重写"></a>多态：又分为重载 和 重写</h3><p>重载就是根据不同的参数类型，参数个数实现不同的功能</p><p>重写就是父类的方法不好用，我自己重新定义一个方法名相同的不同方法（方法名相同但方法体不同）</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 原型 </tag>
            
            <tag> 封装 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-ES6</title>
      <link href="/posts/es6.html"/>
      <url>/posts/es6.html</url>
      
        <content type="html"><![CDATA[<h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>块级作用域：一种普遍存在于各个语言中的作用域范围；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">    &#123;      var a = 10;      let b = 20;     &#125;     console.log(a)//10     console.log(b)// b is not defined</code></pre><p>在一个大括号中用let声明的变量在外部不可访问了，每个大括号都是独立的作用域</p><p>有了let声明我们在函数外部就无法访问到 i ，i作为下标只存在于for循环中， 所以，这个时候每个i都是独立的；我们在点击的时候可以轻易的获取当前元素的下标，而不用做很多繁琐的处理了</p><pre><code>var aLi = document.querySelectorAll(&quot;li&quot;);for(let i = 0;i&lt;aLi.length;i++)&amp;#123;  aLi[i].onclick = function()&amp;#123;    alert(i);  &amp;#125;  console.log(i);//0  1  2  3&amp;#125;</code></pre><p>JS中var声明一个变量是存在声明提升的，这是JS中的一个缺陷所在， 但是现在的let不存在声明提升</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">        // console.log(a);//undefined        // console.log(b);//b is not defined        // var a = 10;        // let b = 20;        let a = 20;        function foo()&#123;            console.log(a);            let a = 10;        &#125;        foo();//a is not defined        //报错,暂时性死区        //js预编译的时候发现有一个局部的a,所以就不会再去寻找全局的a        //但是在执行的时候他发现局部的a在后面let声明的,所以报错</code></pre><p>ES6规定在某个区块中， 一旦用let或const声明一个变量，那么这个区块就变成块级作用域，用let 或者const声明的变量即为该区块绑定， 该变量不受任何变量影响。 在该变量使用let声明前不可以用。在语法上，我们叫这种情况为：暂时性死区 (temporal dead zone，简称 TDZ)</p><h3 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h3><p>声明常量:</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const a = 20;//常量:不能被修改的量a = 30;    //Uncaught TypeError:Assignment to constant variable.(未捕获的类型错误:赋值给常量变量)</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">console.log(Math.PI);//3.141592653589793        Math.PI = 4;        console.log(Math.PI);//3.141592653589793</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">const arr = [2,3,4,5];        //arr = [3,4,4,6];        //不能修改数组或对象的引用,但是可以通过API取修改内部结构        arr.push(6,7);        console.log(arr);//[2, 3, 4, 5, 6, 7]</code></pre><h2 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符 …"></a>扩展运算符 …</h2><p>三个点号，功能是把数组或类数组对象展开成一系列用逗号隔开的值</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [1,2,3,4,5];        console.log(arr);//Array(5)        console.log(...arr);//1 2 3 4 5   console.log 不会显示逗号，中间其实是有逗号的        function add(arr)&#123;            arr.pop();            console.log(arr);        &#125;</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript"> var foo = function(a, b, c) &#123;console.log(a);console.log(b);console.log(c);&#125;var arr = [1, 2, 3];//传统写法foo(arr[0], arr[1], arr[2]);//使用扩展运算符foo(...arr);//1//2//3</code></pre><h2 id="rest运算符"><a href="#rest运算符" class="headerlink" title="rest运算符"></a>rest运算符</h2><p>rest运算符也是三个点号，不过其功能与扩展运算符恰好相反，把逗号隔开的值序列组合成一个数组</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> //主要用于不定参数，所以ES6开始可以不再使用arguments对象var bar = function(a, ...args) &#123;    console.log(a);    console.log(args);&#125;bar(1, 2, 3, 4);//1//[ 2, 3, 4 ]</code></pre><h2 id="字符串扩展-了解"><a href="#字符串扩展-了解" class="headerlink" title="字符串扩展(了解)"></a>字符串扩展(了解)</h2><p>1.字符串的 Unicode 表示; 规则为\u + 四位十六进制;</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> //例如: console.log("\u0061");</code></pre><p>打印结果是 a；</p><p>这种新的字符表示方式只能表示 \u 0000 ~ \u ffff 之间的数字。 如果超出范围必须用双字节表示;</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  console.log("\uD842\uDFB6");</code></pre><p>打印结果是 𠮶<br>如果不按照规则熟悉书写 例如 console.log(“\uD842\uDFB69”)<br>这个9是多余字符； 那么则认为这段字符是 \uD842\uDFB6 + 9 所以打印结果是 𠮶9；</p><p>如果想要一次性表示超出范围的字符那么我们可以使用{}来表示；<br>例如:<br>console.log(“\u20BB9”); 这个的打印结果是 拆分开来的 ₻9<br>console.log(“\u{20BB9}”); 这个打印的结果是一个完整的字符</p><p>ES6支持多种格式的字符表示;</p><h2 id="字符串模板扩展："><a href="#字符串模板扩展：" class="headerlink" title="字符串模板扩展："></a>字符串模板扩展：</h2><p>ES6中存在一种新的字符串， 这种字符串是 以 (波浪线上的那个字符 &gt; 反引号)括起来表示的；</p><p>通常我们想要拼接一个带有标签的字符串， 是用这样的方式:</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">      bianliang + " <strong>这是一个文字" + obj.name + "</strong> " + bianliang</code></pre><p>但是有了ES6字符串一切都变得非常简单了;</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">      `  $&#123;bianliang&#125; <strong>这是一个文字$&#123;obj.name&#125;</strong>$&#123;bianliang&#125; `</code></pre><p>用 ${ } 扩住变量让拼接变得非常容易;<br>非常简单的换行；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">      `In JavaScript \n is a line-feed.`           console.log(`string text line 1      string text line 2`);</code></pre><p>当我们想要在字符串中使用 `反引号的时候我们需要进行转义；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">      `\`Yo\` World!`    //"`Yo` World!"</code></pre><p>模板还可以调用函数；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">      function fn() &#123;      return "Hello World";&#125;      `foo $&#123;fn()&#125; bar`</code></pre><h2 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法:"></a>字符串的新增方法:</h2><h3 id="repeat-重复功能"><a href="#repeat-重复功能" class="headerlink" title="repeat()重复功能"></a>repeat()重复功能</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript"> 'x'.repeat(3)  //xxx；  重复字符串;</code></pre><h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes() startsWith() endsWith();"></a>includes() startsWith() endsWith();</h3><p>判定字符串中是否存在某个字符串;</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var s = 'Hello world!';s.startsWith('Hello') // true   以参数开头s.endsWith('!') // true            以参数结尾s.includes('o') // true             包括参数;</code></pre><p>第二种方法接受第二个参数，第二个参数表示从第几位开始;</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  var s = 'Hello world!';  s.startsWith('world', 6) // true  s.endsWith('Hello', 5) // true  s.includes('Hello', 6) // false</code></pre><h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h2><p>一种新的遍历方式;<br>for of 可以用于遍历字符串：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">      var s = "abc";      for(let  b of s)&#123;           console.log(b) // "a"  "b"  "c"       &#125;</code></pre><h2 id="gt-箭头函数"><a href="#gt-箭头函数" class="headerlink" title="=&gt;箭头函数"></a>=&gt;箭头函数</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">var test = function(x)&#123;    return x+2;&#125;</code></pre><p>使用箭头函数： var test = x =&gt;x+2;<br>var 函数名 = 参数 =&gt; 运算规则;</p><p>如果箭头函数只有一个形参,那么可以省略小括号</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">    var foo = str => &#123;    console.log(str);            &#125;</code></pre><p>如果函数体只有一句话,那么可以省略大括号</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">    var foo = str => console.log(str);</code></pre><p>如果只有一句话,并且这句话就是return,可以省略return关键字</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var foo = str => str+"abc";console.log(foo("fooo"));</code></pre><p>箭头函数会自动绑定this(箭头函数没有自己的this)</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">document.querySelector("button").onclick = function()&#123;                setTimeout(() => &#123;                    console.log(this);                &#125;,1000);            &#125;</code></pre><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>第一： 箭头函数是不能new的，它的设计初衷就跟构造函数不太一样<br>第二： 箭头函数如果要返回一个JSON对象，必须用小括号包起来 var test = ()=&gt;({id:3, val=20})</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var obj = &#123;name:"lisi", age:80, gender: "female"&#125;;            var &#123;age, name, gender="male"&#125; = obj;            console.log(age, name, gender); var json = [    &#123;name:"lisi", age:80, gender: "female"&#125;,    &#123;name:"liwu", age:70, gender: "male"&#125;,    &#123;name:"liliu", age:60, gender: "female"&#125;        ]var [&#123;age&#125;,&#123;name&#125;,&#123;gender&#125;] = json;    //var &#123;name&#125; = b;    console.log(name);</code></pre><h2 id="Symbol类型-第六种基本数据类型Symbol"><a href="#Symbol类型-第六种基本数据类型Symbol" class="headerlink" title="Symbol类型 第六种基本数据类型Symbol"></a>Symbol类型 第六种基本数据类型Symbol</h2><p>Symbol函数会生成一个唯一的值可以理解为Symbol类型跟字符串是接近的 但每次生成唯一的值，也就是每次都不相等，至于它等于多少，并不重要 这对于一些字典变量，比较有用</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var s1 = Symbol();var s2 = Symbol();var s3 = Symbol("abc");var s4 = Symbol("abc");s1不等于s2s3不等于s4</code></pre><h3 id="利用Symbol类型的案例：点击div变色"><a href="#利用Symbol类型的案例：点击div变色" class="headerlink" title="利用Symbol类型的案例：点击div变色"></a>利用Symbol类型的案例：点击div变色</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var obj =&#123;                red: Symbol(),                blue: Symbol(),                green: Symbol(),                yellow: Symbol()            &#125;            var color = obj.red;            //适用于只需要关心状态(属于哪个状态)            //但是不用知道内部结构(不关心值为多少)            document.querySelector("div").onclick = function()&#123;                if(color === obj.red)&#123;                    this.style.background = "blue";                    color = obj.blue;                &#125;else if(color === obj.blue)&#123;                    this.style.background = "green";                    color = obj.green;                &#125;else if(color === obj.green)&#123;                    this.style.background = "yellow";                    color = obj.yellow;                &#125;else if(color === obj.yellow)&#123;                    this.style.background = "red";                    color = obj.red;                &#125;            &#125;</code></pre><h2 id="Set和Map结构"><a href="#Set和Map结构" class="headerlink" title="Set和Map结构"></a>Set和Map结构</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Set集合是默认去重复的，但前提是两个添加的元素严格相等 所以5和”5”不相等，两个new出来的字符串不相等</p><p>Set集合，本质上就是对数组的一种包装 例如：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> let imgs = new Set();imgs.add(1）;imgs.add(1）;imgs.add(5）;imgs.add("5"）;imgs.add(new String("abc")）;imgs.add(new String("abc")）;// 打印的结果： 1  5  '5'  'abc'  'abc'</code></pre><p>下面展示了一种极为精巧的数组去重的方法</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var newarr = [...new Set(array)];</code></pre><h4 id="set集合遍历"><a href="#set集合遍历" class="headerlink" title="set集合遍历:"></a>set集合遍历:</h4><p>1.根据KEY遍历</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> var imgs = new Set(['a','b','c']);  //根据KEY遍历for(let item of imgs.keys())&#123;    console.log(item);&#125; //a //b //c</code></pre><p>2.根据VALUE遍历</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> //根据VALUE遍历for(let item of imgs.values())&#123;    console.log(item);&#125; //a //b //c</code></pre><p>3.根据KEY-VALUE遍历</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">for(let item of imgs.entries())&#123;    console.log(item); &#125; //['a','a'] //['b','b'] //['c','c']</code></pre><p>4.普通for…of循环</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> //普通for...of循环(for...of跟for-in的区别很明显，就是直接取值，而不再取下标了)for(let item of imgs)&#123;    console.log(item);&#125; //a //b //c</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map集合,即映射</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> let map = new Map();map.set("S230", "张三");map.set("S231", "李四");map.set("S232", "王五");map.get("s232"); // 获取某一个元素   王五for(let [key,value] of map)&#123;console.log(key,value);&#125; //循环遍历，配合解构赋值</code></pre><h2 id="class的写法-语法糖-了解"><a href="#class的写法-语法糖-了解" class="headerlink" title="class的写法 语法糖(了解)"></a>class的写法 语法糖(了解)</h2><p>Class保留字终于成了关键字<br>以前编写一个构造函数（类）</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Pad(color)&#123;    this.color = color;&#125;</code></pre><p>现在的写法跟Java更接近了</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">class Iphone&#123;    constructor(color, size)&#123;            this.color = color;            this.size = size;         &#125;    playgame()&#123;           //.............    &#125;    toString()&#123;          return `这台手机的颜色是$&#123;this.color&#125; 屏幕大小是$&#123;this.size&#125;`;    &#125;&#125;</code></pre><p>我们定义了一个类，名字叫Iphone 通过类生成一个实例： var iphone = new Iphone(“白色”, 5);</p><p>其中constructor被称之为构造方法，在我们new 一个对象的时候，自动被调用</p><p>不过本质上，JS依然使用了原型来实现，也就是说，这不过是一个新的写法而已 跟以前的构造函数没有区别。</p><p>要注意的是，使用了class来定义类，必须先定义再使用</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> let/const </tag>
            
            <tag> 箭头函数 </tag>
            
            <tag> 扩展运算符··· </tag>
            
            <tag> symbol类型 </tag>
            
            <tag> set/map </tag>
            
            <tag> class语法糖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-ES5</title>
      <link href="/posts/es5.html"/>
      <url>/posts/es5.html</url>
      
        <content type="html"><![CDATA[<h2 id="ES5严格模式（strict-mode）"><a href="#ES5严格模式（strict-mode）" class="headerlink" title="ES5严格模式（strict mode）"></a>ES5严格模式（strict mode）</h2><p>顾名思义，这种模式使得Javascript在更严格的条件下运行。<br>-消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>-消除代码运行的一些不安全之处，保证代码运行的安全；<br>-提高编译器效率，增加运行速度；<br>-为未来新版本的Javascript做好铺垫。</p><h3 id="进入严格模式-“use-strict”"><a href="#进入严格模式-“use-strict”" class="headerlink" title="进入严格模式 “use strict”"></a>进入严格模式 “use strict”</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">"use strict"console.log("已经进入严格模式");</code></pre><h3 id="严格模式行为变更："><a href="#严格模式行为变更：" class="headerlink" title="严格模式行为变更："></a>严格模式行为变更：</h3><p>1.全局变量声明时 必须加var</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">"use strict"a = 10;//报错 因为 a没有被var 声明//Uncaught ReferenceError: a is not defined; 引用错误： a 没有被声明</code></pre><p>2.this 无法指向全局对象</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">"use strict"// console.log("已经进入严格模式");function a()&#123;  this.b = 10; //报错 ， 因为this指向了window对象;  //Uncaught TypeError: Cannot set property 'b' of undefined;   //类型错误 ： 不能给undefined设置属性b；&#125;window.a()；</code></pre><p>3.函数内重名属性</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">"use strict";function a(b,b,c)&#123; //报错// Uncaught SyntaxError: Duplicate parameter name not allowed in this context;语法错误：在此上下文中不允许重复的参数名称&#125;</code></pre><p>4.arguments对象;</p><p>4.1 arguments对象不允许被动态改变;</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function fn1(a) &#123;        a = 2;        return [a, arguments[0]];    &#125;    console.log(fn1(1)); // 正常模式为[2,2]    function fn2(a) &#123;        "use strict";        a = 2;        return [a, arguments[0]];    &#125;    console.log(fn2(1)); // 严格模式为[2,1]</code></pre><p> 4.2 arguments对象不允许被自调用;</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">"use strict";        var f = function() &#123; return arguments.callee; &#125;;        f(); // 报错        //Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them        //类型错误：“caller ”，“arguments.callee ”，不能在严格模式中使用;        //caller返回调用当前函数的函数的引用  （正在执行的函数的属性）       // callee返回正在执行的函数本身的引用 （arguments的属性）</code></pre><p>5.新增保留字； implements, interface, let, package, private, protected, public, static, yield。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">"use strict";function package(protected) &#123; // 语法错误    var implements; // 语法错误&#125;package();</code></pre><h2 id="ES5新增常见方法"><a href="#ES5新增常见方法" class="headerlink" title="ES5新增常见方法"></a>ES5新增常见方法</h2><p>数组：<br>2个索引方法：indexOf() 和 lastIndexOf()；<br>5个迭代方法：forEach()、map()、filter()、some()、every()；<br>2个归并方法：reduce()、reduceRight()；</p><h3 id="reduce去重："><a href="#reduce去重：" class="headerlink" title="reduce去重："></a>reduce去重：</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [12,12,32,43,5,5,34,43,4,6,4];        var arr1 = arr.reduce(function(prev,next)&#123;            if(!prev.includes(next))&#123;                prev.push(next);            &#125;            return prev;        &#125;,[])        console.log(arr1);//[12, 32, 43, 5, 34, 4, 6]</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串:"></a>字符串:</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">trim();// 去掉字符串前后空格trimLeft()trimRIght()var reg = /(^\s*)|(\s*$)/gstr.replace(reg,"");</code></pre><p>JSON.parse(str); //json序列化，将符合json格式的字符串转换为json</p><p>JSON.stringify(); //json转换为字符串</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">        var data = [            &#123;"name":"zhangsan","age":20&#125;,            &#123;"name":"zhangsan","age":20&#125;,        ]        var str = JSON.stringify(data);//json转换为字符串        console.log(str);//[&#123;"name":"zhangsan","age":20&#125;,&#123;"name":"zhangsan","age":20&#125;]//json序列化，将符合json格式的字符串转换为json        var date1 = JSON.parse('[&#123;"name":"zhangsan","age":20&#125;,&#123;"name":"zhangsan","age":20&#125;]');        console.log(date1);</code></pre><p>Date.now(); //日期对象得到当前日期的毫秒数</p><p>Object.defineProperties(obj, props); //给obj设置属性</p><p>Object.keys(obj); //获取obj的所有属性名称，返回数组</p><p>Object.values(obj); // 获取obj的所有属性值，返回数组</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var obj = new Object();Object.defineProperty(obj, 'name', &#123;configurable: false, // 表示能否通过delete删除此属性writable: true, // 能否修改属性的值enumerable: true, // 表示该属性是否可枚举，即是否通过for-in循环或Object.keys()返回属性value: '张三'&#125;)console.log(obj.name)//张三</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">var obj = new Object();Object.defineProperties(obj, &#123;     name: &#123;        value: '张三',        configurable: false,        writable: true,        enumerable: true    &#125;,     age: &#123;        value: 18,        configurable: true    &#125;&#125;)console.log(obj.name, obj.age) // 张三, 18</code></pre><p>Object.assign 对象合并,相同属性后面的生效</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var obj = &#123;"name":"lisi"&#125;;var obj1 = &#123;"age":20,"name":"zhangsi"&#125;;var obj2 = Object.assign(obj,obj1);//对象合并,相同属性后面的生效.覆盖前面的相同属性console.log(obj2);</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5 </tag>
            
            <tag> 严格模式 </tag>
            
            <tag> arguments </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS冒泡选择快速排序</title>
      <link href="/posts/js-sort-method.html"/>
      <url>/posts/js-sort-method.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS冒泡排序（必须掌握思想和必须会代码默写）（面试最常考）"><a href="#JS冒泡排序（必须掌握思想和必须会代码默写）（面试最常考）" class="headerlink" title="JS冒泡排序（必须掌握思想和必须会代码默写）（面试最常考）"></a>JS冒泡排序（必须掌握思想和必须会代码默写）（面试最常考）</h2><p>原理：依次比较相邻的两个值，如果后面的比前面的小，则将小的元素排到前面。依照这个规则进行多次并且递减的迭代，直到顺序正确。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr=[8,94,15,88,55,76,21,39];function sortarr(arr)&#123;    for(i=0; i < arr.length-1; i++)&#123;        for(j=0; j < arr.length-1-i; j++)&#123;            if(arr[j] > arr[j+1])&#123;                var temp = arr[j];                arr[j] = arr[j+1];                arr[j+1] = temp;            &#125;        &#125;    &#125;    return arr;&#125;sortarr(arr);console.log(arr);</code></pre><p>解析<br>两个循环<br>当i=0的时候，里面的循环完整执行，从j=0执行到j=6,这也就是第一遍排序，结果是将最大的数排到了最后，这一遍循环结束后的结果应该是[8,15,88,55,76,21,39,94]<br>当i=1的时候，里面的循环再次完整执行，由于最大的数已经在最后了，没有必要去比较数组的最后两项，这也是j&lt;arr.length-1-i的巧妙之处，结果是[8,15,55,76,21,39,88,94]<br>说到这里，规律就清楚了，每次将剩下数组里面最大的一个数排到最后面，当第一个循环执行到最后的时候，也就是i=6,此时，j=0,只需要比较数组的第一和第二项，比较完毕，返回。</p><h2 id="JS选择排序（了解思想和必须会代码默写）（面试最常考）"><a href="#JS选择排序（了解思想和必须会代码默写）（面试最常考）" class="headerlink" title="JS选择排序（了解思想和必须会代码默写）（面试最常考）"></a>JS选择排序（了解思想和必须会代码默写）（面试最常考）</h2><p>原理：首先从原始数组中找到最小的元素，并把该元素放在数组的最前面，然后再从剩下的元素中寻找最小的元素，放在之前最小元素的后面，直到排序完毕。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr=[8,94,15,88,55,76,21,39];function selectSort(arr)&#123;    var minIndex,temp;    for(i = 0; i < arr.length-1; i++)&#123;        minIndex=i; //设置最小数的下标为当前的i        for(j = i+1; j < arr.length; j++)&#123;            if(arr[j] < arr[minIndex])&#123;                minIndex = j;            &#125;        &#125;    temp = arr[i];    arr[i] = arr[minIndex];    arr[minIndex] = temp;    &#125;    return arr;&#125;console.log(selectSort(arr));</code></pre><p>解析<br>minIndex始终保存着最小值的位置的索引，随着i的自增，遍历的数组长度越来越短，直到完成排序。</p><h2 id="JS快速排序（了解思想和了解代码）"><a href="#JS快速排序（了解思想和了解代码）" class="headerlink" title="JS快速排序（了解思想和了解代码）"></a>JS快速排序（了解思想和了解代码）</h2><p>原理<br>从数组中选定一个基数，然后把数组中的每一项与此基数做比较，小的放入一个新数组，大的放入另外一个新数组。然后再采用这样的方法操作新数组。直到所有子集只剩下一个元素，排序完成。</p><pre><code>var arr=[8,94,15,88,55,76,21,39];  function fastsort(arr)&#123;    if(arr.length&lt;2)&#123;        return arr;    &#125;    var left=[];    var right=[];    var pivotIndex=Math.floor(arr.length/2);    var pivot=arr.splice(pivotIndex,1)[0];    for(i=0;i&lt;arr.length;i++)&#123;        if(arr[i]&lt;pivot)&#123;            left.push(arr[i]);        &#125;else&#123;            right.push(arr[i])        &#125;    &#125;    return fastsort(left).concat([pivot],fastsort(right));  &#125;  console.log(fastsort(arr));</code></pre><p>解析<br>pivotIndex是将数组的长度除2向下取整得到的一个数值，数组的长度是不断减半的，所以最后它的值为0<br>pivot是利用splice方法从数组里获取一个基数</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 选择排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件流</title>
      <link href="/posts/js-event-flow.html"/>
      <url>/posts/js-event-flow.html</url>
      
        <content type="html"><![CDATA[<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>Netscape认为，石头先扔进河里，再从河里确定了一个扔石头的点，从外往内逐渐精确的过程（捕获）</p><p>w3c认为，石头扔进去先到达准确的那个点，涟漪从内往外扩散（冒泡）</p><p>事件流：事件执行的顺序</p><p>子元素的事件被触发时，父级也会被触发（冒泡）</p><p>一个完整事件包含  捕获阶段 —-&gt; 目标阶段  —-&gt;冒泡阶段</p><p>冒泡是可以阻止的</p><pre><code> e.stopPropagation( ); e.cancelBubble=true;//兼容IE</code></pre><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>DOM0级事件处理，是一种赋值方式，是被所有浏览器所支持的，简单易懂容易操作；</p><p>DOM2级事件处理是所有DOM节点中的方法，可以重复绑定，但是浏览器兼容存在问题；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//DOM0级oDiv.onclick = function()&#123; .... &#125;    //DOM2级if(window.attachEvent)&#123;    oDiv.attachEvent("onclick", function()&#123; ... &#125;);  // IE只有冒泡阶段,所以没有第三个参数，而且需要加on；&#125;else&#123;    oDiv.addEventListener( "click", function()&#123; ... &#125;,false);  // false指冒泡阶段&#125;//移除事件监听，第二个参数为必须，移除的事件处理函数oDiv.removeEventListener( "click",fn）oDiv.detachEvent("onclick",fn)</code></pre><h3 id="事件委托（事件代理）委派"><a href="#事件委托（事件代理）委派" class="headerlink" title="事件委托（事件代理）委派"></a>事件委托（事件代理）委派</h3><p>什么是事件委托：全班同学都要做《五年高考三年模拟》，每个同学自己去书店买？不用，委托老师帮你们买，同学们只管认真做题就好啦，好开心。</p><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以处理某一类型的所有事件<br>使用场景主要用于事件源不确定的情况，可以把事件委托给父级</p><p>判断事件源：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">e.target || e.srcElement</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件流 </tag>
            
            <tag> 冒泡 </tag>
            
            <tag> 捕获 </tag>
            
            <tag> 监听 </tag>
            
            <tag> 委托/代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件2</title>
      <link href="/posts/js-event-2.html"/>
      <url>/posts/js-event-2.html</url>
      
        <content type="html"><![CDATA[<h3 id="事件的原理"><a href="#事件的原理" class="headerlink" title="事件的原理"></a>事件的原理</h3><p>事件的原理和hover类似。可以做到:hover做不到的事，:hover只能操作当前的元素，但是事件绑定之后可以选择任何元素。</p><p>事件触发三要素：通过谁触发？ 通过什么触发？触发后要做什么？</p><p>事件的写法：</p><p>w3c标准：事件写在行内，但是因为结构和行为要分离，所以我们一般情况下用JavaScript的方法来绑定事件，只有再极少数情况下，才将事件写在行内，事件的绑定方法：</p><pre><code> 浏览器中的节点(对象).on+事件句柄 = function( )&#123;      干什么？（放在浏览器中，不执行，当事件发生的时候再执行。） &#125; oDiv.onclick=function()&#123;           alert（1） &#125;</code></pre><p>事件总结：事件是给浏览器定义一个预处理函数，当事件触发的时候，执行函数，这就是事件。</p><p>当事件被触发的时候奥特曼会得到一个信息（事件对象），包含了跟事件相关的一些属性和方法的封装（如：事件发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态等），只有事件在触发的时候才会得到。</p><pre><code> oDiv.onmousedown=function(e)&#123;      alert（e）; &#125;</code></pre><p>JS缺德定律：事件对象有兼容问题；<br>所以我们先做好兼容再去使用事件对象：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">e=e || window.event;alert (e.buttons)观察.buttons的返回值；</code></pre><h4 id="鼠标事件及方法；"><a href="#鼠标事件及方法；" class="headerlink" title="鼠标事件及方法；"></a>鼠标事件及方法；</h4><p>e.buttons<br>返回鼠标点击按键（1左键，2右键，4中键滚轮）</p><p>e.offsetX / offsetY<br>获取事件触发最近的盒子（事件源）的坐标</p><p>e.clientX / clientY<br>获取可视区的坐标（根据浏览器的定位）</p><p>e.screenX / screenY<br>获取整个屏幕的坐标</p><p>e.pageX / e.pageY<br>获取文档的坐标（包含滚动条）</p><h4 id="键盘事件：keydown、keyup、keypress"><a href="#键盘事件：keydown、keyup、keypress" class="headerlink" title="键盘事件：keydown、keyup、keypress"></a>键盘事件：keydown、keyup、keypress</h4><p>document.onkeydown = function(e){<br>     console.log(e.keyCode)<br>}<br>键盘上每一个键都有一个唯一的编码，用来识别当前用户正在操作的是键盘上哪一个键</p><p>有兼容问题<br>e.keyCode || e.which</p><p>特殊键码：是否按下alt  ctrl  和 shift<br>e.altKey</p><p>e.ctrlKey</p><p>e.shiftKey</p><p>返回值是布尔值；</p><p>可以用来判断组合键</p><p>if（e.keyCode==13&amp;&amp;e.altKey）{<br>     alert(‘同时按下了enter和alt’)；<br>}</p><h4 id="默认行为（浏览器）"><a href="#默认行为（浏览器）" class="headerlink" title="默认行为（浏览器）"></a>默认行为（浏览器）</h4><p>有一些html元素默认的行为，比如说a标签，点击后有跳转动作；form表单中的submit类型的input有一个默认提交跳转事件；reset类型的input有重置表单行为。</p><p>但是，有些时候我们是不需要默认事件的，所以就需要阻止默认事件</p><p>return false；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">if(e.preventDefault) &#123;   e.preventDefault();&#125;else &#123;    window.event.returnValue = false;        //return false;&#125;</code></pre><p>1、右键菜单（上下文菜单）  oncontextmenu<br>2、表单提交事件 onsubmit</p><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>子元素的事件被触发时，父级也会被触发（冒泡）<br>一个完整事件流包含  捕获阶段 —-&gt; 目标阶段  —-&gt;冒泡阶段</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鼠标/键盘事件 </tag>
            
            <tag> 阻止默认浏览器事件 </tag>
            
            <tag> 事件流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件</title>
      <link href="/posts/js-event-1.html"/>
      <url>/posts/js-event-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS运行和编译"><a href="#JS运行和编译" class="headerlink" title="JS运行和编译"></a>JS运行和编译</h2><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>查找基本语法有没有错误</p><h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><p>执行之前进行预解析<br>var、function关键字提前到当前作用域的顶部，变量默认值为undefined，函数默认值为函数体代码块，当函数与变量重名时，保留函数。</p><h2 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h2><p>全局变量的生命周期直至浏览器卸载页面才会结束。<br>局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="用户的行为：onclick、ondblclick、onfocus、onblur、window-onload"><a href="#用户的行为：onclick、ondblclick、onfocus、onblur、window-onload" class="headerlink" title="用户的行为：onclick、ondblclick、onfocus、onblur、window.onload"></a>用户的行为：onclick、ondblclick、onfocus、onblur、window.onload</h3><p>是用户跟页面的交互，当用户跟页面进行一些“交流”的时候，页面通过js就会触发一些事件，比如鼠标点击的时候就会触发onclick事件，给这个事件绑定一个函数，那么这个时候函数就会被调用，代码就会被执行</p><h3 id="事件类型："><a href="#事件类型：" class="headerlink" title="事件类型："></a>事件类型：</h3><p>鼠标事件：click，dbclick，mousedown，mouseup，mouseover，mouseout，mouseenter、     mouseleave、mousemove<br>鼠标滚轮：scroll，mousewheel<br>鼠标右键（上下文菜单：在不同环境下右键菜单不一样）：contextmenu<br>  mouseover：鼠标在元素身上移动穿过子元素的时候会被反复触发<br>  mouseenter：只是在进入元素的时候触发<br>键盘事件：keydown，keyup，keypress<br>表单事件：对表单元素操作之后会触发的事件<br>  单选框、多选框、下拉菜单 状态改变的时候会触发  onchange 事件<br>  表单提交的时候会触发 onsubmit ，触发在<form>元素身上</form></p><h2 id="this关键字-事件函数里面的this指的是事件触发对象"><a href="#this关键字-事件函数里面的this指的是事件触发对象" class="headerlink" title="this关键字:事件函数里面的this指的是事件触发对象"></a>this关键字:事件函数里面的this指的是事件触发对象</h2>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
            <tag> 事件 </tag>
            
            <tag> 变量生命周期 </tag>
            
            <tag> 运行编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的node节点</title>
      <link href="/posts/js-node.html"/>
      <url>/posts/js-node.html</url>
      
        <content type="html"><![CDATA[<h3 id="node节点（更详细的获取（设置）页面中所有的内容）"><a href="#node节点（更详细的获取（设置）页面中所有的内容）" class="headerlink" title="node节点（更详细的获取（设置）页面中所有的内容）"></a>node节点（更详细的获取（设置）页面中所有的内容）</h3><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：<br>元素是节点的别称，节点包含元素当然节点还有好多细化的种类；<br>根节点：root&gt;&gt;&gt;&gt;HTML没有父节点；<br>节点操作：（通过父子系关系）<br>childNodes     获取当前元素的所有子节点；<br>nodeType       节点种类，返回值是数字；<br>nodeValue      获取（文字）节点的文本内容；<br>nodeName     返回node节点名称（#text，注释， 标签….）；<br>一个可以找出元素节点的方法；</p><h3 id="常见的节点类型："><a href="#常见的节点类型：" class="headerlink" title="常见的节点类型："></a>常见的节点类型：</h3><p>nodeType值：1 代表元素（DIV、BODY、LI、SPAN……. ）<br>nodeType值：2 属性代表属性节点 （class，src，href）<br>nodeType值：3 文本节点（text节点）<br>nodeType值：8 代表注释节点<br>nodeType值：9 代表document节点；</p><h3 id="innerHTML和nodeValue-当innerHTML和nodeValue分别作为左值的时候"><a href="#innerHTML和nodeValue-当innerHTML和nodeValue分别作为左值的时候" class="headerlink" title="innerHTML和nodeValue;(当innerHTML和nodeValue分别作为左值的时候)"></a>innerHTML和nodeValue;(当innerHTML和nodeValue分别作为左值的时候)</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">box.innerHTML = '<strong>abc</strong>';box.childNodes[0].nodeValue = '<strong>abc</strong>';innerHTML会将标签解析；nodeValue不会进行解析，会将标签名转译成字符串，直接输出；outerHTML/innerText (非W3C)</code></pre><h3 id="attributes属性"><a href="#attributes属性" class="headerlink" title="attributes属性"></a>attributes属性</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var oBox = document.getElementById('box');    console.log(oBox.attributes)                                      //  获取所有，该节点的属性信息；    console.log(oBox.attributes.length);                          //返回属性节点个数    console.log(oBox.attributes[0]);                                 //返回第一个属性节点    console.log(oBox.attributes[0].nodeType);                //2，属性    console.log(oBox.attributes[0].nodeValue);               //属性值    console.log(oBox.attributes['id']);                              //返回属性为 id 的节点    console.log(oBox.attributes.getNamedItem('id'));     // 获取 id 的节点；</code></pre><p>attributes属性 一般只用作获取，设置使用setAttribute()</p><h3 id="父（parent）、子（child）和同胞（sibling）"><a href="#父（parent）、子（child）和同胞（sibling）" class="headerlink" title="父（parent）、子（child）和同胞（sibling）"></a>父（parent）、子（child）和同胞（sibling）</h3><p>描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）。<br>    childNodes 获取当前元素节点的所有子节点</p><pre><code>firstChild 获取当前元素节点的第一个子节点lastChild 获取当前元素节点的最后一个子节点previousSibling 获取当前节点的前一个同级节点nextSibling 获取当前节点的后一个同级节点****以上五中方法都包含空白文本节点firstElementChild   获取当前元素节点的第一个元素子节点lastElementChild  获取当前元素节点的最后一个元素子节点ownerDocument 获取该节点的文档根节点，相当于documentparentNode 获取当前节点的父元素</code></pre><h3 id="创建文档碎片createDocumentFragment"><a href="#创建文档碎片createDocumentFragment" class="headerlink" title="创建文档碎片createDocumentFragment();"></a>创建文档碎片createDocumentFragment();</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var cache = document.createDocumentFragment();for( var i = 0 ; i < 1000; i ++ )&#123;    var opt = document.createElement("input");    opt.type="button";    opt.value = "删除";    cache.appendChild(opt);&#125;document.body.appendChild(cache);</code></pre><h3 id="DOM尺寸和位置"><a href="#DOM尺寸和位置" class="headerlink" title="DOM尺寸和位置"></a>DOM尺寸和位置</h3><h4 id="DOM尺寸"><a href="#DOM尺寸" class="headerlink" title="DOM尺寸"></a>DOM尺寸</h4><p>box.style.width<br>box.style.height<br>只能获取到内联style属性的CSS样式中的宽和高，如果有，获取;如果没有，则返回空</p><p>getStyle(box,”width”)<br>getStyle(box,”width”)<br>//如下getStyle方法的封装<br>通过计算获取元素的大小，无关你是否是行内、内联或者链接，它经过计算后得到的结果返回出来。如果本身设置大小，它会返回元素的大小，如果本身没有设置，非IE浏览器会返回默认的大小，IE浏览器返回auto。</p><p>box.clientWidth<br>box.clientHeight<br>返回了元素大小，但没有单位，默认单位是px，如果设置了其他的单位，比如100em之类，返回出来的结果还会转换为px像素（不含边框）</p><p>box.scrollWidth<br>box.scrollHeight<br>获取滚动内容的元素大小（当元素出现滚动条时，此属性指全部滚动内容的宽高）<br>返回了元素大小，默认单位是px。如果没有设置任何CSS的宽和高度，它会得到计算后的宽度和高度</p><p>box.offsetWidth<br>box.offsetHeight<br>返回了元素大小，默认单位是px。如果没有设置任何CSS的宽和高度，他会得到计算后的宽度和高度<br>包含盒模型中除margin以外的宽高（包含边框）<br>最稳定，使用最频繁<br>以上这三对方法都是只读的<br>  获取非行内样式（兼容问题）</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function getStyle(obj,attr)&#123;    //获取非行间样式，obj是对象，attr是值      if(obj.currentStyle)&#123;   //针对ie获取非行间样式            return obj.currentStyle[attr];      &#125;else&#123;            return getComputedStyle(obj,false)[attr];   //针对非ie      &#125;;&#125;;</code></pre><h4 id="位置坐标"><a href="#位置坐标" class="headerlink" title="位置坐标"></a>位置坐标</h4><p>box.clientLeft<br>box.clientTop<br>获取左边框和上边框的宽度<br>box.offsetLeft<br>box.offsetTop<br>获取元素当前相对于offsetParent父元素的位置<br>box.scrollTop<br>box.scrollLeft<br>获取滚动内容上方的位置(就是隐藏的内容的高度)<br>获取滚动内容左方的位置</p><p>offsetParent      这个属性的返回值是它根据谁定位的，如果它的所有父元素都没有定位，那么返回body</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node节点 </tag>
            
            <tag> 文档碎片 </tag>
            
            <tag> DOM尺寸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的MATH和Date对象</title>
      <link href="/posts/js-math-date.html"/>
      <url>/posts/js-math-date.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h2><p>对象的类型是Object。<br>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…<br>javaScript中万事万物皆对象<br>想要有对象怎么办？</p><h2 id="创建对象：（创建两种方式-字面量和new运算符）"><a href="#创建对象：（创建两种方式-字面量和new运算符）" class="headerlink" title="创建对象：（创建两种方式:字面量和new运算符）"></a>创建对象：（创建两种方式:字面量和new运算符）</h2><h3 id="1-New一个对象出来；"><a href="#1-New一个对象出来；" class="headerlink" title="1.New一个对象出来；"></a>1.New一个对象出来；</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var obj = new Object();//找到对象了  >>>  第一个想到的就是属性；//给对象添加一个属性；obj.bianmei='哇真的变漂亮了' ;obj.say=function()&#123;    alert(this.bianmei);&#125;obj.say();delete obj.jian; //删除对象的属性</code></pre><p>obj的属性可以是一个函数，这个时候也叫方法；<br>obj函数内的指针this，指向obj对象本身；</p><h2 id="javaScript内置对象-十个"><a href="#javaScript内置对象-十个" class="headerlink" title="javaScript内置对象(十个)"></a>javaScript内置对象(十个)</h2><p>1.Object对象        是所有JavaScript对象的超类(基类)<br>2.Array对象          数组对象—定义数组属性和方法<br>3.Boolean对象     布尔对象—布尔值相关<br>4.Date对象           日期对象—日期时间相关<br>5.Error对象           错误对象—处理程序错误<br>6.Function对象     函数对象—定义函数属性和方法<br>7.Math对象            数学对象—各种数学运算工具(不是构造函数)<br>8.Number对象       数字对象—定义数字属性和方法<br>9.RegExp对象        正则表达式对象—定义文本匹配与筛选规则<br>10.String对象        字符串对象—定义字符串属性和方法</p><h2 id="Date内置对象"><a href="#Date内置对象" class="headerlink" title="Date内置对象"></a>Date内置对象</h2><p>日期对象创建<br>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总毫秒数（时间戳）<br>  var date = new Date();//当前时间的日期对象<br>  var data = new Date(2012,6,10);//2012年7月10号的日期对象</p><h3 id="get系列API"><a href="#get系列API" class="headerlink" title="get系列API"></a>get系列API</h3><p>getFullYear()<br>返回年<br>getMonth()<br>返回月份0—11<br>getDate()<br>返回某一天<br>getDay()<br>返回星期0-6<br>getHours()<br>返回小时<br>getMinutes()<br>返回分钟<br>getSeconds()<br>返回秒<br>getTime()<br>返回1970年1月1日午夜到指定日期（字符串）的毫秒数</p><h3 id="set系列API"><a href="#set系列API" class="headerlink" title="set系列API"></a>set系列API</h3><p>setFullYear()<br>设置年份<br>setMonth()<br>设置月<br>setDate()<br>设置天<br>setHours()<br>设置小时<br>setMinutes()<br>设置分钟<br>setSeconds()<br>设置秒<br>setTime()<br>使用毫秒的形式设置时间对象</p><h2 id="★注意"><a href="#★注意" class="headerlink" title="★注意:"></a>★注意:</h2><p>1、setDay( 这个真没有!!!!,星期是通过设定日期自动计算的 )<br>2、set系列API可以设置比当前范围更精细的时间<br>比如：setFullYear（2012，3，5）  设置日期为2018年4月5号<br>setHours（13，30，0）  设置时间为13:30:00</p><h3 id="getMonth："><a href="#getMonth：" class="headerlink" title="getMonth："></a>getMonth：</h3><p>可选,介于 0 ~ 11 之间：如果不填，取系统当月<br>-1 为去年的最后一个月<br>12 为明年的第一个月<br>13 为明年的第二个月</p><h3 id="getDay"><a href="#getDay" class="headerlink" title="getDay()"></a>getDay()</h3><p>返回星期 0-6</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象 </tag>
            
            <tag> math </tag>
            
            <tag> date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的BOM对象</title>
      <link href="/posts/js-bom.html"/>
      <url>/posts/js-bom.html</url>
      
        <content type="html"><![CDATA[<h2 id="BOM（Browser-Object-Model-浏览器对象模型）"><a href="#BOM（Browser-Object-Model-浏览器对象模型）" class="headerlink" title="BOM（Browser Object Model  浏览器对象模型）"></a>BOM（Browser Object Model  浏览器对象模型）</h2><h3 id="window是全局浏览器内置顶级对象"><a href="#window是全局浏览器内置顶级对象" class="headerlink" title="window是全局浏览器内置顶级对象"></a>window是全局浏览器内置顶级对象</h3><p>表示浏览器中打开的窗口（没有应用于window对象的公开标准，不过所有浏览器都支持该对象）<br>Window 对象表示一个浏览器窗口或一个框架。<br>在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。<br>也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。<br>例如，可以只写 document，而不必写 window.document。<br>同样，可以把当前窗口对象的方法当作函数来使用，如只写 alert()，而不必写 Window.alert()。<br>除了上面列出的属性和方法，Window 对象还实现了核心 JavaScript 所定义的所有全局属性和方法。</p><h3 id="1、全局变量默认是挂在window下的"><a href="#1、全局变量默认是挂在window下的" class="headerlink" title="1、全局变量默认是挂在window下的"></a>1、全局变量默认是挂在window下的</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var  a = 123;alert(window.a)//123</code></pre><h3 id="2、window下的子对象"><a href="#2、window下的子对象" class="headerlink" title="2、window下的子对象"></a>2、window下的子对象</h3><h4 id="（1）location"><a href="#（1）location" class="headerlink" title="（1）location"></a>（1）location</h4><p>window.location.href          当前页面的 URL，可以获取，可以修改（页面跳转）<br>window.location.hostname      web 主机的域名<br>window.location.pathname      当前页面的路径和文件名<br>window.location.port          web 主机的端口 （80 或 443）<br>window.location.protocol      所使用的 web 协议（http:// 或 https://）<br>window.location.search        请求参数（？后面的内容）</p><p>window.location.reload();<br>刷新页面，一般情况下给reload()传递一个true，让他刷新，并不使用缓存。缓存的东西一般为js文件，css文件等。<br>用这个方法可以让自己不能动的页面动起来了。刷新当前页面。</p><h4 id="（2）window-navigator"><a href="#（2）window-navigator" class="headerlink" title="（2）window.navigator"></a>（2）window.navigator</h4><p>navigator.appName      返回获取当前浏览器的名称。<br>navigator.appVersion    返回 获取当前浏览器的版本号。<br>navigator.platform        返回 当前计算机的操作系统。<br>以上属性已经在逐渐被抛弃了。一个新的属性将替代这些属性。</p><p>navigator.userAgent   返回浏览器信息（可用此属性判断当前浏览器）</p><h5 id="判断当前浏览器类型的代码："><a href="#判断当前浏览器类型的代码：" class="headerlink" title="判断当前浏览器类型的代码："></a>判断当前浏览器类型的代码：</h5><pre class=" language-lang-javascript"><code class="language-lang-javascript">function isBrowser() &#123;    var userAgent = navigator.userAgent;    //微信内置浏览器    if(userAgent.match(/MicroMessenger/i) == 'MicroMessenger') &#123;        return "MicroMessenger";    &#125;    //QQ内置浏览器    else if(userAgent.match(/QQ/i) == 'QQ') &#123;        return "QQ";    &#125;    //Chrome    else if(userAgent.match(/Chrome/i) == 'Chrome') &#123;        return "Chrome";    &#125;    //Opera    else if(userAgent.match(/Opera/i) == 'Opera') &#123;        return "Opera";    &#125;    //Firefox    else if(userAgent.match(/Firefox/i) == 'Firefox') &#123;        return "Firefox";    &#125;    //Safari    else if(userAgent.match(/Safari/i) == 'Safari') &#123;        return "Safari";    &#125;    //IE    else if(!!window.ActiveXObject || "ActiveXObject" in window) &#123;        return "IE";    &#125;    else &#123;        return "未定义:"+userAgent;    &#125;&#125;</code></pre><h4 id="（3）history"><a href="#（3）history" class="headerlink" title="（3）history"></a>（3）history</h4><p>history.go(1)    参数可写任意整数，正数前进，负数后退<br>history.back()   后退<br>history.forward() 前进</p><h4 id="（4）screen-屏幕"><a href="#（4）screen-屏幕" class="headerlink" title="（4）screen: 屏幕"></a>（4）screen: 屏幕</h4><p>window.screen.width 返回当前屏幕宽度(分辨率值)<br>window.screen.height 返回当前屏幕高度(分辨率值)</p><h4 id="（5）window下的弹框方法"><a href="#（5）window下的弹框方法" class="headerlink" title="（5）window下的弹框方法"></a>（5）window下的弹框方法</h4><p>alert()   prompt()  confirm()</p><h4 id="（6）定时器"><a href="#（6）定时器" class="headerlink" title="（6）定时器"></a>（6）定时器</h4><p>超时定时器        间隔定时器<br>setTimeout       setInterval<br>clearTimeout     clearInterval</p><h4 id="（7）window-onload"><a href="#（7）window-onload" class="headerlink" title="（7）window.onload"></a>（7）window.onload</h4><h4 id="（8）window-onscroll"><a href="#（8）window-onscroll" class="headerlink" title="（8）window.onscroll"></a>（8）window.onscroll</h4><p>var scrolltop=document.documentElement.scrollTop||document.body.scrollTop; //兼容</p><h4 id="（9）window-window-onresize"><a href="#（9）window-window-onresize" class="headerlink" title="（9）window.window.onresize"></a>（9）window.window.onresize</h4>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
            <tag> 定时器 </tag>
            
            <tag> window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的DOM对象</title>
      <link href="/posts/js-dom.html"/>
      <url>/posts/js-dom.html</url>
      
        <content type="html"><![CDATA[<h2 id="DOM（Document-Object-Model-文档对象模型）"><a href="#DOM（Document-Object-Model-文档对象模型）" class="headerlink" title="DOM（Document Object Model 文档对象模型）"></a>DOM（Document Object Model 文档对象模型）</h2><p>DOM定义了表示和修改文档所需的对象、行为和属性，以及这些对象之间的关系。<br>当你想要改变网页行为的时候 你该怎么办呢？你不会用脚来踹网页或者用头来顶网页吧？这时候怎么办呢 ？<br>而你手中有javascript 这种工具！所以你就会考虑用javascript来改变网页行为.</p><h2 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h2><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="获取DOM节点"><a href="#获取DOM节点" class="headerlink" title="获取DOM节点"></a>获取DOM节点</h3><p>1、 document.getElementById(id名)<br>2、 getElementsByTagName(标签名) 得到的是一个集合（不止一个，是一堆）<br>3、 getElementsByName( ) 通过Name值获取元素，返回值是集合，通常用来获取有name的input的值；<br>注：1<em>不是所有的标签都有name值；  2</em>低版本的浏览器会有兼容问题；<br>4、 children属性，获得DOM元素的所有子元素；返回值是集合<br>5、 parentNode属性，获得DOM元素的父级元素<br>6、 getElementsByClassName(class名称)  但是：IE8以下不能用<br>7、 ES5选择器：<br>    document.querySelector ()  &gt;  一旦匹配成功一个元素，就不往后匹配了<br>    document.querySelectorAll ()  &gt;&gt;&gt;&gt; 强大到超乎想象;匹配到所有满足的元素, 支持IE8+</p><h3 id="属性获取和操作"><a href="#属性获取和操作" class="headerlink" title="属性获取和操作"></a>属性获取和操作</h3><p>1、getAttribute( )获取元素的属性值，他是节点的方法！所以前缀必须是节点！<br>document.getElementById( ID值 ).getAttribute( )<br>什么是元素属性呢？ class就是元素属性，写在标签内的所有东西都是标签属性， 比如link的href比如img的src….都是元素属性。<br>元素自带的属性可以直接用 . 语法获取，但是自定义属性需要 getAttribute() 和 setAttribute( ) 方法<br>2、setAttribute( )设置元素的属性。同上；<br>有些小小的兼容性问题，低版本IE不兼容；<br>设置的属性永远都是字符串类型<br>3、removeAttribute( )删除属性；同上；<br>兼容性问题同上；</p><h3 id="DOM元素类型-元素、文本和属性"><a href="#DOM元素类型-元素、文本和属性" class="headerlink" title="DOM元素类型(元素、文本和属性)"></a>DOM元素类型(元素、文本和属性)</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">nodeObj.nodeName // 节点名称  /*    元素节点：标签名（大写）    属性节点：属性名称    文本节点：#text*/nodeObj.nodeType // 1 ==> 元素节点  2 ==> 属性节点  3 ==> 文本节点</code></pre><h3 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h3><p>增、删、克隆节点<br>1.创建节点<br>var oDiv = document.createElement(“div”);<br>2.克隆节点<br>clonedNode = Node.cloneNode(boolean) // 只有一个参数，传入一个布尔值，true表示深客隆，复制该节点下的所有子节点；false表示浅克隆，只复制该节点<br>3.插入节点<br>parentNode.appendChild(childNode);  // 将新节点追加到子节点列表的末尾<br>parentNode.insertBefore(newNode, targetNode);//将newNode插入targetNode之前<br>4.替换节点<br>parentNode.replaceChild(newNode, targetNode); //使用newNode替换targetNode<br>5.移除节点<br>parentNode.removeChild(childNode);  // 移除目标节点<br>node.parentNode.removeChild(node);    //在不清楚父节点的情况下使用<br>childNode.remove()  //IE不支持</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
            <tag> DOM节点 </tag>
            
            <tag> 操作DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象</title>
      <link href="/posts/js-object.html"/>
      <url>/posts/js-object.html</url>
      
        <content type="html"><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="类是对象的抽象，对象是类的实例。"><a href="#类是对象的抽象，对象是类的实例。" class="headerlink" title="类是对象的抽象，对象是类的实例。"></a>类是对象的抽象，对象是类的实例。</h3><p>在js中一切皆为对象，如字符串、数字、数组等。<br>在js中对象的本质：属性和方法的集合。</p><h3 id="JS内置对象（10个）"><a href="#JS内置对象（10个）" class="headerlink" title="JS内置对象（10个）"></a>JS内置对象（10个）</h3><ol><li>Object对象 是所有JavaScript对象的超类(基类)</li><li>Array对象 数组对象—定义数组属性和方法</li><li>Boolean对象 布尔对象—布尔值相关</li><li>Date对象 日期对象—日期时间相关</li><li>Error对象 错误对象—处理程序错误</li><li>Function对象 函数对象—定义函数属性和方法</li><li>Math对象 数学对象—各种数学运算工具(不是构造函数)</li><li>Number对象 数字对象—定义数字属性和方法</li><li>RegExp对象 正则表达式对象—定义文本匹配与筛选规则</li><li>String对象 字符串对象—定义字符串属性和方法</li></ol><h3 id="1、创建对象"><a href="#1、创建对象" class="headerlink" title="1、创建对象"></a>1、创建对象</h3><p>方法1 字面量创建</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//字面量创建 var person = &#123;    //键值对    //key : value    height : 170,    weight : 70,    say : function()&#123;        alert(123);    &#125;&#125;</code></pre><p>方法2 new创建</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//new创建var person = new Object();person.height = 170;person.weight = 70;person.say = function()&#123;    alert(456);&#125;</code></pre><h3 id="2、使用对象"><a href="#2、使用对象" class="headerlink" title="2、使用对象"></a>2、使用对象</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">//对象名.属性名//alert(height);alert(person.height);//对象名.方法名()person.say();console.log(person);</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象 </tag>
            
            <tag> 类 </tag>
            
            <tag> 内置对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啊啊啊文章模板啊</title>
      <link href="/posts/articletemplate.html"/>
      <url>/posts/articletemplate.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info">前言</div><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul><li>项目</li></ul><p><img src="/posts/articletemplate.htm/图片链接" alt="引入图片"></p><p><code>正文一些需要高亮色的文字</code></p><p><a href="链接" class="LinkCard" target="_blank">引入链接</a></p><div style="position: relative; padding: 30% 45%;"> <iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="视频地址去B站分享按钮下iframe里面的src属性值复制" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> </div>]]></content>
      
      
      <categories>
          
          <category> 文章模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about-me</title>
      <link href="/posts/about-me.html"/>
      <url>/posts/about-me.html</url>
      
        <content type="html"><![CDATA[<h4 id="Hello-Everyone"><a href="#Hello-Everyone" class="headerlink" title="Hello Everyone!"></a>Hello Everyone!</h4><ul><li><p>欢迎来到我的个人博客，我将在这里和大家分享我在前端学习路上的一些知识和经历</p></li><li><p>可以称呼我 nekodeng</p></li><li><p>梦想是成为一位优秀的 Web Front-end Developer</p></li></ul><h4 id="Life-was-like-a-box-of-chocolates-you-never-know-what-you’re-gonna-get"><a href="#Life-was-like-a-box-of-chocolates-you-never-know-what-you’re-gonna-get" class="headerlink" title="Life was like a box of chocolates, you never know what you’re gonna get."></a>Life was like a box of chocolates, you never know what you’re gonna get.</h4><ul><li><p>这是电影《阿甘正传》里的句子啦</p></li><li><p>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。<br>可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。   王小波—《黄金时代》</p></li></ul><h4 id="https-space-bilibili-com-107492592"><a href="#https-space-bilibili-com-107492592" class="headerlink" title="https://space.bilibili.com/107492592"></a><a href="https://space.bilibili.com/107492592">https://space.bilibili.com/107492592</a></h4><ul><li><p>也喜欢逛逛B站的，这是本up主的主页地址哈</p></li><li><p>UID: 107492592</p></li></ul><h4 id="https-nekodeng-github-io"><a href="#https-nekodeng-github-io" class="headerlink" title="https://nekodeng.github.io/"></a><a href="https://nekodeng.github.io/">https://nekodeng.github.io/</a></h4><ul><li>这是部署在GitHub上的博客地址啦</li></ul><h4 id="https-nekodeng-gitee-io"><a href="#https-nekodeng-gitee-io" class="headerlink" title="https://nekodeng.gitee.io/"></a><a href="https://nekodeng.gitee.io/">https://nekodeng.gitee.io/</a></h4><ul><li>这是部署在gitee上的博客地址啦</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> about-me </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
