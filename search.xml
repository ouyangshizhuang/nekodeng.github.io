<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>这是测试哦</title>
      <link href="/posts/29e0.html"/>
      <url>/posts/29e0.html</url>
      
        <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>正文随意发挥。。。。。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//这里是js代码</code></pre><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><p>正文随意发挥。。。。。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//这里是js代码</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS正则表达式</title>
      <link href="/posts/e88.html"/>
      <url>/posts/e88.html</url>
      
        <content type="html"><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>（英语：Regular Expression，在代码中常简写为regex、regexp或RE）<br>语法<br>/正则表达式主体/修饰符(可选)</p><h4 id="正则的第一种写法"><a href="#正则的第一种写法" class="headerlink" title="正则的第一种写法"></a>正则的第一种写法</h4><pre class=" language-lang-javascript"><code class="language-lang-javascript">var reg=new RegExp('a');var str='abcdefg';alert(reg.test(str));   //返回bool值，代表是否匹配成功</code></pre><h4 id="正则表达式的第二种写法"><a href="#正则表达式的第二种写法" class="headerlink" title="正则表达式的第二种写法"></a>正则表达式的第二种写法</h4><p>perl风格 古老的语言</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var re = /a/var str='abcdefg';re.test(str);</code></pre><h3 id="中括号：匹配其中的某一个字符"><a href="#中括号：匹配其中的某一个字符" class="headerlink" title="[ ] 中括号：匹配其中的某一个字符"></a>[ ] 中括号：匹配其中的某一个字符</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = prompt();var reg = /[abcde]/;//匹配是否有abcde中的字符console.log(reg.test(str));</code></pre><p>[ a-z ] 匹配所有小写字母<br>[0-9] == \d 匹配任意一个数字( )</p><p>小括号：分组：小括号里面的内容作为整体进行匹配<br>小括号用于分组，竖线作为间隔代表“或者”的含义<br>/(ab) | (cd)/ 匹配’ab’ 或者 ‘cd’<br>/(a|b)cd/ 匹配 ‘acd’ 或者 ‘bcd’<br>注意：小括号、竖线不要放在 [ ] 内（无意义）</p><p>| : 或，跟js中的（||）一样<br>^：排除（除了） 类似js中的（！）<br>^ (不在中括号里)匹配字符串开头<br>$ 匹配结尾</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var reg = /^[a-z]$/;//小写字母 开头并且小写字母结尾,中间不能有字符(完整匹配)/^$/这样的正则代表完整匹配</code></pre><h3 id="转义字符：元字符"><a href="#转义字符：元字符" class="headerlink" title="转义字符：元字符"></a>转义字符：元字符</h3><p>\d —— [0-9] 数字<br>\w ——-[a-z0-9_A-Z] 数字，字母，下划线<br>\s —- 空白字符</p><p>\D ——-<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup> 非数字<br>\W ——-<sup><a href="#fn_a-z0-9_" id="reffn_a-z0-9_">a-z0-9_</a></sup> 非数字，字母，下划线<br>\ S ——-非空白字符</p><p>. ——-全部字符<br>b ——-匹配单词边界<br>\B ——-匹配 非 单词边界<br>\0(数字0) ——-匹配 NUL 字符<br>\n ——-匹配 换行符<br>\f ——-匹配 换页符<br>\r ——-匹配 回车符<br>\t ——-匹配 制表符<br>\v ——-匹配 垂直制表符<br>\u4e00 - \u9fa5 验证中文</p><h3 id="量词：（单位名称）"><a href="#量词：（单位名称）" class="headerlink" title="量词：（单位名称）"></a>量词：（单位名称）</h3><p>{n} —-匹配n次</p><p>{n,m} —-最少n次，最多m次；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">QQ号验证  /^[1-9]\d&#123;4,10&#125;$/</code></pre><p>{n,} —-最少n次，最多不限</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">+  == &#123;1,&#125;最少为一个</code></pre><p>? {0,1} 可有可无，最多一个</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">*  &#123;0,&#125; 可以有也可以没有，个数不限</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">/(ab|cd)&#123;2&#125;/ 匹配字符串"ab" 或者 "cd" 的2次，或者abcd 结果为:abab cdcd abcd cdab</code></pre><h3 id="匹配大小写不一样的字母怎么办？"><a href="#匹配大小写不一样的字母怎么办？" class="headerlink" title="匹配大小写不一样的字母怎么办？"></a>匹配大小写不一样的字母怎么办？</h3><p>var re=new RegExp(‘a’,’i’)<br>正则对象中有一个参数，可以传入对应的值，i 代表让正则不区分大小写；<br>i：忽略大小写<br>var re= /a/i</p><p>g：全局查找<br>reg = /\d+/ g<br>g: 代表全局所有 （global）</p><p>m： 多行查找（必须与g一起实用,并且,当使用^和$模式时才会起作用）</p><h3 id="正则对象的方法："><a href="#正则对象的方法：" class="headerlink" title="正则对象的方法："></a>正则对象的方法：</h3><h4 id="1-test方法"><a href="#1-test方法" class="headerlink" title="1.test方法"></a>1.test方法</h4><p>该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false</p><h4 id="2-compile方法"><a href="#2-compile方法" class="headerlink" title="2.compile方法"></a>2.compile方法</h4><p>该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var reg=/[abc]/gi;console.log(reg.test('a'));reg=/[cde]/gi;console.log(reg.test('a'));reg.compile(reg);console.log(reg.test('a'));</code></pre><h4 id="3-exec方法"><a href="#3-exec方法" class="headerlink" title="3.exec方法"></a>3.exec方法</h4><p>返回的是一个数组，数组元素为匹配的子字符串</p><h3 id="支持正则的字符串方法"><a href="#支持正则的字符串方法" class="headerlink" title="支持正则的字符串方法"></a>支持正则的字符串方法</h3><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>查找第一次匹配的子字符串的位置，如果找到就返回一个number类型的index值，否则返回-1</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>该方法用来将字符串中的某些子串替换为需要的内容，接受两个参数，第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容，第二个参数为被替换的新的子字符串</p><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>将一个字符串拆分成一个数组，它接受一个正则或者子字符（串）作为参数，返回一个数组</p><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><p>接受一个正则作为参数，用来匹配一个字符串，返回一个数组</p><p>例子：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">    var reg = new RegExp("b");//写法1    var str = prompt();    var reg = /b/;// 写法2  匹配是否存在b    var reg = /[abcde]/;//匹配是否有abcde中的字符    var reg = /[a-z]/;//匹配所有小写字母    var reg = /(ab)|(cd)/;//ab  或 cd    var reg = /(a|b)cd/;//acd  或bcd    var reg = /[^a-z]/;//不能有小写字母    var reg = /^[a-z]/;//小写字母开头    var reg = /^[a-z]$/;//小写字母 开头并且小写字母结尾,中间不能有字符(完整匹配)    var reg = /\d/;//匹配0-9的数字[0-9];    var reg = /./;//匹配所有字符    var reg = /\./;//转义字符z    var reg = /\d&#123;6&#125;/;//6个数字（超过也为true）    var reg = /a\d&#123;6,8&#125;a/;//六到8个数字,前后做好限定,否则会自动过滤掉多余的数字    var reg = /^[1-9]\d&#123;4,10&#125;$/;//5-11位,完整匹配    var reg = /\w/;//-[a-z0-9_A-Z]     数字，字母，下划线    var reg = /\s/;//空格    var reg = /\D/;//不为数字    var reg = /^\d+.&#123;3,&#125;$/;// 必须以数字开头,数量一个以上,紧接着任意字符至少三个,并以之结尾    var reg = /^\d?$/;//以数字开头 一个数字或者没有  &#123;0,1&#125; 可有可无，最多一个    var reg = /^\d*$/;//&#123;0,&#125; 可以有也可以没有，个数不限    var reg = /zhangsan/i;//i：忽略大小写    var reg = /\d+/g;//g: 代表全局所有  （global）    console.log(reg.test(str));</code></pre><h3 id="案例-密码强度"><a href="#案例-密码强度" class="headerlink" title="案例:密码强度"></a>案例:密码强度</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">            // html代码如下            // input type="text" id="pwd"     input标签            // button 登录 button             button标签            //js代码如下            var input = document.querySelector("#pwd");            var numReg = /\d+/;            //var letterReg = /^[a-zA-Z]$/;            var letterReg = /[a-z]+/i;            var charReg = /[^0-9a-z]+/i;            //存储三个正则的验证结果            document.querySelector("button").onclick = function()&#123;                var arr = [];                var pwd = input.value;                arr.push(numReg.test(pwd));                arr.push(letterReg.test(pwd));                arr.push(charReg.test(pwd));                console.log(arr);                var arr1 = arr.filter(function(item)&#123;                    return item;                &#125;)                if(arr1.length === 1) alert("弱");                else if(arr1.length === 2) alert("中");                if(arr1.length === 3) alert("强");            &#125;</code></pre><h3 id="附：扩展正则案例"><a href="#附：扩展正则案例" class="headerlink" title="附：扩展正则案例"></a>附：扩展正则案例</h3><p>只能用数字开头，长度在6—18位之间 /^\d.{5,17}$/</p><p>以字母开头，数字结尾，中间任意一个字符 /^[a-z].\d$/i</p><p>密码不能少于6位的字符 /^.{6,}$/</p><p>以a开头 b字符至少出现2个，至多出现6个(b连续出现) /^a.*b{2,6}/</p><p>变量的命名正则表达式(不能用数字开头 由字母、数字、下划线 、][\w/</p><p>开头为0的2或者三位数字加上 - 开头为非零的八位数字结尾是1到4位的分机号<br>/^0\d{2,3}-[1-9]\d{7}-\d{1,4}$/</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS冒泡选择快速排序</title>
      <link href="/posts/b0e2.html"/>
      <url>/posts/b0e2.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS冒泡排序（必须掌握思想和必须会代码默写）（面试最常考）"><a href="#JS冒泡排序（必须掌握思想和必须会代码默写）（面试最常考）" class="headerlink" title="JS冒泡排序（必须掌握思想和必须会代码默写）（面试最常考）"></a>JS冒泡排序（必须掌握思想和必须会代码默写）（面试最常考）</h2><p>原理：依次比较相邻的两个值，如果后面的比前面的小，则将小的元素排到前面。依照这个规则进行多次并且递减的迭代，直到顺序正确。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr=[8,94,15,88,55,76,21,39];function sortarr(arr)&#123;    for(i=0; i < arr.length-1; i++)&#123;        for(j=0; j < arr.length-1-i; j++)&#123;            if(arr[j] > arr[j+1])&#123;                var temp = arr[j];                arr[j] = arr[j+1];                arr[j+1] = temp;            &#125;        &#125;    &#125;    return arr;&#125;sortarr(arr);console.log(arr);</code></pre><p>解析<br>两个循环<br>当i=0的时候，里面的循环完整执行，从j=0执行到j=6,这也就是第一遍排序，结果是将最大的数排到了最后，这一遍循环结束后的结果应该是[8,15,88,55,76,21,39,94]<br>当i=1的时候，里面的循环再次完整执行，由于最大的数已经在最后了，没有必要去比较数组的最后两项，这也是j&lt;arr.length-1-i的巧妙之处，结果是[8,15,55,76,21,39,88,94]<br>说到这里，规律就清楚了，每次将剩下数组里面最大的一个数排到最后面，当第一个循环执行到最后的时候，也就是i=6,此时，j=0,只需要比较数组的第一和第二项，比较完毕，返回。</p><h2 id="JS选择排序（了解思想和必须会代码默写）（面试最常考）"><a href="#JS选择排序（了解思想和必须会代码默写）（面试最常考）" class="headerlink" title="JS选择排序（了解思想和必须会代码默写）（面试最常考）"></a>JS选择排序（了解思想和必须会代码默写）（面试最常考）</h2><p>原理：首先从原始数组中找到最小的元素，并把该元素放在数组的最前面，然后再从剩下的元素中寻找最小的元素，放在之前最小元素的后面，直到排序完毕。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr=[8,94,15,88,55,76,21,39];function selectSort(arr)&#123;    var minIndex,temp;    for(i = 0; i < arr.length-1; i++)&#123;        minIndex=i; //设置最小数的下标为当前的i        for(j = i+1; j < length-1; j++)&#123;            if(arr[j] < arr[minIndex])&#123;                minIndex = j;            &#125;        &#125;    temp = arr[i];    arr[i] = arr[minIndex];    arr[minIndex] = temp;    &#125;    return arr;&#125;console.log(selectSort(arr));</code></pre><p>解析<br>minIndex始终保存着最小值的位置的索引，随着i的自增，遍历的数组长度越来越短，直到完成排序。</p><h2 id="JS快速排序（了解思想和了解代码）"><a href="#JS快速排序（了解思想和了解代码）" class="headerlink" title="JS快速排序（了解思想和了解代码）"></a>JS快速排序（了解思想和了解代码）</h2><p>原理<br>从数组中选定一个基数，然后把数组中的每一项与此基数做比较，小的放入一个新数组，大的放入另外一个新数组。然后再采用这样的方法操作新数组。直到所有子集只剩下一个元素，排序完成。</p><pre><code>var arr=[8,94,15,88,55,76,21,39];  function fastsort(arr)&#123;    if(arr.length&lt;2)&#123;        return arr;    &#125;    var left=[];    var right=[];    var pivotIndex=Math.floor(arr.length/2);    var pivot=arr.splice(pivotIndex,1)[0];    for(i=0;i&lt;arr.length;i++)&#123;        if(arr[i]&lt;pivot)&#123;            left.push(arr[i]);        &#125;else&#123;            right.push(arr[i])        &#125;    &#125;    return fastsort(left).concat([pivot],fastsort(right));  &#125;  console.log(fastsort(arr));</code></pre><p>解析<br>pivotIndex是将数组的长度除2向下取整得到的一个数值，数组的长度是不断减半的，所以最后它的值为0<br>pivot是利用splice方法从数组里获取一个基数</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 选择排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件流</title>
      <link href="/posts/e04e.html"/>
      <url>/posts/e04e.html</url>
      
        <content type="html"><![CDATA[<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>Netscape认为，石头先扔进河里，再从河里确定了一个扔石头的点，从外往内逐渐精确的过程（捕获）</p><p>w3c认为，石头扔进去先到达准确的那个点，涟漪从内往外扩散（冒泡）</p><p>事件流：事件执行的顺序</p><p>子元素的事件被触发时，父级也会被触发（冒泡）</p><p>一个完整事件包含  捕获阶段 —-&gt; 目标阶段  —-&gt;冒泡阶段</p><p>冒泡是可以阻止的</p><pre><code> e.stopPropagation( ); e.cancelBubble=true;//兼容IE</code></pre><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>DOM0级事件处理，是一种赋值方式，是被所有浏览器所支持的，简单易懂容易操作；</p><p>DOM2级事件处理是所有DOM节点中的方法，可以重复绑定，但是浏览器兼容存在问题；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//DOM0级oDiv.onclick = function()&#123; .... &#125;    //DOM2级if(window.attachEvent)&#123;    oDiv.attachEvent("onclick", function()&#123; ... &#125;);  // IE只有冒泡阶段,所以没有第三个参数，而且需要加on；&#125;else&#123;    oDiv.addEventListener( "click", function()&#123; ... &#125;,false);  // false指冒泡阶段&#125;//移除事件监听，第二个参数为必须，移除的事件处理函数oDiv.removeEventListener( "click",fn）oDiv.detachEvent("onclick",fn)</code></pre><h3 id="事件委托（事件代理）委派"><a href="#事件委托（事件代理）委派" class="headerlink" title="事件委托（事件代理）委派"></a>事件委托（事件代理）委派</h3><p>什么是事件委托：全班同学都要做《五年高考三年模拟》，每个同学自己去书店买？不用，委托老师帮你们买，同学们只管认真做题就好啦，好开心。</p><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以处理某一类型的所有事件<br>使用场景主要用于事件源不确定的情况，可以把事件委托给父级</p><p>判断事件源：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">e.target || e.srcElement</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件流 </tag>
            
            <tag> 冒泡 </tag>
            
            <tag> 捕获 </tag>
            
            <tag> 监听 </tag>
            
            <tag> 委托/代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件2</title>
      <link href="/posts/a1a1.html"/>
      <url>/posts/a1a1.html</url>
      
        <content type="html"><![CDATA[<h3 id="事件的原理"><a href="#事件的原理" class="headerlink" title="事件的原理"></a>事件的原理</h3><p>事件的原理和hover类似。可以做到:hover做不到的事，:hover只能操作当前的元素，但是事件绑定之后可以选择任何元素。</p><p>事件触发三要素：通过谁触发？ 通过什么触发？触发后要做什么？</p><p>事件的写法：</p><p>w3c标准：事件写在行内，但是因为结构和行为要分离，所以我们一般情况下用JavaScript的方法来绑定事件，只有再极少数情况下，才将事件写在行内，事件的绑定方法：</p><pre><code> 浏览器中的节点(对象).on+事件句柄 = function( )&#123;      干什么？（放在浏览器中，不执行，当事件发生的时候再执行。） &#125; oDiv.onclick=function()&#123;           alert（1） &#125;</code></pre><p>事件总结：事件是给浏览器定义一个预处理函数，当事件触发的时候，执行函数，这就是事件。</p><p>当事件被触发的时候奥特曼会得到一个信息（事件对象），包含了跟事件相关的一些属性和方法的封装（如：事件发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态等），只有事件在触发的时候才会得到。</p><pre><code> oDiv.onmousedown=function(e)&#123;      alert（e）; &#125;</code></pre><p>JS缺德定律：事件对象有兼容问题；<br>所以我们先做好兼容再去使用事件对象：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">e=e || window.event;alert (e.buttons)观察.buttons的返回值；</code></pre><h4 id="鼠标事件及方法；"><a href="#鼠标事件及方法；" class="headerlink" title="鼠标事件及方法；"></a>鼠标事件及方法；</h4><p>e.buttons<br>返回鼠标点击按键（1左键，2右键，4中键滚轮）</p><p>e.offsetX / offsetY<br>获取事件触发最近的盒子（事件源）的坐标</p><p>e.clientX / clientY<br>获取可视区的坐标（根据浏览器的定位）</p><p>e.screenX / screenY<br>获取整个屏幕的坐标</p><p>e.pageX / e.pageY<br>获取文档的坐标（包含滚动条）</p><h4 id="键盘事件：keydown、keyup、keypress"><a href="#键盘事件：keydown、keyup、keypress" class="headerlink" title="键盘事件：keydown、keyup、keypress"></a>键盘事件：keydown、keyup、keypress</h4><p>document.onkeydown = function(e){<br>     console.log(e.keyCode)<br>}<br>键盘上每一个键都有一个唯一的编码，用来识别当前用户正在操作的是键盘上哪一个键</p><p>有兼容问题<br>e.keyCode || e.which</p><p>特殊键码：是否按下alt  ctrl  和 shift<br>e.altKey</p><p>e.ctrlKey</p><p>e.shiftKey</p><p>返回值是布尔值；</p><p>可以用来判断组合键</p><p>if（e.keyCode==13&amp;&amp;e.altKey）{<br>     alert(‘同时按下了enter和alt’)；<br>}</p><h4 id="默认行为（浏览器）"><a href="#默认行为（浏览器）" class="headerlink" title="默认行为（浏览器）"></a>默认行为（浏览器）</h4><p>有一些html元素默认的行为，比如说a标签，点击后有跳转动作；form表单中的submit类型的input有一个默认提交跳转事件；reset类型的input有重置表单行为。</p><p>但是，有些时候我们是不需要默认事件的，所以就需要阻止默认事件</p><p>return false；</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">if(e.preventDefault) &#123;   e.preventDefault();&#125;else &#123;    window.event.returnValue = false;        //return false;&#125;</code></pre><p>1、右键菜单（上下文菜单）  oncontextmenu<br>2、表单提交事件 onsubmit</p><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>子元素的事件被触发时，父级也会被触发（冒泡）<br>一个完整事件流包含  捕获阶段 —-&gt; 目标阶段  —-&gt;冒泡阶段</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鼠标/键盘事件 </tag>
            
            <tag> 阻止默认浏览器事件 </tag>
            
            <tag> 事件流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的node节点</title>
      <link href="/posts/e785.html"/>
      <url>/posts/e785.html</url>
      
        <content type="html"><![CDATA[<h3 id="node节点（更详细的获取（设置）页面中所有的内容）"><a href="#node节点（更详细的获取（设置）页面中所有的内容）" class="headerlink" title="node节点（更详细的获取（设置）页面中所有的内容）"></a>node节点（更详细的获取（设置）页面中所有的内容）</h3><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：<br>元素是节点的别称，节点包含元素当然节点还有好多细化的种类；<br>根节点：root&gt;&gt;&gt;&gt;HTML没有父节点；<br>节点操作：（通过父子系关系）<br>childNodes     获取当前元素的所有子节点；<br>nodeType       节点种类，返回值是数字；<br>nodeValue      获取（文字）节点的文本内容；<br>nodeName     返回node节点名称（#text，注释， 标签….）；<br>一个可以找出元素节点的方法；</p><h3 id="常见的节点类型："><a href="#常见的节点类型：" class="headerlink" title="常见的节点类型："></a>常见的节点类型：</h3><p>nodeType值：1 代表元素（DIV、BODY、LI、SPAN……. ）<br>nodeType值：2 属性代表属性节点 （class，src，href）<br>nodeType值：3 文本节点（text节点）<br>nodeType值：8 代表注释节点<br>nodeType值：9 代表document节点；</p><h3 id="innerHTML和nodeValue-当innerHTML和nodeValue分别作为左值的时候"><a href="#innerHTML和nodeValue-当innerHTML和nodeValue分别作为左值的时候" class="headerlink" title="innerHTML和nodeValue;(当innerHTML和nodeValue分别作为左值的时候)"></a>innerHTML和nodeValue;(当innerHTML和nodeValue分别作为左值的时候)</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">box.innerHTML = '<strong>abc</strong>';box.childNodes[0].nodeValue = '<strong>abc</strong>';innerHTML会将标签解析；nodeValue不会进行解析，会将标签名转译成字符串，直接输出；outerHTML/innerText (非W3C)</code></pre><h3 id="attributes属性"><a href="#attributes属性" class="headerlink" title="attributes属性"></a>attributes属性</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var oBox = document.getElementById('box');    console.log(oBox.attributes)                                      //  获取所有，该节点的属性信息；    console.log(oBox.attributes.length);                          //返回属性节点个数    console.log(oBox.attributes[0]);                                 //返回第一个属性节点    console.log(oBox.attributes[0].nodeType);                //2，属性    console.log(oBox.attributes[0].nodeValue);               //属性值    console.log(oBox.attributes['id']);                              //返回属性为 id 的节点    console.log(oBox.attributes.getNamedItem('id'));     // 获取 id 的节点；</code></pre><p>attributes属性 一般只用作获取，设置使用setAttribute()</p><h3 id="父（parent）、子（child）和同胞（sibling）"><a href="#父（parent）、子（child）和同胞（sibling）" class="headerlink" title="父（parent）、子（child）和同胞（sibling）"></a>父（parent）、子（child）和同胞（sibling）</h3><p>描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）。<br>    childNodes 获取当前元素节点的所有子节点</p><pre><code>firstChild 获取当前元素节点的第一个子节点lastChild 获取当前元素节点的最后一个子节点previousSibling 获取当前节点的前一个同级节点nextSibling 获取当前节点的后一个同级节点****以上五中方法都包含空白文本节点firstElementChild   获取当前元素节点的第一个元素子节点lastElementChild  获取当前元素节点的最后一个元素子节点ownerDocument 获取该节点的文档根节点，相当于documentparentNode 获取当前节点的父元素</code></pre><h3 id="创建文档碎片createDocumentFragment"><a href="#创建文档碎片createDocumentFragment" class="headerlink" title="创建文档碎片createDocumentFragment();"></a>创建文档碎片createDocumentFragment();</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var cache = document.createDocumentFragment();for( var i = 0 ; i < 1000; i ++ )&#123;    var opt = document.createElement("input");    opt.type="button";    opt.value = "删除";    cache.appendChild(opt);&#125;document.body.appendChild(cache);</code></pre><h3 id="DOM尺寸和位置"><a href="#DOM尺寸和位置" class="headerlink" title="DOM尺寸和位置"></a>DOM尺寸和位置</h3><h4 id="DOM尺寸"><a href="#DOM尺寸" class="headerlink" title="DOM尺寸"></a>DOM尺寸</h4><p>box.style.width<br>box.style.height<br>只能获取到内联style属性的CSS样式中的宽和高，如果有，获取;如果没有，则返回空</p><p>getStyle(box,”width”)<br>getStyle(box,”width”)<br>//如下getStyle方法的封装<br>通过计算获取元素的大小，无关你是否是行内、内联或者链接，它经过计算后得到的结果返回出来。如果本身设置大小，它会返回元素的大小，如果本身没有设置，非IE浏览器会返回默认的大小，IE浏览器返回auto。</p><p>box.clientWidth<br>box.clientHeight<br>返回了元素大小，但没有单位，默认单位是px，如果设置了其他的单位，比如100em之类，返回出来的结果还会转换为px像素（不含边框）</p><p>box.scrollWidth<br>box.scrollHeight<br>获取滚动内容的元素大小（当元素出现滚动条时，此属性指全部滚动内容的宽高）<br>返回了元素大小，默认单位是px。如果没有设置任何CSS的宽和高度，它会得到计算后的宽度和高度</p><p>box.offsetWidth<br>box.offsetHeight<br>返回了元素大小，默认单位是px。如果没有设置任何CSS的宽和高度，他会得到计算后的宽度和高度<br>包含盒模型中除margin以外的宽高（包含边框）<br>最稳定，使用最频繁<br>以上这三对方法都是只读的<br>  获取非行内样式（兼容问题）</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function getStyle(obj,attr)&#123;    //获取非行间样式，obj是对象，attr是值      if(obj.currentStyle)&#123;   //针对ie获取非行间样式            return obj.currentStyle[attr];      &#125;else&#123;            return getComputedStyle(obj,false)[attr];   //针对非ie      &#125;;&#125;;</code></pre><h4 id="位置坐标"><a href="#位置坐标" class="headerlink" title="位置坐标"></a>位置坐标</h4><p>box.clientLeft<br>box.clientTop<br>获取左边框和上边框的宽度<br>box.offsetLeft<br>box.offsetTop<br>获取元素当前相对于offsetParent父元素的位置<br>box.scrollTop<br>box.scrollLeft<br>获取滚动内容上方的位置(就是隐藏的内容的高度)<br>获取滚动内容左方的位置</p><p>offsetParent      这个属性的返回值是它根据谁定位的，如果它的所有父元素都没有定位，那么返回body</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node节点 </tag>
            
            <tag> 文档碎片 </tag>
            
            <tag> DOM尺寸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的DOM对象</title>
      <link href="/posts/116b.html"/>
      <url>/posts/116b.html</url>
      
        <content type="html"><![CDATA[<h2 id="DOM（Document-Object-Model-文档对象模型）"><a href="#DOM（Document-Object-Model-文档对象模型）" class="headerlink" title="DOM（Document Object Model 文档对象模型）"></a>DOM（Document Object Model 文档对象模型）</h2><p>DOM定义了表示和修改文档所需的对象、行为和属性，以及这些对象之间的关系。<br>当你想要改变网页行为的时候 你该怎么办呢？你不会用脚来踹网页或者用头来顶网页吧？这时候怎么办呢 ？<br>而你手中有javascript 这种工具！所以你就会考虑用javascript来改变网页行为.</p><h2 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h2><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="获取DOM节点"><a href="#获取DOM节点" class="headerlink" title="获取DOM节点"></a>获取DOM节点</h3><p>1、 document.getElementById(id名)<br>2、 getElementsByTagName(标签名) 得到的是一个集合（不止一个，是一堆）<br>3、 getElementsByName( ) 通过Name值获取元素，返回值是集合，通常用来获取有name的input的值；<br>注：1<em>不是所有的标签都有name值；  2</em>低版本的浏览器会有兼容问题；<br>4、 children属性，获得DOM元素的所有子元素；返回值是集合<br>5、 parentNode属性，获得DOM元素的父级元素<br>6、 getElementsByClassName(class名称)  但是：IE8以下不能用<br>7、 ES5选择器：<br>    document.querySelector ()  &gt;  一旦匹配成功一个元素，就不往后匹配了<br>    document.querySelectorAll ()  &gt;&gt;&gt;&gt; 强大到超乎想象;匹配到所有满足的元素, 支持IE8+</p><h3 id="属性获取和操作"><a href="#属性获取和操作" class="headerlink" title="属性获取和操作"></a>属性获取和操作</h3><p>1、getAttribute( )获取元素的属性值，他是节点的方法！所以前缀必须是节点！<br>document.getElementById( ID值 ).getAttribute( )<br>什么是元素属性呢？ class就是元素属性，写在标签内的所有东西都是标签属性， 比如link的href比如img的src….都是元素属性。<br>元素自带的属性可以直接用 . 语法获取，但是自定义属性需要 getAttribute() 和 setAttribute( ) 方法<br>2、setAttribute( )设置元素的属性。同上；<br>有些小小的兼容性问题，低版本IE不兼容；<br>设置的属性永远都是字符串类型<br>3、removeAttribute( )删除属性；同上；<br>兼容性问题同上；</p><h3 id="DOM元素类型-元素、文本和属性"><a href="#DOM元素类型-元素、文本和属性" class="headerlink" title="DOM元素类型(元素、文本和属性)"></a>DOM元素类型(元素、文本和属性)</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">nodeObj.nodeName // 节点名称  /*    元素节点：标签名（大写）    属性节点：属性名称    文本节点：#text*/nodeObj.nodeType // 1 ==> 元素节点  2 ==> 属性节点  3 ==> 文本节点</code></pre><h3 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h3><p>增、删、克隆节点<br>1.创建节点<br>var oDiv = document.createElement(“div”);<br>2.克隆节点<br>clonedNode = Node.cloneNode(boolean) // 只有一个参数，传入一个布尔值，true表示深客隆，复制该节点下的所有子节点；false表示浅克隆，只复制该节点<br>3.插入节点<br>parentNode.appendChild(childNode);  // 将新节点追加到子节点列表的末尾<br>parentNode.insertBefore(newNode, targetNode);//将newNode插入targetNode之前<br>4.替换节点<br>parentNode.replaceChild(newNode, targetNode); //使用newNode替换targetNode<br>5.移除节点<br>parentNode.removeChild(childNode);  // 移除目标节点<br>node.parentNode.removeChild(node);    //在不清楚父节点的情况下使用<br>childNode.remove()  //IE不支持</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
            <tag> DOM节点 </tag>
            
            <tag> 操作DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象</title>
      <link href="/posts/5.html"/>
      <url>/posts/5.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类——定义属性和方法<br>类的具体实现，继承了类所定义的属性和方法（是一种数据类型）</p><h3 id="类是对象的抽象，对象是类的实例"><a href="#类是对象的抽象，对象是类的实例" class="headerlink" title="类是对象的抽象，对象是类的实例"></a>类是对象的抽象，对象是类的实例</h3><p>程序 = 算法 + 数据结构<br>js是基于对象的编程语言<br>对象可以定义和描述很复杂的数据，让算法变的简单高效</p><h3 id="js中的对象"><a href="#js中的对象" class="headerlink" title="js中的对象"></a>js中的对象</h3><p>js语言中一切皆为对象，比如数字、字符串、数组、Math、Object、函数<br>js中对象的本质：属性和方法的集合（无序，所以对象没有length属性）<br>用官方一点的语言来解释对象：<br>什么是对象，其实就是一种类型，即引用类型。而对象的值就是引用类型的实例。在 ECMAScript 中引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称做为类，但 ECMAScript6以前却没有这种东西。虽然 ECMAScript 是一门面向对象的语言，却不具备传统面向对象语言所支持的类等基本结构。</p><h3 id="创建对象的方式："><a href="#创建对象的方式：" class="headerlink" title="创建对象的方式："></a>创建对象的方式：</h3><p>1、字面量<br>  var obj = {<br>        键值对<br>        key:value<br>    }</p><p>2、通过new运算符<br>  var obj = new Object()<br>对象遍历：for…in循环（隐式迭代）</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var obj= new Object();obj.name = "zhangsan";obj.age = 18;obj["gender"] = "male";for(var key in obj)&#123;    console.log(key);    console.log(obj[key]);&#125;</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一组数据（一个变量来承载）</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "Hello world"; // 一个变量存放一个数据var arr = [1,2,3,4,5,6,7,8,9];//往数组结尾插入元素arr[arr.length] = 20</code></pre><h3 id="数组有两种定义方式"><a href="#数组有两种定义方式" class="headerlink" title="数组有两种定义方式"></a>数组有两种定义方式</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [];//字面量的方式var arr = new Array();//构造函数的方式var arr = new Array(10);//一个参数指数组长度为10,也被称为稀疏数组var arr = new Array(10，20，30);//多个参数指定义数组元素</code></pre><h3 id="稀疏数组：、"><a href="#稀疏数组：、" class="headerlink" title="稀疏数组：、"></a>稀疏数组：、</h3><p>就是包含从0开始的不连续索引的数组。也就是说数组中大部分的内容值都未被使用（或都为零）。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = new Array(3);   //数组没有元素，但是length是3console.log(arr);    // [empty × 3]</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">//另一种生成稀疏数组的方法var arr = []arr[1000] = 1 //数组的长度为1001，但是实际的元素只有1个</code></pre><p>实际上，JavaScript并没有常规的数组，所有的数组其实就是个对象，只不过会自动管理一些”数字”属性和length属性罢了。<br>说的更直接一点，JavaScript中的数组根本没有索引，因为索引应该是数字，而JavaScript中数组的索引其实是字符串：arr[1]其实就是arr[“1”]，给arr[“1000”] = 1，arr.length也会自动变为1001。<br>这些表现的根本原因就是：JavaScript中的对象就是字符串到任意值的键值对。注意键只能是字符串。</p><h3 id="因为js是弱类型语言，所以数组也是弱类型，同一个数组变量里可以有各种不同类型的元素"><a href="#因为js是弱类型语言，所以数组也是弱类型，同一个数组变量里可以有各种不同类型的元素" class="headerlink" title="因为js是弱类型语言，所以数组也是弱类型，同一个数组变量里可以有各种不同类型的元素"></a>因为js是弱类型语言，所以数组也是弱类型，同一个数组变量里可以有各种不同类型的元素</h3><p>数组的长度arr.length<br>数组的索引（下标）arr[0]  - arr[arr.length-1]</p><h3 id="数组遍历-（for循环）"><a href="#数组遍历-（for循环）" class="headerlink" title="数组遍历 （for循环）"></a>数组遍历 （for循环）</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [9,2,35,5,74,12,43,4];for(var i = 0; i < arr.length; i++)&#123;    console.log(arr[i]);&#125;</code></pre><h3 id="for…in（ES5）-遍历稀疏数组的时候不会遍历到undefined"><a href="#for…in（ES5）-遍历稀疏数组的时候不会遍历到undefined" class="headerlink" title="for…in（ES5）  遍历稀疏数组的时候不会遍历到undefined"></a>for…in（ES5）  遍历稀疏数组的时候不会遍历到undefined</h3><p>主要用于获得数组的索引和对应的值</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [9,2,35,5,74,12,43,4];for(var key in arr)&#123;    console.log(key); //获得索引值    console.log(typeof key); //string类型，证明这个索引值是字符类型    console.log(arr[key]);&#125;</code></pre><h3 id="for…of（ES6）"><a href="#for…of（ES6）" class="headerlink" title="for…of（ES6）"></a>for…of（ES6）</h3><p>主要用于获得数组的值</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [9,2,35,5,74,12,43,4];for(var value of arr)&#123;    console.log(value);&#125;</code></pre><h3 id="数组是引用类型"><a href="#数组是引用类型" class="headerlink" title="数组是引用类型"></a>数组是引用类型</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "Hello World";var str2 = str;//内存开辟另外一段空间存放str2var arr = [1,2,3,4,5,6,7,8,9];var arr2 = arr;//arr和arr2指向同一段存储空间</code></pre><p>基本数据类型：number、string、boolean、undefined、null<br>引用数据类型：object（array也属于object）、function</p><h3 id="函数的值传递和引用传递"><a href="#函数的值传递和引用传递" class="headerlink" title="函数的值传递和引用传递"></a>函数的值传递和引用传递</h3><p>数组常见API（concat\join\reverse\slice\splice\toString\sort）<br>concat()连接两个或更多的数组，并返回结果。<br>join()把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。<br>pop()删除并返回数组的最后一个元素<br>push()向数组的末尾添加一个或更多元素，并返回新的长度。<br>shift()删除并返回数组的第一个元素<br>unshift()向数组的开头添加一个或更多元素，并返回新的长度。<br>reverse()颠倒数组中元素的顺序。<br>slice()从某个已有的数组返回选定的元素<br>sort()对数组的元素进行排序<br>splice()删除元素，并向数组添加新元素。<br>toString()把数组转换为字符串，并返回结果。</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象/类 </tag>
            
            <tag> 稀疏数组 </tag>
            
            <tag> for/in </tag>
            
            <tag> for/of </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件</title>
      <link href="/posts/4.html"/>
      <url>/posts/4.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS运行和编译"><a href="#JS运行和编译" class="headerlink" title="JS运行和编译"></a>JS运行和编译</h2><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>查找基本语法有没有错误</p><h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><p>执行之前进行预解析<br>var、function关键字提前到当前作用域的顶部，变量默认值为undefined，函数默认值为函数体代码块，当函数与变量重名时，保留函数。</p><h2 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h2><p>全局变量的生命周期直至浏览器卸载页面才会结束。<br>局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="用户的行为：onclick、ondblclick、onfocus、onblur、window-onload"><a href="#用户的行为：onclick、ondblclick、onfocus、onblur、window-onload" class="headerlink" title="用户的行为：onclick、ondblclick、onfocus、onblur、window.onload"></a>用户的行为：onclick、ondblclick、onfocus、onblur、window.onload</h3><p>是用户跟页面的交互，当用户跟页面进行一些“交流”的时候，页面通过js就会触发一些事件，比如鼠标点击的时候就会触发onclick事件，给这个事件绑定一个函数，那么这个时候函数就会被调用，代码就会被执行</p><h3 id="事件类型："><a href="#事件类型：" class="headerlink" title="事件类型："></a>事件类型：</h3><p>鼠标事件：click，dbclick，mousedown，mouseup，mouseover，mouseout，mouseenter、     mouseleave、mousemove<br>鼠标滚轮：scroll，mousewheel<br>鼠标右键（上下文菜单：在不同环境下右键菜单不一样）：contextmenu<br>  mouseover：鼠标在元素身上移动穿过子元素的时候会被反复触发<br>  mouseenter：只是在进入元素的时候触发<br>键盘事件：keydown，keyup，keypress<br>表单事件：对表单元素操作之后会触发的事件<br>  单选框、多选框、下拉菜单 状态改变的时候会触发  onchange 事件<br>  表单提交的时候会触发 onsubmit ，触发在<form>元素身上</form></p><h2 id="this关键字-事件函数里面的this指的是事件触发对象"><a href="#this关键字-事件函数里面的this指的是事件触发对象" class="headerlink" title="this关键字:事件函数里面的this指的是事件触发对象"></a>this关键字:事件函数里面的this指的是事件触发对象</h2>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件 </tag>
            
            <tag> this </tag>
            
            <tag> 变量生命周期 </tag>
            
            <tag> 运行编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的MATH和Date对象</title>
      <link href="/posts/6.html"/>
      <url>/posts/6.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h2><p>对象的类型是Object。<br>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…<br>javaScript中万事万物皆对象<br>想要有对象怎么办？</p><h2 id="创建对象：（创建两种方式-字面量和new运算符）"><a href="#创建对象：（创建两种方式-字面量和new运算符）" class="headerlink" title="创建对象：（创建两种方式:字面量和new运算符）"></a>创建对象：（创建两种方式:字面量和new运算符）</h2><h3 id="1-New一个对象出来；"><a href="#1-New一个对象出来；" class="headerlink" title="1.New一个对象出来；"></a>1.New一个对象出来；</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var obj = new Object();//找到对象了  >>>  第一个想到的就是属性；//给对象添加一个属性；obj.bianmei='哇真的变漂亮了' ;obj.say=function()&#123;    alert(this.bianmei);&#125;obj.say();delete obj.jian; //删除对象的属性</code></pre><p>obj的属性可以是一个函数，这个时候也叫方法；<br>obj函数内的指针this，指向obj对象本身；</p><h2 id="javaScript内置对象-十个"><a href="#javaScript内置对象-十个" class="headerlink" title="javaScript内置对象(十个)"></a>javaScript内置对象(十个)</h2><p>1.Object对象        是所有JavaScript对象的超类(基类)<br>2.Array对象          数组对象—定义数组属性和方法<br>3.Boolean对象     布尔对象—布尔值相关<br>4.Date对象           日期对象—日期时间相关<br>5.Error对象           错误对象—处理程序错误<br>6.Function对象     函数对象—定义函数属性和方法<br>7.Math对象            数学对象—各种数学运算工具(不是构造函数)<br>8.Number对象       数字对象—定义数字属性和方法<br>9.RegExp对象        正则表达式对象—定义文本匹配与筛选规则<br>10.String对象        字符串对象—定义字符串属性和方法</p><h2 id="Date内置对象"><a href="#Date内置对象" class="headerlink" title="Date内置对象"></a>Date内置对象</h2><p>日期对象创建<br>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总毫秒数（时间戳）<br>  var date = new Date();//当前时间的日期对象<br>  var data = new Date(2012,6,10);//2012年7月10号的日期对象</p><h3 id="get系列API"><a href="#get系列API" class="headerlink" title="get系列API"></a>get系列API</h3><p>getFullYear()<br>返回年<br>getMonth()<br>返回月份0—11<br>getDate()<br>返回某一天<br>getDay()<br>返回星期0-6<br>getHours()<br>返回小时<br>getMinutes()<br>返回分钟<br>getSeconds()<br>返回秒<br>getTime()<br>返回1970年1月1日午夜到指定日期（字符串）的毫秒数</p><h3 id="set系列API"><a href="#set系列API" class="headerlink" title="set系列API"></a>set系列API</h3><p>setFullYear()<br>设置年份<br>setMonth()<br>设置月<br>setDate()<br>设置天<br>setHours()<br>设置小时<br>setMinutes()<br>设置分钟<br>setSeconds()<br>设置秒<br>setTime()<br>使用毫秒的形式设置时间对象</p><h2 id="★注意"><a href="#★注意" class="headerlink" title="★注意:"></a>★注意:</h2><p>1、setDay( 这个真没有!!!!,星期是通过设定日期自动计算的 )<br>2、set系列API可以设置比当前范围更精细的时间<br>比如：setFullYear（2012，3，5）  设置日期为2018年4月5号<br>setHours（13，30，0）  设置时间为13:30:00</p><h3 id="getMonth："><a href="#getMonth：" class="headerlink" title="getMonth："></a>getMonth：</h3><p>可选,介于 0 ~ 11 之间：如果不填，取系统当月<br>-1 为去年的最后一个月<br>12 为明年的第一个月<br>13 为明年的第二个月</p><h3 id="getDay"><a href="#getDay" class="headerlink" title="getDay()"></a>getDay()</h3><p>返回星期 0-6</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> date </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS函数</title>
      <link href="/posts/3.html"/>
      <url>/posts/3.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数：一个工具，被封装好可重复执行的一段代码块，函数的功能相对单一"><a href="#函数：一个工具，被封装好可重复执行的一段代码块，函数的功能相对单一" class="headerlink" title="函数：一个工具，被封装好可重复执行的一段代码块，函数的功能相对单一"></a>函数：一个工具，被封装好可重复执行的一段代码块，函数的功能相对单一</h2><p>把某一段代码放在函数里面进行封装，可以避免在非必要情况下调用该代码，也就是说我们可以让一段代码在特定情况下再去执行，而且每次需要执行这一段代码的时候只需调用一下这个函数即可（函数名）<br>我们在需要的时候可以调用一个封装好的函数，函数内的一些代码就会被执行，功能就会被实现</p><h3 id="系统函数："><a href="#系统函数：" class="headerlink" title="系统函数："></a>系统函数：</h3><p>parseInt()   alert()  prompt()  eval()</p><h3 id="函数的声明和使用"><a href="#函数的声明和使用" class="headerlink" title="函数的声明和使用"></a>函数的声明和使用</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">//通过function关键字声明一个函数，跟上函数名，一堆小括号，一堆花括号，花括号里面放代码块//提升到顶部function test()&#123;    //可重复执行的代码块&#125;  test();//表达式定义法//不会提升var test1 = function()&#123;    //可重复执行的代码块&#125;for (var i = 0; i < 10; i++) &#123;    test1();&#125;</code></pre><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>形参：形式参数，声明函数的时候写在小括号里面的参数，无需var<br>1.实参：实际参数，在函数调用的时候需要传递实际有值得参数<br>2.实参个数大于形参，多余实参自动舍弃<br>3.形参个数大于形参，多余形参默认为undefined<br>4.实参副本arguments：可以在函数内部使用arguments接收所传递过来的参数，是一个集合</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function test()&#123;    console.log(arguments);    console.log(arguments.length);&#125;        test(1,2,3,5,6) // 打印 1,2,3,5,6   长度为5</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="作用域：变量的作用范围"><a href="#作用域：变量的作用范围" class="headerlink" title="作用域：变量的作用范围"></a>作用域：变量的作用范围</h4><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>作用范围为整个程序的执行范围<br>在函数体外部定义的变量就是全局变量<br>在函数体内部不使用var定义的也是全局变量</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>作用范围是某个函数体内部<br>在函数体内部通过var关键字定义的变量或者形参，都是局部变量<br>当局部变量与全局变量重名时，在函数体内部局部变量优先于全局变量</p><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>变量的声明会提升至当前作用域的最顶端，但不会提升赋值</p><h3 id="return关键字"><a href="#return关键字" class="headerlink" title="return关键字"></a>return关键字</h3><p>1.结束函数的执行<br>2.交回函数执行权<br>3.返回一个结果到全局</p><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>是一种数据结构，指的是数据存取的方式，当定义一个变量时，内存会开辟一段空间<br>栈（ Stack）：先进后出（FILO），在栈顶做插入（压栈）和删除操作（出栈）。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>先进先出（FIFO），在队头做删除操作,在队尾做插入操作。</p><h4 id="堆和它们不同，代码执行时系统动态分配，不存在是先进后出还是先进先出。"><a href="#堆和它们不同，代码执行时系统动态分配，不存在是先进后出还是先进先出。" class="headerlink" title="堆和它们不同，代码执行时系统动态分配，不存在是先进后出还是先进先出。"></a>堆和它们不同，代码执行时系统动态分配，不存在是先进后出还是先进先出。</h4><h3 id="执行环境执行栈（也称执行上下文–execution-context）"><a href="#执行环境执行栈（也称执行上下文–execution-context）" class="headerlink" title="执行环境执行栈（也称执行上下文–execution context）"></a>执行环境执行栈（也称执行上下文–execution context）</h3><p>当JavaScript解释器初始化执行代码时，它首先默认进入全局执行环境，从此刻开始，函数的每次调用都会创建一个新的执行环境，每一个执行环境都会创建一个新的环境对象压入栈中。<br>当执行流进入一个函数时，函数的环境对象就会被压入一个环境栈中（execution stack）。在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>内层环境可以访问外层中的变量和函数，而外层环境不能访问内层的变量和函数</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>程序调用自身的编程技巧称为递归（ recursion）。<br>递归，就是在运行的过程中调用自己，本质就是循环。<br>构成递归需具备的条件</p><ol><li>子问题须与原始问题为同样的事，且更为简单；</li><li>不能无限制地调用本身，须有个出口，化简为非递归状况处理。<br>由于递归是函数本身一层一层压栈，导致先入栈的不能出栈，空间占满以后就会造成堆栈溢出</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>1、利用递归求100的阶乘<br>2、编写函数计算任意数字的阶乘（两种方法）<br>3、函数和循环结合打印任意乘法表<br>4、编写函数实现：两个数平方的阶乘相加的和<br>要求：三个函数实现，一个求阶乘，一个求平方，第三个函数利用这两个函数求出最终结果<br>5、如果一个数恰好等于它的因数（除自身以外）之和，则称该数为“完全数” perfect number。<br>请列出m~n（m&lt;n）的所有完全数（要求用两个函数实现）</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> function </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的BOM对象</title>
      <link href="/posts/b140.html"/>
      <url>/posts/b140.html</url>
      
        <content type="html"><![CDATA[<h2 id="BOM（Browser-Object-Model-浏览器对象模型）"><a href="#BOM（Browser-Object-Model-浏览器对象模型）" class="headerlink" title="BOM（Browser Object Model  浏览器对象模型）"></a>BOM（Browser Object Model  浏览器对象模型）</h2><h3 id="window是全局浏览器内置顶级对象"><a href="#window是全局浏览器内置顶级对象" class="headerlink" title="window是全局浏览器内置顶级对象"></a>window是全局浏览器内置顶级对象</h3><p>表示浏览器中打开的窗口（没有应用于window对象的公开标准，不过所有浏览器都支持该对象）<br>Window 对象表示一个浏览器窗口或一个框架。<br>在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。<br>也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。<br>例如，可以只写 document，而不必写 window.document。<br>同样，可以把当前窗口对象的方法当作函数来使用，如只写 alert()，而不必写 Window.alert()。<br>除了上面列出的属性和方法，Window 对象还实现了核心 JavaScript 所定义的所有全局属性和方法。</p><h3 id="1、全局变量默认是挂在window下的"><a href="#1、全局变量默认是挂在window下的" class="headerlink" title="1、全局变量默认是挂在window下的"></a>1、全局变量默认是挂在window下的</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var  a = 123;alert(window.a)//123</code></pre><h3 id="2、window下的子对象"><a href="#2、window下的子对象" class="headerlink" title="2、window下的子对象"></a>2、window下的子对象</h3><h4 id="（1）location"><a href="#（1）location" class="headerlink" title="（1）location"></a>（1）location</h4><p>window.location.href          当前页面的 URL，可以获取，可以修改（页面跳转）<br>window.location.hostname      web 主机的域名<br>window.location.pathname      当前页面的路径和文件名<br>window.location.port          web 主机的端口 （80 或 443）<br>window.location.protocol      所使用的 web 协议（http:// 或 https://）<br>window.location.search        请求参数（？后面的内容）</p><p>window.location.reload();<br>刷新页面，一般情况下给reload()传递一个true，让他刷新，并不使用缓存。缓存的东西一般为js文件，css文件等。<br>用这个方法可以让自己不能动的页面动起来了。刷新当前页面。</p><h4 id="（2）window-navigator"><a href="#（2）window-navigator" class="headerlink" title="（2）window.navigator"></a>（2）window.navigator</h4><p>navigator.appName      返回获取当前浏览器的名称。<br>navigator.appVersion    返回 获取当前浏览器的版本号。<br>navigator.platform        返回 当前计算机的操作系统。<br>以上属性已经在逐渐被抛弃了。一个新的属性将替代这些属性。</p><p>navigator.userAgent   返回浏览器信息（可用此属性判断当前浏览器）</p><h5 id="判断当前浏览器类型的代码："><a href="#判断当前浏览器类型的代码：" class="headerlink" title="判断当前浏览器类型的代码："></a>判断当前浏览器类型的代码：</h5><pre class=" language-lang-javascript"><code class="language-lang-javascript">function isBrowser() &#123;    var userAgent = navigator.userAgent;    //微信内置浏览器    if(userAgent.match(/MicroMessenger/i) == 'MicroMessenger') &#123;        return "MicroMessenger";    &#125;    //QQ内置浏览器    else if(userAgent.match(/QQ/i) == 'QQ') &#123;        return "QQ";    &#125;    //Chrome    else if(userAgent.match(/Chrome/i) == 'Chrome') &#123;        return "Chrome";    &#125;    //Opera    else if(userAgent.match(/Opera/i) == 'Opera') &#123;        return "Opera";    &#125;    //Firefox    else if(userAgent.match(/Firefox/i) == 'Firefox') &#123;        return "Firefox";    &#125;    //Safari    else if(userAgent.match(/Safari/i) == 'Safari') &#123;        return "Safari";    &#125;    //IE    else if(!!window.ActiveXObject || "ActiveXObject" in window) &#123;        return "IE";    &#125;    else &#123;        return "未定义:"+userAgent;    &#125;&#125;</code></pre><h4 id="（3）history"><a href="#（3）history" class="headerlink" title="（3）history"></a>（3）history</h4><p>history.go(1)    参数可写任意整数，正数前进，负数后退<br>history.back()   后退<br>history.forward() 前进</p><h4 id="（4）screen-屏幕"><a href="#（4）screen-屏幕" class="headerlink" title="（4）screen: 屏幕"></a>（4）screen: 屏幕</h4><p>window.screen.width 返回当前屏幕宽度(分辨率值)<br>window.screen.height 返回当前屏幕高度(分辨率值)</p><h4 id="（5）window下的弹框方法"><a href="#（5）window下的弹框方法" class="headerlink" title="（5）window下的弹框方法"></a>（5）window下的弹框方法</h4><p>alert()   prompt()  confirm()</p><h4 id="（6）定时器"><a href="#（6）定时器" class="headerlink" title="（6）定时器"></a>（6）定时器</h4><p>超时定时器        间隔定时器<br>setTimeout       setInterval<br>clearTimeout     clearInterval</p><h4 id="（7）window-onload"><a href="#（7）window-onload" class="headerlink" title="（7）window.onload"></a>（7）window.onload</h4><h4 id="（8）window-onscroll"><a href="#（8）window-onscroll" class="headerlink" title="（8）window.onscroll"></a>（8）window.onscroll</h4><p>var scrolltop=document.documentElement.scrollTop||document.body.scrollTop; //兼容</p><h4 id="（9）window-window-onresize"><a href="#（9）window-window-onresize" class="headerlink" title="（9）window.window.onresize"></a>（9）window.window.onresize</h4>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
            <tag> 定时器 </tag>
            
            <tag> window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS程序执行</title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<p> 顺序结构：按照由上到下的顺序一行一行地执行的程序结构<br> 分支结构：根据不同的条件判断来决定程序执行走向的结构（也叫选择结构）<br> 循环结构：需要重复执行同一操作的程序结构称为循环结构。</p><h3 id="if-判断逻辑语句"><a href="#if-判断逻辑语句" class="headerlink" title="if 判断逻辑语句"></a>if 判断逻辑语句</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">if(true)&#123;    //会执行的语句&#125;if(false)&#123;    //会跳过不执行的语句&#125;if(判断条件)&#123; //当if括号中结果为true时执行语句1，否则执行语句2    //语句1&#125;else&#123;    //语句2&#125;if(判断条件1)&#123; //当条件1结果为true时执行语句1    //语句1&#125;else if(判断条件2)&#123; //当条件1结果为false而且条件2结果为true时执行语句2    //语句2&#125;else&#123; //当条件1条件2结果都为false时执行语句3    //语句3&#125;</code></pre><p>我们都知道，if括号中只需要布尔类型值。那么在if判断中，所有的数据类型都会被隐式转换为布尔类型。<br>注意：0、-0、null、””、false、undefined 或者 NaN在if条件里结果为false</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>除了+运算符具有两层含义以外，- <em> /只有数学意义，所以当进行- </em> /运算的时候默认会将运算符两侧的数据类型隐式转换为数字类型，再进行运算。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var a = 2, b = "2";if(a == b)&#123;    alert("a和b相等");    // 会弹  &#125;if(a === b)&#123;    alert("a和b相等");    // 不会弹  &#125;if(1 == true)&#123;    alert("数字1是true");&#125;if(a = b)&#123;    alert("a和b相等");&#125;//一个等号代表赋值操作，结果为等号右边的值</code></pre><h3 id="switch-case多分支语句"><a href="#switch-case多分支语句" class="headerlink" title="switch case多分支语句"></a>switch case多分支语句</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">switch(语句)&#123;  //语句的结果与每一条case内容进行匹配    case 1:       alert(1);           break;        case 2:             alert(2);             break;        case 3:            alert(3);            break;        default:            alert(0);&#125;</code></pre><p>注意switch的应用场景（有多个确定值需要判断的时候）；<br>注意case穿透，要加break语句（如果程序没有发现break语句，那么解析器会继续向下解析）;</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var a = 1;switch(a)&#123;     case 1:       alert(1);    case 2:        alert(2);    case 3:        alert(3);    default:        alert(0);&#125;//每一个alert都会被执行，而且alert会阻断程序进程</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>1.判断一个整数，属于哪个范围：大于0；小于0；等于0<br>2.判断一个整数是偶数还是奇数，并输出判断结果<br>3.开发一款软件，根据公式（身高-108）*2=体重，可以有10斤左右的浮动。来观察测试者体重是否合适<br>4.判断一个三位数是否是水仙花数（如：153 = 1^3 + 5^3 + 3^3，那么153就是水仙花数）</p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>1.点击切换div颜色<br>2.输入分数，判定成绩等级<br>3.输入年份，计算某一年是否是闰年<br>4.输入月份，显示当月的天数，要求：利用case穿透简化代码<br>5.输入数字，显示星期几，如：输入0，弹出星期日，以此类推（两种方法）<br>6.设计一个猜拳游戏：<br>假设： 1代表石头 2代表剪刀 3代表 布<br>计算机每次随机出现1—3中的任意一个数（parseInt (Math.random()*3) + 1）<br>玩家也有三种状态，用玩家出的数和计算机出的数进行比对，按照游戏规则比出胜负。</p><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p>1.根据一个数字日期，判断这个日期是这一年的第几天<br>例如： 20160211，计算后结果为42<br>2.制作一个表单，包括用户名，密码，电话<br>要求：<br>1）做好看点<br>2）点击保存按钮时，使用JS判断用户的联系电话是否为纯数字，如果用户输入有错误，使用alert()弹框警告<br>3）判断用户名是否填写，如果空白，使用alert弹框警告<br>4）判断密码长度，必须大于8位，否则alert警告<br>提示：通过length属性取得字符串的长度</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var str = "hello";str.length // 得到长度</code></pre>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> if/else </tag>
            
            <tag> switch/case </tag>
            
            <tag> 显/隐式转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS循环结构</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">while(条件)&#123;    //条件成立就会反复执行这里的代码&#125;var count = 0;while(count < 10)&#123;    count++;    document.write("Hello world");&#125;</code></pre><p>注意死循环： 没有终止条件的循环即为死循环，在代码中应尽量避免死循环</p><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">do&#123;    //先执行一遍代码    //while条件成立再继续反复执行&#125;while(条件)</code></pre><h3 id="while和do…while循环的区别"><a href="#while和do…while循环的区别" class="headerlink" title="while和do…while循环的区别"></a>while和do…while循环的区别</h3><p>do…while循环至少会执行一遍，不管条件是否成立，但是while循环如果初始条件不成立一遍也不会执行。</p><h3 id="break和continue关键字"><a href="#break和continue关键字" class="headerlink" title="break和continue关键字"></a>break和continue关键字</h3><p>break：跳出循环体，整个循环结束<br>continue：结束本次循环进入下一次循环体</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">for (var i = 0; i < 10; i++) &#123;    console.log(i);&#125;</code></pre><p>如下图所示：注意for循环时的执行顺序,并且：for循环1，2，4步是可选的</p><!-- ![for的循环执行顺序](JS循环结构/for.png) 引入的图片 --><h3 id="三种循环的联系和区别"><a href="#三种循环的联系和区别" class="headerlink" title="三种循环的联系和区别"></a>三种循环的联系和区别</h3><p>1、都是会反复执行的代码块<br>2、大部分情况下可以互相替换<br>3、do…while至少执行一次，while和for有可能0次，while不太能确定执行次数，for可以</p><h3 id="练习（while和for两种方式）"><a href="#练习（while和for两种方式）" class="headerlink" title="练习（while和for两种方式）"></a>练习（while和for两种方式）</h3><p>1.打印100以内所有偶数的和<br>2.求出1-1/2+1/3-1/4…..1/100的和<br>3.打印出1000-2000年中所有的闰年，并以每行四个数的形式输出<br>4.打印九九乘法表<br>5.求1+2!+3!+…+20!的值<br>6.有一个棋盘，有64个方格，在第一个方格里面放1粒芝麻重量是0.00001kg，第二个里面放2粒，第三个里面放4，按每一个格子是前一个格子的二倍（第四个格子放8个）计算，问棋盘上放的所有芝麻的重量是多少？<br>7.打印100–200之间所有能被3或者7整除的数<br>8.计算100的阶乘</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> while </tag>
            
            <tag> do...while </tag>
            
            <tag> break和continue </tag>
            
            <tag> for </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客文章模板</title>
      <link href="/posts/8e47.html"/>
      <url>/posts/8e47.html</url>
      
        <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>正文随意发挥。。。。。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//这里是js代码</code></pre><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><p>正文随意发挥。。。。。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//这里是js代码</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
